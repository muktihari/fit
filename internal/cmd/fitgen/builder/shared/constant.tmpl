{{ define "constant" }}
// Code generated by internal/cmd/fitgen/main.go. DO NOT EDIT.
// SDK Version: {{ .SDKVersion }}

// Copyright 2023 The Fit SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

{{ .PackageDoc }}
package {{ .Package }}


import (
    {{ if .Imports -}}
        {{ range $_, $v := .Imports }}
            {{ printf "%q" $v }}
        {{ end -}}
    {{ end -}}
	{{ if .AllowRegister }}"fmt"{{ end }}
)

type {{ .Type }} {{ .Base }}

const (
    {{ range .Constants -}}
    {{ .Name }} {{ .Type }} {{ .Op }} {{ .Value }} {{ if .Comment }} // {{ .Comment }} {{ end }}
    {{ end -}}
    {{ .Invalid.Name }} {{ .Invalid.Type }} {{ .Invalid.Op }} {{ .Invalid.Value }}
)

{{ if .AllowRegister }}
var {{ .Type | ToLower }}ToString = map[{{ .Type }}]string{}
var stringTo{{ .Type }} = map[string]{{ .Type }}{}
{{ end }}

{{ $r := printf "%.1s" $.Type | ToLower }}
{{ $vals := print $.Type "ToString" | ToLower }}
func ({{ $r }} {{ $.Type }}) String() string {
	switch {{ $r }} {
	{{ range .Constants -}}
		{{ if not (eq (printf "%.2s" .Name) "//") -}}
		case {{ .Name }}:
			return {{ printf "%q" .String }}
		{{ end -}}
	{{ end -}}
	default:
	{{ if .AllowRegister -}}
		if val, ok := {{ .Type | ToLower }}ToString[{{ $r }}]; ok {
			return val
		}
	{{ end -}}
	return "{{ .Type }}Invalid(" + {{- if eq (sprintf "%.4s" .Base) "byte" -}}
			strconv.Itoa(int({{ $r }}))
		{{- else if eq (sprintf "%.3s" .Base) "int" -}}
			strconv.FormatInt(int64({{ $r }}), 10)
		{{- else if eq (sprintf "%.4s" .Base) "uint" -}}
			strconv.FormatUint(uint64({{ $r }}), 10)
		{{- else if eq (sprintf "%.7s" .Base) "float32" -}}
			strconv.FormatFloat(float64({{ $r }}), 'f', -1, 32)
		{{- else if eq (sprintf "%.7s" .Base) "float64" -}}
			strconv.FormatFloat(float64({{ $r }}), 'f', -1, 64)
		{{- else if eq .Base "string" -}}
			string({{ $r }})
	{{ end -}} + ")"
	}
}

// FromString parse string into {{ .Type }} constant it's represent, return {{ .Type }}Invalid if not found.
func {{ .Type }}FromString(s string) {{ .Type }} {
	switch s {
	{{ range .Constants -}}
	{{ if and (not (eq (printf "%.2s" .Name) "//")) (not (eq .String "invalid")) -}}
		case {{ printf "%q" .String }}:
			return {{ .Name }}
		{{ end -}}
	{{ end -}}
	default:
		{{ if .AllowRegister -}}
		if val, ok := stringTo{{ .Type }}[s]; ok {
			return val
		}
		{{ end -}}
		return {{ .Invalid.Name }}
	}
}

// List returns all constants.
func List{{ .Type }}() []{{ .Type }} {
	{{ if .AllowRegister -}}
		list := []{{ .Type }} {
			{{ range .Constants -}}
				{{ .Name }},
			{{ end -}}
		}
		for k := range {{ .Type | ToLower }}ToString {
			list = append(list, k)
		}
		return list
	{{ else -}}
		return []{{ .Type }} {
			{{ range .Constants -}}
				{{ .Name }},
			{{ end -}}
		}
	{{ end -}}
}

{{ if .AllowRegister }}
{{ template "register" . }}
{{ end }}

{{ end }} // end of constant

// Register Manufacturer Specific Type:
{{ define "register" }}
// {{ .Type }}Register registers a manufacturer specific {{ .Type }} so that the value can be recognized. 
// It is recommended to define the constants somewhere else to track your own specifications.
// 
// This is intended for those who prefer using this SDK as it is without the need to generate custom SDK using cmd/fitgen.
func {{ .Type }}Register(v {{ .Type }}, s string) error {
	if v >= {{ .Type}}Invalid {
		return fmt.Errorf("could not register outside max range: %d", {{ .Type}}Invalid)
	}

    switch v {
    {{ range .Constants -}}
    case {{ .Name }}:
		return fmt.Errorf("duplicate: %d is already exist for {{ .Name }}", v)
    {{ end -}}
    }

	{{ .Type | ToLower }}ToString[v] = s
	stringTo{{ .Type }}[s] = v

	return nil
}
{{ end }}