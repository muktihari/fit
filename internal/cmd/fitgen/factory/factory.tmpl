// This Template contains multiple template definitions.

{{ define "header" }}
// Code generated by internal/cmd/fitgen/main.go. DO NOT EDIT.

// Copyright 2023 The FIT SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

{{ end }}

// Template definition for [factory.go]
{{ define "factory" }}
{{ template "header" . }}
package {{ .Package }}

import (
	"fmt"
	"sync"

	"github.com/muktihari/fit/profile"
	"github.com/muktihari/fit/profile/basetype"
	"github.com/muktihari/fit/profile/typedef"
	"github.com/muktihari/fit/profile/untyped/fieldnum"
	"github.com/muktihari/fit/profile/untyped/mesgnum"
	"github.com/muktihari/fit/proto"
)

type errorString string

func (e errorString) Error() string { return string(e) }

const (
	// ErrRegisterForbidden occurs when trying to create manufacturer specific message outside available range.
	ErrRegisterForbidden = errorString("register is forbidden")

	// NameUnknown is the name of an unknown message or an unknown field.
	NameUnknown string = "unknown"
)


// Factory handles creation and registration for FIT's message and field.
type Factory struct {
	registeredMesgs map[typedef.MesgNum]proto.Message
}

// New creates new Factory with predefined messages.
// Use this if you work with multiple manufacturers that have different manufacturer specific messages, 
// Otherwise, use StandardFactory().
// 
// New is not receiving messages on purpose: to comply with FIT term and conditions which is not allowing edit on existing messages. 
// Receiving messages through here means we need to validate all of it, while RegisterMesg is already exist for that purpose.
func New() *Factory { return &Factory{} }

var ( // cache for CreateMesg method
	once	   sync.Once
	protoMesgs []proto.Message // data is populated on CreateMesg first invocation.
)

{{ template "create_mesg_doc" -}}
func (f *Factory) CreateMesg(num typedef.MesgNum) proto.Message {
	once.Do(func() { // populate data for the first invocation.
		protoMesgs = make([]proto.Message, {{ .LenMesgs }})
		var i int
		var fieldBases *[256]*proto.FieldBase
		for i, fieldBases = range mesgs {
			if fieldBases == nil {
				continue
			}
			var n byte
			for j := range fieldBases {
				if fieldBases[j] != nil {
					n++
				}
			}
			fields := make([]proto.Field, 0, n)
            
			var timestampNum byte = proto.FieldNumTimestamp
			mesgNum := typedef.MesgNum(i)
			switch mesgNum {
			case mesgnum.CoursePoint:
				timestampNum = fieldnum.CoursePointTimestamp
			case mesgnum.Set:
				timestampNum = fieldnum.SetTimestamp
			}

			// Place timestamp field at the first index since the field is frequently used.
			// This kind of ordering matches the fields' ordering in Profile.xlsx which put timestamp at the beginning.
			fieldBase := fieldBases[timestampNum]
			if fieldBase != nil {
				fields = append(fields, proto.Field{FieldBase: fieldBase})
			}
			for _, fieldBase = range fieldBases {
				if fieldBase != nil && fieldBase.Num != timestampNum {
					fields = append(fields, proto.Field{FieldBase: fieldBase})
				}
			}
			protoMesgs[i] = proto.Message{
				Num:    mesgNum,
				Fields: fields,
			}
		}
	})

	var mesg proto.Message
	if num < {{ .LenMesgs }} {
		mesg = protoMesgs[num]
	}
	if mesg.Num != num {
		mesg = f.registeredMesgs[num]
	}
	mesg.Num = num // In case of unknown field

	if len(mesg.Fields) != 0 {
		fields := make([]proto.Field, len(mesg.Fields))
		copy(fields, mesg.Fields)
		mesg.Fields = fields
	}

	return mesg
}

{{ template "create_field_doc" -}}
func (f *Factory) CreateField(mesgNum typedef.MesgNum, num byte) proto.Field {
	if mesgNum < {{ .LenMesgs }} && mesgs[mesgNum] != nil {
		fieldBase := mesgs[mesgNum][num]
		if fieldBase != nil {
			return proto.Field{FieldBase: fieldBase}
		}
		return createUnknownField(num)
	}
	if mesg, ok := f.registeredMesgs[mesgNum]; ok {
		for i := range mesg.Fields {
			if mesg.Fields[i].Num == num {
				return mesg.Fields[i]
			}
		}
	}
	return createUnknownField(num)
}

func createUnknownField(num byte) proto.Field {
	return proto.Field{FieldBase: &proto.FieldBase{Name: NameUnknown, Num: num, Scale: 1, Offset: 0}}
}

{{ template "register_mesg_doc" -}}
func (f *Factory) RegisterMesg(mesg proto.Message) error {
	if f.registeredMesgs == nil {
		f.registeredMesgs = make(map[typedef.MesgNum]proto.Message) // only alloc when needed
	}
	if mesg.Num > typedef.MesgNumMfgRangeMax {
		return fmt.Errorf("could not register outside max range: %d: %w", 
			typedef.MesgNumMfgRangeMax, ErrRegisterForbidden)
	}
	if mesg.Num < {{ .LenMesgs }} && mesgs[mesg.Num] != nil {
		return fmt.Errorf("could not register on reserved predefined message, mesg.Num %d (%s) is already exist: %w",
			mesg.Num, mesg.Num, ErrRegisterForbidden)
	}
	f.registeredMesgs[mesg.Num] = mesg
	return nil
}

// Use array to ensure O(1) lookup
var mesgs = {{ .Messages }}

{{ end }} // end of "factory"

// Template definition for [exported.go] 
{{ define "exported"}}
{{ template "header" . }}

package {{ .Package }}

 import (
	"github.com/muktihari/fit/proto"
	"github.com/muktihari/fit/profile/typedef"
)

 var std = New()

// StandardFactory returns standard factory.
func StandardFactory() *Factory { return std }

{{ template "create_mesg_doc" -}}
func CreateMesg(num typedef.MesgNum) proto.Message {
	return std.CreateMesg(num)
}

{{ template "create_field_doc" -}}
func CreateField(mesgNum typedef.MesgNum, num byte) proto.Field {
	return std.CreateField(mesgNum, num)
}

{{ template "register_mesg_doc" -}}
func RegisterMesg(mesg proto.Message) error {
	return std.RegisterMesg(mesg)
}

{{ end }} // end of "exported"

// Funcs & Methods Shared Documentations:
{{ define "create_mesg_doc" }}
// CreateMesg creates new message based on defined messages in the factory. If not found, it returns proto.Message{Num: num}.
//
// This will create a shallow copy of the Fields, so changing any value declared in Field's FieldBase is prohibited 
// (except in case of unknown field).
//
// NOTE: This method is not used by either the Decoder or the Encoder, and the data will only be populated once upon the first invocation.
// Unless you need most of the returned fields, it's recommended create an empty proto.Message{Num: num} then fill only the necessary fields 
// using CreateField method.
{{ end }}

{{ define "create_field_doc" }}
// CreateField creates new field based on defined messages in the factory. If not found, it returns new field with "unknown" name.
// 
// The returned field contains a pointer reference to FieldBase defined in the factory, so changing any value 
// declared in FieldBase is prohibited (except in the case of unknown field).
{{ end }}

{{ define "register_mesg_doc" }}
// RegisterMesg registers a new message that is not defined in the profile.xlsx. 
// You can not edit or replace existing predefined messages in the factory, you can only edit the messages you have registered.
// Please note, we don't use mutex for efficiency, since this is intended to be used on instantiation.
//
// By registering, any FIT file containing these messages can be recognized instead of returning "unknown" message.
{{ end }}