// This Template contains multiple template definitions.

{{ define "header" }}
// Code generated by internal/cmd/fitgen/main.go. DO NOT EDIT.

// Copyright 2023 The FIT SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

{{ end }}

// Template definition for [factory.go]
{{ define "factory" }}
{{ template "header" . }}
package {{ .Package }}

import (
	"errors"
	"fmt"
    "math"
	"sync"

	"github.com/muktihari/fit/proto"
	"github.com/muktihari/fit/profile"
	"github.com/muktihari/fit/profile/basetype"
	"github.com/muktihari/fit/profile/typedef"
)

const (
	// NameUnknown is unknown message or field name
	NameUnknown string = "unknown"
)

var (
	// ErrRegisterForbidden occurs when trying to create manufacturer specific message outside available range.
	ErrRegisterForbidden = errors.New("register is forbidden")
)

// Factory handles creation and registration for FIT's message and field.
type Factory struct {
	registeredMesgs map[typedef.MesgNum]proto.Message
}

// New creates new Factory with predefined messages.
// Use this if you work with multiple manufacturers that have different manufacturer specific messages, 
// Otherwise, use StandardFactory().
// 
// New is not receiving messages on purpose: to comply with FIT term and conditions which is not allowing edit on existing messages. 
// Receiving messages through here means we need to validate all of it, while RegisterMesg is already exist for that purpose.
func New() *Factory { return &Factory{} }

var ( // cache for CreateMesg method
	once	   sync.Once
	protoMesgs [len(mesgs)]proto.Message // data is populated on CreateMesg first invocation.
)

{{ template "create_mesg_doc" -}}
func (f *Factory) CreateMesg(num typedef.MesgNum) proto.Message {
	once.Do(func() { // populate data fields in the cache.
		for i := range mesgs {
			rawmesg := &mesgs[i]
			if rawmesg.Num != typedef.MesgNum(i) {
				continue // skip unknown message
			}
			var n byte
			for j := range rawmesg.Fields {
				field := rawmesg.Fields[j]
				if field.FieldBase != nil {
					n++
				}
			}
			fields := make([]proto.Field, 0, n)
			for j := range rawmesg.Fields {
				field := rawmesg.Fields[j]
				if field.FieldBase != nil {
					fields = append(fields, field)
				}
			}
			protoMesgs[rawmesg.Num] = proto.Message{
				Num:    rawmesg.Num, 
				Fields: fields,
			}
		}
	})

	mesg := protoMesgs[num]
	if mesg.Num != num {
		mesg = f.registeredMesgs[num]
	}

	mesg.Num = num // In case of unknown field

	if len(mesg.Fields) != 0 {
		fields := make([]proto.Field, len(mesg.Fields))
		copy(fields, mesg.Fields)
		mesg.Fields = fields
	}

	return mesg
}

{{ template "create_mesg_only_doc" -}}
func (f *Factory) CreateMesgOnly(num typedef.MesgNum) proto.Message {
	return proto.Message{Num: num}
}

{{ template "create_field_doc" -}}
func (f *Factory) CreateField(mesgNum typedef.MesgNum, num byte) proto.Field {
	if mesgNum < typedef.MesgNum(len(mesgs)) && mesgs[mesgNum].Num == mesgNum {
		field := mesgs[mesgNum].Fields[num]
		if field.FieldBase != nil {
			return field
		}
		return createUnknownField(num)
	}

	if mesg, ok := f.registeredMesgs[mesgNum]; ok {
		for i := range mesg.Fields {
			if mesg.Fields[i].Num == num {
				return mesg.Fields[i]
			}
		}
	}

	return createUnknownField(num)
}

func createUnknownField(num byte) proto.Field {
	return proto.Field{FieldBase: &proto.FieldBase{Name: NameUnknown, Num: num, Scale: 1, Offset: 0}}
}

{{ template "register_mesg_doc" -}}
func (f *Factory) RegisterMesg(mesg proto.Message) error {
	if f.registeredMesgs == nil {
		f.registeredMesgs = make(map[typedef.MesgNum]proto.Message) // only alloc when needed
	}

	if mesg.Num > typedef.MesgNumMfgRangeMax {
		return fmt.Errorf("could not register outside max range: %d: %w", 
			typedef.MesgNumMfgRangeMax, ErrRegisterForbidden)
	}

	if mesg.Num < typedef.MesgNum(len(mesgs)) && mesgs[mesg.Num].Num == mesg.Num {
		return fmt.Errorf("could not register on reserved predefined message, mesg.Num %d (%s) is already exist: %w",
			mesg.Num, mesg.Num, ErrRegisterForbidden)
	}

	f.registeredMesgs[mesg.Num] = mesg

	return nil
}

type message struct {
	Num    typedef.MesgNum
	Fields [256]proto.Field // Use array to ensure O(1) lookup, use pointer to reduce memory usage.
}

// Use array to ensure O(1) lookup
var mesgs = {{ .Messages }} 

{{ end }} // end of "factory"

// Template definition for [exported.go] 
{{ define "exported"}}
{{ template "header" . }}

package {{ .Package }}

 import (
	"github.com/muktihari/fit/proto"
	"github.com/muktihari/fit/profile/typedef"
)

 var std = New()

// StandardFactory returns standard factory.
func StandardFactory() *Factory { return std }

{{ template "create_mesg_doc" -}}
func CreateMesg(num typedef.MesgNum) proto.Message {
	return std.CreateMesg(num)
}

{{- template "create_mesg_only_doc" -}}
func CreateMesgOnly(num typedef.MesgNum) proto.Message{
	return std.CreateMesgOnly(num)
}

{{ template "create_field_doc" -}}
func CreateField(mesgNum typedef.MesgNum, num byte) proto.Field {
	return std.CreateField(mesgNum, num)
}

{{ template "register_mesg_doc" -}}
func RegisterMesg(mesg proto.Message) error {
	return std.RegisterMesg(mesg)
}

{{ end }} // end of "exported"

// Funcs & Methods Shared Documentations:
{{ define "create_mesg_doc" }}
// CreateMesg creates new message based on defined messages in the factory. If not found, it returns proto.Message{Num: num}.
//
// This will create a shallow copy of the Fields, so changing any value declared in Field's FieldBase is prohibited (except in case of unknown field).
// If you want a deep copy of the mesg, clone it by calling mesg.Clone().
//
// NOTE: This method is not used by either the decoder or the encoder, and the data will only be populated once upon the first invocation.
{{ end }}

{{ define "create_mesg_only_doc" }}
// CreateMesgOnly is a syntax sugar for creating proto.Message{Num: num}.
{{ end }}

{{ define "create_field_doc" }}
// CreateField creates new field based on defined messages in the factory. If not found, it returns new field with "unknown" name.
// 
// Field's FieldBase is a pointer struct embedded, and this will only create a shallow copy of the field, so changing any value declared in 
// FieldBase is prohibited (except fot the unknown field) since it still referencing the same struct. If you want a deep copy of the Field, 
// create it by calling field.Clone().
{{ end }}

{{ define "register_mesg_doc" }}
// RegisterMesg registers a new message that is not defined in the profile.xlsx. 
// You can not edit or replace existing predefined messages in the factory, you can only edit the messages you have registered.
// However, we don't create a lock for efficiency, since this is intended to be used on instantiation. If you want to
// change something without triggering data race, you can create a new instance of Factory using New().
//
// By registering, any FIT file containing these messages can be recognized instead of returning "unknown" message.
{{ end }}