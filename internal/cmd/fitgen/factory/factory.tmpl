// This Template contains multiple template definitions.

{{ define "header" }}
// Code generated by internal/cmd/fitgen/main.go. DO NOT EDIT.

// Copyright 2023 The FIT SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

{{ end }}

// Template definition for [factory.go]
{{ define "factory" }}
{{ template "header" . }}
package {{ .Package }}

import (
	"fmt"
	"math"
	"sync"

	"github.com/muktihari/fit/proto"
	"github.com/muktihari/fit/profile"
	"github.com/muktihari/fit/profile/basetype"
	"github.com/muktihari/fit/profile/typedef"
)

type errorString string

func (e errorString) Error() string { return string(e) }

const (
	// ErrRegisterForbidden occurs when trying to create manufacturer specific message outside available range.
	ErrRegisterForbidden = errorString("register is forbidden")

	// NameUnknown is the name of an unknown message or an unknown field.
	NameUnknown string = "unknown"
)


// Factory handles creation and registration for FIT's message and field.
type Factory struct {
	registeredMesgs map[typedef.MesgNum]proto.Message
}

// New creates new Factory with predefined messages.
// Use this if you work with multiple manufacturers that have different manufacturer specific messages, 
// Otherwise, use StandardFactory().
// 
// New is not receiving messages on purpose: to comply with FIT term and conditions which is not allowing edit on existing messages. 
// Receiving messages through here means we need to validate all of it, while RegisterMesg is already exist for that purpose.
func New() *Factory { return &Factory{} }

var ( // cache for CreateMesg method
	once	   sync.Once
	protoMesgs []proto.Message // data is populated on CreateMesg first invocation.
)

{{ template "create_mesg_doc" -}}
func (f *Factory) CreateMesg(num typedef.MesgNum) proto.Message {
	once.Do(func() { // populate data for the firt invocation.
		protoMesgs = make([]proto.Message, len(mesgs))
		for i := range mesgs {
			m := &mesgs[i]
			if m.Num != typedef.MesgNum(i) {
				continue // skip unknown message
			}
			var n byte
			for j := range m.Fields {
				if m.Fields[j].FieldBase != nil {
					n++
				}
			}
			fields := make([]proto.Field, 0, n)
            
			// Place timestamp field at the first index since the field is frequently used.
			// This kind of ordering matches the fields' ordering in Profile.xlsx which put timestamp at the beginning.
			field := m.Fields[proto.FieldNumTimestamp]
			if field.FieldBase != nil {
				fields = append(fields, field)
			}
			for _, field = range m.Fields {
				if field.FieldBase != nil && field.Num != proto.FieldNumTimestamp {
					fields = append(fields, field)
				}
			}
			protoMesgs[m.Num] = proto.Message{
				Num:    m.Num, 
				Fields: fields,
			}
		}
	})

	var mesg proto.Message
	if num < typedef.MesgNum(len(protoMesgs)) {
		mesg = protoMesgs[num]
	}
	if mesg.Num != num {
		mesg = f.registeredMesgs[num]
	}
	mesg.Num = num // In case of unknown field

	if len(mesg.Fields) != 0 {
		fields := make([]proto.Field, len(mesg.Fields))
		copy(fields, mesg.Fields)
		mesg.Fields = fields
	}

	return mesg
}

{{ template "create_mesg_only_doc" -}}
func (f *Factory) CreateMesgOnly(num typedef.MesgNum) proto.Message {
	return proto.Message{Num: num}
}

{{ template "create_field_doc" -}}
func (f *Factory) CreateField(mesgNum typedef.MesgNum, num byte) proto.Field {
	if mesgNum < typedef.MesgNum(len(mesgs)) && mesgs[mesgNum].Num == mesgNum {
		field := mesgs[mesgNum].Fields[num]
		if field.FieldBase != nil {
			return field
		}
		return createUnknownField(num)
	}

	if mesg, ok := f.registeredMesgs[mesgNum]; ok {
		for i := range mesg.Fields {
			if mesg.Fields[i].Num == num {
				return mesg.Fields[i]
			}
		}
	}

	return createUnknownField(num)
}

func createUnknownField(num byte) proto.Field {
	return proto.Field{FieldBase: &proto.FieldBase{Name: NameUnknown, Num: num, Scale: 1, Offset: 0}}
}

{{ template "register_mesg_doc" -}}
func (f *Factory) RegisterMesg(mesg proto.Message) error {
	if f.registeredMesgs == nil {
		f.registeredMesgs = make(map[typedef.MesgNum]proto.Message) // only alloc when needed
	}

	if mesg.Num > typedef.MesgNumMfgRangeMax {
		return fmt.Errorf("could not register outside max range: %d: %w", 
			typedef.MesgNumMfgRangeMax, ErrRegisterForbidden)
	}

	if mesg.Num < typedef.MesgNum(len(mesgs)) && mesgs[mesg.Num].Num == mesg.Num {
		return fmt.Errorf("could not register on reserved predefined message, mesg.Num %d (%s) is already exist: %w",
			mesg.Num, mesg.Num, ErrRegisterForbidden)
	}

	f.registeredMesgs[mesg.Num] = mesg

	return nil
}

type message struct {
	Num    typedef.MesgNum
	Fields [256]proto.Field // Use array to ensure O(1) lookup
}

// Use array to ensure O(1) lookup
var mesgs = {{ .Messages }} 

{{ end }} // end of "factory"

// Template definition for [exported.go] 
{{ define "exported"}}
{{ template "header" . }}

package {{ .Package }}

 import (
	"github.com/muktihari/fit/proto"
	"github.com/muktihari/fit/profile/typedef"
)

 var std = New()

// StandardFactory returns standard factory.
func StandardFactory() *Factory { return std }

{{ template "create_mesg_doc" -}}
func CreateMesg(num typedef.MesgNum) proto.Message {
	return std.CreateMesg(num)
}

{{- template "create_mesg_only_doc" -}}
func CreateMesgOnly(num typedef.MesgNum) proto.Message{
	return std.CreateMesgOnly(num)
}

{{ template "create_field_doc" -}}
func CreateField(mesgNum typedef.MesgNum, num byte) proto.Field {
	return std.CreateField(mesgNum, num)
}

{{ template "register_mesg_doc" -}}
func RegisterMesg(mesg proto.Message) error {
	return std.RegisterMesg(mesg)
}

{{ end }} // end of "exported"

// Funcs & Methods Shared Documentations:
{{ define "create_mesg_doc" }}
// CreateMesg creates new message based on defined messages in the factory. If not found, it returns proto.Message{Num: num}.
//
// This will create a shallow copy of the Fields, so changing any value declared in Field's FieldBase is prohibited (except in case of unknown field).
// If you want a deep copy of the mesg, clone it by calling mesg.Clone().
//
// NOTE: This method is not used by either the Decoder or the Encoder, and the data will only be populated once upon the first invocation.
// Unless you need most of the returned fields, it's recommended create an empty proto.Message{Num: num} then fill only the necessary fields 
// using CreateField method.
{{ end }}

{{ define "create_mesg_only_doc" }}
// CreateMesgOnly is a syntax sugar for creating proto.Message{Num: num}.
{{ end }}

{{ define "create_field_doc" }}
// CreateField creates new field based on defined messages in the factory. If not found, it returns new field with "unknown" name.
// 
// Field's FieldBase is a pointer struct embedded, and this will only create a shallow copy of the field, so changing any value declared in 
// FieldBase is prohibited (except fot the unknown field) since it still referencing the same struct. If you want a deep copy of the Field, 
// create it by calling field.Clone().
{{ end }}

{{ define "register_mesg_doc" }}
// RegisterMesg registers a new message that is not defined in the profile.xlsx. 
// You can not edit or replace existing predefined messages in the factory, you can only edit the messages you have registered.
// However, we don't create a lock for efficiency, since this is intended to be used on instantiation. If you want to
// change something without triggering data race, you can create a new instance of Factory using New().
//
// By registering, any FIT file containing these messages can be recognized instead of returning "unknown" message.
{{ end }}