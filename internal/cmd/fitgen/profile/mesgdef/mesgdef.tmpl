{{ define "mesgdef" }}
// Code generated by internal/cmd/fitgen/main.go. DO NOT EDIT.
// SDK Version: {{ .SDKVersion }}

// Copyright 2023 The Fit SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package {{ .Package }}

import (
	"github.com/muktihari/fit/kit/typeconv"
	"github.com/muktihari/fit/profile/typedef"
	"github.com/muktihari/fit/proto"
	{{- if .Imports -}}
        {{ range $_, $v := .Imports }}
            {{ printf "%q" $v -}}
        {{ end }}
    {{ end }}
)

// {{ .Name }} is a {{ .Name }} message.
type {{ .Name }} struct {
	{{ range .Fields -}}
	{{ .Name }} {{ .Type }} {{ if .Comment }} // {{ .Comment }} {{ end }}
	{{ end }}

	{{- if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription")) }}
	// Developer Fields are dynamic, can't be mapped as struct's fields. 
	// [Added since protocol version 2.0]
	DeveloperFields []proto.DeveloperField
	{{- end -}}
}

// New{{ .Name }} creates new {{ .Name }} struct based on given mesg. 
// If mesg is nil, it will return {{ .Name }} with all fields being set to its corresponding invalid value.
func New{{ .Name }}(mesg *proto.Message) *{{ .Name }} {
    vals := [{{ .MaxFieldNum }}]any{}

    {{ if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription"))  -}}
        var developerFields []proto.DeveloperField
    {{ end -}}
    if mesg != nil {
        for i := range mesg.Fields {
            if mesg.Fields[i].Num >= byte(len(vals)) {
                continue
            }
            vals[mesg.Fields[i].Num] = mesg.Fields[i].Value
        }
        {{- if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription"))  }}
            developerFields = mesg.DeveloperFields
        {{ end -}}
    }


	return &{{ .Name }}{
		{{ range .Fields -}}
			{{ .Name }}: {{ .TypedValue }},
		{{ end -}}

		{{- if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription"))  }}
		DeveloperFields: developerFields,
		{{ end -}}
	}
}

// ToMesg converts {{ .Name }} into proto.Message.
func (m *{{ .Name }}) ToMesg(fac Factory) proto.Message {
    mesg := fac.CreateMesgOnly(typedef.MesgNum{{ .Name }})
	mesg.Fields = make([]proto.Field, 0, m.size())

    {{ range .Fields -}}
        if {{ .ComparableValue }} != {{ .InvalidValue }} {
            field := fac.CreateField(mesg.Num, {{ .Num }})
            field.Value = {{ .PrimitiveValue }}
            mesg.Fields = append(mesg.Fields, field)
        }
	{{ end }}

	{{ if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription"))  }}
	mesg.DeveloperFields = m.DeveloperFields
	{{ end }}

	return mesg
}

// size returns size of {{ .Name }}'s valid fields.
func (m *{{ .Name }}) size() byte {
    var size byte
    {{ range .Fields -}}
        if {{ .ComparableValue }} != {{ .InvalidValue }} {
            size++
        }
	{{ end -}}
    return size
}

{{ range .Fields -}}
// Set{{ .Name }} sets {{ $.Name }} value.
//
// {{ .Comment }}
func (m *{{ $.Name }}) Set{{ .Name }}(v {{ .Type }}) *{{ $.Name }} {
    m.{{ .Name }} = v
    return m
}
{{ end }}


{{- if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription")) }}
// SetDeveloperFields {{ $.Name }}'s DeveloperFields.
func (m *{{ $.Name }}) SetDeveloperFields(developerFields ...proto.DeveloperField) *{{ $.Name }} {
    m.DeveloperFields = developerFields
    return m
}
{{ end }}

{{ end }}