{{ define "mesgdef" }}
// Code generated by internal/cmd/fitgen/main.go. DO NOT EDIT.
// SDK Version: {{ .SDKVersion }}

// Copyright 2023 The Fit SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package {{ .Package }}

import (
	"github.com/muktihari/fit/proto"
	"github.com/muktihari/fit/kit/typeconv"
	"github.com/muktihari/fit/profile/typedef"
	{{- if .Imports -}}
        {{ range $_, $v := .Imports }}
            {{ printf "%q" $v -}}
        {{ end }}
    {{ end }}
)

// {{ .Name }} is a {{ .Name }} message.
type {{ .Name }} struct {
	{{ range .Fields -}}
	{{ .Name }} {{ .Type }} {{ if .Comment }} // {{ .Comment }} {{ end }}
	{{ end }}

	{{- if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription")) }}
	// Developer Fields are dynamic, can't be mapped as struct's fields. 
	// [Added since protocol version 2.0]
	DeveloperFields []proto.DeveloperField
	{{- end -}}
}

// New{{ .Name }} creates new {{ .Name }} struct based on given mesg. If mesg is nil or mesg.Num is not equal to {{ .Name }} mesg number, it will return nil.
func New{{ .Name }}(mesg proto.Message) *{{ .Name }} {
	if mesg.Num != typedef.MesgNum{{ .Name }} {
		return nil
	}

	vals := [...]any{ // nil value will be converted to its corresponding invalid value by typeconv.
		{{ range .Fields -}}
			{{ .Num }}: nil, /* {{ .Name }} */
		{{ end -}}
	}

	for i := range mesg.Fields {
		field := &mesg.Fields[i]
		if field.Num >= byte(len(vals)) {
			continue
		}
		vals[field.Num] = field.Value
	}

	return &{{ .Name }}{
		{{ range .Fields -}}
			{{ .Name }}: {{ .AssignedValue }},
		{{ end -}}

		{{- if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription"))  }}
		DeveloperFields: mesg.DeveloperFields,
		{{ end }}
	}
}

// PutMessage puts fields's value into mesg. If mesg is nil or mesg.Num is not equal to {{ .Name }} mesg number, it will return nil.
// It is the caller responsibility to provide the appropriate mesg, it's recommended to create mesg using factory: 
//  
//  factory.CreateMesg(typedef.MesgNum{{ .Name }})
func (m {{ .Name }}) PutMessage(mesg *proto.Message) {
	if mesg == nil {
		return
	}

	if mesg.Num != typedef.MesgNum{{ .Name }} {
		return
	}

	vals := [...]any{
		{{ range .Fields -}}
			{{ .Num }}: m.{{ .Name }},
		{{ end -}}
	}

	for i := range mesg.Fields {
		field := &mesg.Fields[i]
		if field.Num >= byte(len(vals)) {
			continue
		}
		field.Value = vals[field.Num]
	}

	{{ if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription"))  }}
	mesg.DeveloperFields = m.DeveloperFields
	{{ end -}}
}
{{ end }}