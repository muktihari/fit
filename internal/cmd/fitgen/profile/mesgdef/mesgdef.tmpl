{{ define "mesgdef" }}
// Code generated by internal/cmd/fitgen/main.go. DO NOT EDIT.

// Copyright 2023 The FIT SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package {{ .Package }}

import (
	"github.com/muktihari/fit/factory"
	"github.com/muktihari/fit/internal/sliceutil"
	"github.com/muktihari/fit/profile/typedef"
	"github.com/muktihari/fit/proto"
	{{- if .Imports -}}
		{{ range $_, $v := .Imports }}
			{{ printf "%q" $v -}}
		{{ end }}
	{{ end }}
)

// {{ .Name }} is a {{ .Name }} message.
// 
// Note: The order of the fields is optimized using a memory alignment algorithm.
// Do not rely on field indices, such as when using reflection.
type {{ .Name }} struct {
	{{ range .OptimizedFields -}}
	{{ .Name }} {{ .Type }} {{ if .Comment }} // {{ .Comment }} {{ end }}
	{{ end }}

	{{ if gt .MaxFieldExpandNum 1 -}}
	state [{{ byteDiv .MaxFieldExpandNum 8 | byteAdd 1 }}]uint8 // Used for tracking expanded fields.
	{{ end }}

	UnknownFields []proto.Field            // UnknownFields are fields that are exist but they are not defined in Profile.xlsx
	{{- if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription")) }}
	DeveloperFields []proto.DeveloperField // DeveloperFields are custom data fields [Added since protocol version 2.0]
	{{- end }}
}

// New{{ .Name }} creates new {{ .Name }} struct based on given mesg. 
// If mesg is nil, it will return {{ .Name }} with all fields being set to its corresponding invalid value.
func New{{ .Name }}(mesg *proto.Message) *{{ .Name }} {
	m := new({{ .Name }})
	m.Reset(mesg)
	return m
}

// Reset resets all {{ .Name }}'s fields based on given mesg.
// If mesg is nil, all fields will be set to its corresponding invalid value.
func (m *{{ $.Name }}) Reset(mesg *proto.Message) {
	var (
		vals [{{ .MaxFieldNum }}]proto.Value
		{{ if gt .MaxFieldExpandNum 1 -}}
		state [{{ byteDiv .MaxFieldExpandNum 8 | byteAdd 1 }}]uint8
		{{ end -}}
		unknownFields []proto.Field
		{{ if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription"))  -}}
			developerFields []proto.DeveloperField
		{{ end -}}
	)

	if mesg != nil {
		arr := pool.Get().(*[poolsize]proto.Field)
		unknownFields = arr[:0]
		for i := range mesg.Fields {
			if mesg.Fields[i].Num > {{ byteSub .MaxFieldNum 1 }} || mesg.Fields[i].Name == factory.NameUnknown {
				unknownFields = append(unknownFields, mesg.Fields[i])
				continue
			}
			{{ if gt $.MaxFieldExpandNum 1 -}}
			if mesg.Fields[i].Num < {{ .MaxFieldExpandNum }} && mesg.Fields[i].IsExpandedField {
				pos := mesg.Fields[i].Num/8
				state[pos] |= 1 << (mesg.Fields[i].Num - (8 * pos))
			}
			{{ end -}}
			vals[mesg.Fields[i].Num] = mesg.Fields[i].Value
		}
		unknownFields = sliceutil.Clone(unknownFields)
		*arr = [poolsize]proto.Field{} {{/* In case of unknown field or field.Value contains pointer to a slice */}}
		pool.Put(arr)
		{{- if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription"))  }}
			developerFields = mesg.DeveloperFields
		{{ end -}}
	}


	*m = {{ .Name }}{
		{{ range .Fields -}}
			{{ .Name }}: {{ .TypedValue }},
		{{ end }}
		{{ if gt .MaxFieldExpandNum 1 -}}
		state: state,
		{{ end }}
		UnknownFields: unknownFields,
		{{- if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription"))  }}
		DeveloperFields: developerFields,
		{{ end }}
	}
} 

// ToMesg converts {{ .Name }} into proto.Message. If options is nil, default options will be used.
func (m *{{ .Name }}) ToMesg(options *Options) proto.Message {
	if options == nil {
		options = defaultOptions
	} else if options.Factory == nil {
		options.Factory = factory.StandardFactory()
	}

	fac := options.Factory

	arr := pool.Get().(*[poolsize]proto.Field)
	fields := arr[:0]

	mesg := proto.Message{ Num: typedef.MesgNum{{ .Name }} }

	{{ range .Fields -}}
	if {{ .IsValidValue -}} {
		{{- if eq .CanExpand true -}} if expanded := m.IsExpandedField({{ .Num }}); !expanded || (expanded && options.IncludeExpandedFields) { {{ end }}
		field := fac.CreateField(mesg.Num, {{ .Num }})
		{{ if gt .FixedArraySize 0 -}}
		{{- /* DO NOT reslice directly from the struct (e.g. m.Velocity[:]), otherwise, we will keep referencing
			the struct since we promote the array from the same memory block as the struct. We must copy the array
			to local variable, so it will be promoted instead (we only need the local variable to escape to the heap),
			only then the struct can be garbage-collected on next GC's cycle. */ -}}
		copied := m.{{ .Name }}
		field.Value = {{ stringReplace .ProtoValue (printf "m.%s" .Name) "copied[:]" -1 }}
		{{ else -}}
		field.Value = {{ .ProtoValue }}
		{{ end -}}
		{{ if eq .CanExpand true -}}
			field.IsExpandedField = expanded
		{{ end -}}
		fields = append(fields, field)
		{{ if eq .CanExpand true -}} } {{ end -}}
	}
	{{ end }}

	for i := range m.UnknownFields {
		fields = append(fields, m.UnknownFields[i])
	}

	mesg.Fields = make([]proto.Field, len(fields))
	copy(mesg.Fields, fields)
	*arr = [poolsize]proto.Field{} {{/* In case of unknown field or field.Value contains pointer to a slice */}}
	pool.Put(arr)

	{{ if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription"))  }}
	mesg.DeveloperFields = m.DeveloperFields
	{{ end }}

	return mesg
}

{{ range .DynamicFields -}}
// Get{{ .Name }} returns Dynamic Field interpretation of {{ .Name }}. Otherwise, returns the original value of {{ .Name }}.
// 
{{ range .SwitchCases -}} 
// Based on {{ .Name }}:
	{{ range .CondValues -}}
//   - name: "{{ .ReturnValue.Name }}" {{- if .ReturnValue.Units -}}, units: "{{ .ReturnValue.Units }}" {{ end }}, value: {{ .ReturnValue.Value }}
	{{ end -}}
{{ end -}}
// Otherwise:
//   - name: "{{ .Default.Name }}" {{- if .Default.Units -}}, units: "{{ .Default.Units }}" {{ end }}, value: {{ .Default.Value }}
func (m *{{ $.Name }}) Get{{ .Name }}() (name string, value any) {
{{ range .SwitchCases -}}
	switch {{ .Name -}} {
	{{- range .CondValues }}
	case {{ stringsJoin .Conds "," }}:
		return "{{ .ReturnValue.Name }}", {{ .ReturnValue.Value -}}
	{{ end}}
	}
{{ end -}}
	return "{{ .Default.Name }}", {{ .Default.Value }}
}
{{ end }}

{{ range .Fields -}}
{{ if eq .Type "time.Time" }}
// {{ .Name }}Uint32 returns {{ .Name }} in uint32 (seconds since FIT's epoch) instead of time.Time.
func (m *{{ $.Name }}) {{ .Name }}Uint32() uint32 { return datetime.ToUint32(m.{{ .Name }}) }
{{ end }}
{{ end }}

{{ range .Fields -}}
{{ if not (and (eq .Scale 1.0) (eq .Offset 0.0)) }}
// {{ .Name }}Scaled return {{ .Name }} in its scaled value.
// If {{ .Name }} value is invalid,{{ if .Array }} nil {{ else }} float64 invalid value {{ end -}} will be returned.
// 
// {{ .Comment }}
func (m *{{ $.Name }}) {{ .Name }}Scaled() {{ if gt .FixedArraySize 0 }} [{{ .FixedArraySize }}]float64 {{ else if .Array }} []float64 {{ else }} float64 {{ end -}} {
	if {{ .ComparableValue }} == {{ .InvalidValue }} {
		return {{ if gt .FixedArraySize 0 }} {{ .InvalidArrayValueScaled }} {{ else if .Array }} nil {{ else }} math.Float64frombits(basetype.Float64Invalid) {{ end -}}
	}
	{{- if gt .FixedArraySize 0 }}
		var vals [{{ .FixedArraySize }}]float64
		for i := range m.{{ .Name }} {
			if m.{{ .Name }}[i] == {{ .BaseTypeInvalid }} {
				vals[i] = math.Float64frombits(basetype.Float64Invalid)
				continue
			}
			vals[i] = float64(m.{{ .Name }}[i]) / {{ .Scale }} -{{ .Offset }}
		}
		return vals
	{{- else if .Array }}
		var vals = make([]float64, len(m.{{ .Name }}))
		for i := range m.{{ .Name }} {
			if m.{{ .Name }}[i] == {{ .BaseTypeInvalid }} {
				vals[i] = math.Float64frombits(basetype.Float64Invalid)
				continue
			}
			vals[i] = float64(m.{{ .Name }}[i]) / {{ .Scale }} - {{ .Offset }}
		}
		return vals
	{{- else }}
		return float64(m.{{ .Name }}) / {{ .Scale }} - {{ .Offset }}
	{{ end -}}
}
{{ end }}
{{ end }}


{{ range .Fields -}}
{{ if eq .Units "semicircles" }}
// {{ .Name }}Degrees returns {{ .Name }} in degrees instead of semicircles.
// If {{ .Name }} value is invalid, float64 invalid value will be returned.
func (m *{{ $.Name }}) {{ .Name }}Degrees() float64 { 
	return semicircles.ToDegrees(m.{{ .Name }})
}
{{ end }}
{{ end }}

{{ range .Fields -}}
// Set{{ .Name }} sets {{ .Name }} value.
//
// {{ .Comment }}
func (m *{{ $.Name }}) Set{{ .Name }}(v {{ .Type }}) *{{ $.Name }} {
	m.{{ .Name }} = v
	return m
}

{{ if not (and (eq .Scale 1.0) (eq .Offset 0.0)) -}}
// Set{{ .Name }}Scaled is similar to Set{{ .Name }} except it accepts a scaled value.
// This method automatically converts the given value to its {{ .Type }} form, discarding any applied scale and offset.
// 
// {{ .Comment }}
func (m *{{ $.Name }}) Set{{ .Name }}Scaled({{ if gt .FixedArraySize 0 }} vs [{{ .FixedArraySize }}]float64 {{ else if .Array }} vs []float64 {{ else }} v float64 {{ end }}) *{{ $.Name }} {
	{{ if gt .FixedArraySize 0 -}}
	m.{{ .Name }} = {{ .InvalidValue }}
	for i := range vs {
		unscaled := (vs[i] + {{ .Offset }}) * {{ .Scale }}
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64({{ .BaseTypeInvalid }}) {
			continue
		}
		m.{{ .Name }}[i] = {{ extractExactlyType .Type }}(unscaled)
	}
	{{ else if .Array -}}
	if vs == {{ .InvalidValue }} {
		m.{{ .Name }} = {{ .InvalidValue }}
		return m
	}
	m.{{ .Name }} = make({{ .Type }}, len(vs))
	for i := range vs {
		unscaled := (vs[i] + {{ .Offset }}) * {{ .Scale }}
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64({{ .BaseTypeInvalid }}) {
			m.{{ .Name }}[i] = {{ extractExactlyType .Type }}({{ .BaseTypeInvalid }})
			continue
		}
		m.{{ .Name }}[i] = {{ extractExactlyType .Type }}(unscaled)
	}
	{{ else -}}
	unscaled := (v + {{ .Offset }}) * {{ .Scale }}
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64({{ .BaseTypeInvalid }}) {
		m.{{ .Name }} = {{ .Type }}({{ .BaseTypeInvalid }})
		return m
	}
	m.{{ .Name }} = {{ .Type }}(unscaled)
	{{ end -}}

	return m
}
{{ end -}}

{{ if eq .Units "semicircles" -}}
// Set{{ .Name }}Degrees is similar to Set{{ .Name }} except it accepts a value in degrees.
// This method will automatically convert given degrees value to semicircles ({{ .Type }}) form.
func (m *{{ $.Name }}) Set{{ .Name }}Degrees(degrees float64) *{{ $.Name }} {
	m.{{ .Name }} = semicircles.ToSemicircles(degrees)
	return m
}
{{ end -}}

{{ end }}

// SetUnknownFields sets UnknownFields (fields that are exist but they are not defined in Profile.xlsx)
func (m *{{ $.Name }}) SetUnknownFields(unknownFields ...proto.Field) *{{ $.Name }} {
	m.UnknownFields = unknownFields
	return m
}

{{- if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription")) }}
// SetDeveloperFields sets DeveloperFields.
func (m *{{ $.Name }}) SetDeveloperFields(developerFields ...proto.DeveloperField) *{{ $.Name }} {
	m.DeveloperFields = developerFields
	return m
}
{{ end }}

{{ if gt .MaxFieldExpandNum 1 -}}
// MarkAsExpandedField marks whether given fieldNum is an expanded field (field that being
// generated through a component expansion). Eligible for field number: {{- template "eligible_for_expanded_fields" . }}.
func (m *{{ $.Name }}) MarkAsExpandedField(fieldNum byte, flag bool) (ok bool) {
	switch fieldNum {
	case {{ template "eligible_for_expanded_fields" . }}:
	default:
		return false
	}
	pos := fieldNum/8
	bit := uint8(1) << (fieldNum - (8 * pos))
	m.state[pos] &^= bit
	if flag {
		m.state[pos] |= bit
	}
	return true
}

// IsExpandedField checks whether given fieldNum is a field generated through
// a component expansion. Eligible for field number: {{- template "eligible_for_expanded_fields" . }}.
func (m *{{ $.Name }}) IsExpandedField(fieldNum byte) bool {
	{{/* Simple check is enough since we validate on marking */ -}}
	if fieldNum >= {{ .MaxFieldExpandNum }} {
		return false
	}
	pos := fieldNum/8
	bit := uint8(1) << (fieldNum - (8 * pos))
	return m.state[pos] & bit == bit
}
{{ end }}

{{ end }}

{{ define "eligible_for_expanded_fields" }}
{{- $first := true -}}
{{ range $i, $v := .Fields -}}
	{{- if .CanExpand -}}
		{{- if $first -}} {{ $first = false }} {{ .Num }}
		{{- else -}}, {{ .Num }} {{- end }}
	{{- end -}}
{{- end -}}
{{ end }}

{{ define "util" }}
// Code generated by internal/cmd/fitgen/main.go. DO NOT EDIT.

// Copyright 2024 The FIT SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package {{ .Package }}

import (
	"github.com/muktihari/fit/proto"
	"sync"
)

const poolsize = {{ .MaxLenFields }} // Max fields' length from the entire messages.

var pool = sync.Pool{New: func() any { return new([poolsize]proto.Field) }}

{{ end }}