{{ define "mesgdef" }}
// Code generated by internal/cmd/fitgen/main.go. DO NOT EDIT.
// SDK Version: {{ .SDKVersion }}

// Copyright 2023 The Fit SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package {{ .Package }}

import (
	"github.com/muktihari/fit/kit/typeconv"
	"github.com/muktihari/fit/profile/typedef"
	"github.com/muktihari/fit/proto"
	{{- if .Imports -}}
        {{ range $_, $v := .Imports }}
            {{ printf "%q" $v -}}
        {{ end }}
    {{ end }}
)

// {{ .Name }} is a {{ .Name }} message.
type {{ .Name }} struct {
	{{ range .Fields -}}
	{{ .Name }} {{ .Type }} {{ if .Comment }} // {{ .Comment }} {{ end }}
	{{ end }}

	{{- if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription")) }}
	// Developer Fields are dynamic, can't be mapped as struct's fields. 
	// [Added since protocol version 2.0]
	DeveloperFields []proto.DeveloperField
	{{ end -}}

	{{ if gt .MaxFieldExpandNum 1 }}

	IsExpandedFields [{{ .MaxFieldExpandNum }}]bool // Used for tracking expanded fields, field.Num as index.
	{{ end -}}
}

// New{{ .Name }} creates new {{ .Name }} struct based on given mesg. 
// If mesg is nil, it will return {{ .Name }} with all fields being set to its corresponding invalid value.
func New{{ .Name }}(mesg *proto.Message) *{{ .Name }} {
    vals := [{{ .MaxFieldNum }}]any{}
	{{ if gt .MaxFieldExpandNum 1 -}}
	isExpandedFields := [{{ .MaxFieldExpandNum }}]bool{}
	{{ end }}

    {{ if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription"))  -}}
        var developerFields []proto.DeveloperField
    {{ end -}}
    if mesg != nil {
        for i := range mesg.Fields {
            if mesg.Fields[i].Num >= byte(len(vals)) {
                continue
            }
			{{ if gt $.MaxFieldExpandNum 1 -}}
			if mesg.Fields[i].Num < byte(len(isExpandedFields)) {
				isExpandedFields[mesg.Fields[i].Num] = mesg.Fields[i].IsExpandedField
			}
			{{ end -}}
            vals[mesg.Fields[i].Num] = mesg.Fields[i].Value
        }
        {{- if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription"))  }}
            developerFields = mesg.DeveloperFields
        {{ end -}}
    }


	return &{{ .Name }}{
		{{ range .Fields -}}
			{{ .Name }}: {{ .TypedValue }},
		{{ end -}}

		{{- if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription"))  }}
		DeveloperFields: developerFields,
		{{ end }}
		{{ if gt .MaxFieldExpandNum 1 -}}
		IsExpandedFields: isExpandedFields,
		{{ end -}}
	}
}

// ToMesg converts {{ .Name }} into proto.Message.
func (m *{{ .Name }}) ToMesg(fac Factory) proto.Message {
    fieldsArray := fieldsPool.Get().(*[256]proto.Field)
    defer fieldsPool.Put(fieldsArray)
    
    fields := (*fieldsArray)[:0] // Create slice from array with zero len.
    mesg := fac.CreateMesgOnly(typedef.MesgNum{{ .Name }})
	
    {{ range .Fields -}}
        if {{ .ComparableValue }} != {{ .InvalidValue }} {
			field := fac.CreateField(mesg.Num, {{ .Num }})
			field.Value = {{ .PrimitiveValue }}
			{{ if eq .CanExpand true -}}
				field.IsExpandedField = m.IsExpandedFields[{{ .Num }}]
			{{ end -}}
			fields = append(fields, field)
        }
	{{ end }}

    mesg.Fields = make([]proto.Field, len(fields))
    copy(mesg.Fields, fields)

	{{ if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription"))  }}
	mesg.DeveloperFields = m.DeveloperFields
	{{ end }}

	return mesg
}

{{ range .Fields -}}
{{ if not (and (eq .Scale 1.0) (eq .Offset 0.0)) }}
// {{ .Name }}Scaled return {{ .Name }} in its scaled value [{{ .Comment }}].
// 
// If {{ .Name }} value is invalid,{{ if eq .Array true }} nil {{ else }} float64 invalid value {{ end -}} will be returned.
func (m *{{ $.Name }}) {{ .Name }}Scaled() {{ if eq .Array true }} []float64 {{ else }} float64 {{ end -}} {
	if {{ .ComparableValue }} == {{ .InvalidValue }} {
		return {{ if eq .Array true }} nil {{ else }} basetype.Float64InvalidInFloatForm() {{ end -}}
	}
	{{ if eq .Array true }} return scaleoffset.ApplySlice(m.{{ .Name }}, {{ .Scale }}, {{ .Offset }})
	{{ else }} return scaleoffset.Apply(m.{{ .Name }}, {{ .Scale }}, {{ .Offset }})
	{{ end }}
}
{{ end }}
{{ end }}

{{ range .Fields -}}
// Set{{ .Name }} sets {{ $.Name }} value.
//
// {{ .Comment }}
func (m *{{ $.Name }}) Set{{ .Name }}(v {{ .Type }}) *{{ $.Name }} {
    m.{{ .Name }} = v
    return m
}
{{ end }}


{{- if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription")) }}
// SetDeveloperFields {{ $.Name }}'s DeveloperFields.
func (m *{{ $.Name }}) SetDeveloperFields(developerFields ...proto.DeveloperField) *{{ $.Name }} {
    m.DeveloperFields = developerFields
    return m
}
{{ end }}

{{ end }}