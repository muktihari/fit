{{ define "mesgdef" }}
// Code generated by internal/cmd/fitgen/main.go. DO NOT EDIT.

// Copyright 2023 The FIT SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package {{ .Package }}

import (
    "github.com/muktihari/fit/factory"
	"github.com/muktihari/fit/profile/typedef"
	"github.com/muktihari/fit/proto"
	{{- if .Imports -}}
        {{ range $_, $v := .Imports }}
            {{ printf "%q" $v -}}
        {{ end }}
    {{ end }}
)

// {{ .Name }} is a {{ .Name }} message.
// 
// Note: The order of the fields is optimized using a memory alignment algorithm.
// Do not rely on field indices, such as when using reflection.
type {{ .Name }} struct {
	{{ range .OptimizedFields -}}
	{{ .Name }} {{ .Type }} {{ if .Comment }} // {{ .Comment }} {{ end }}
	{{ end }}

	{{ if gt .MaxFieldExpandNum 1 -}}
	state [{{ byteDiv .MaxFieldExpandNum 8 | byteAdd 1 }}]uint8 // Used for tracking expanded fields.
	{{ end }}

	{{- if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription")) }}
	// Developer Fields are dynamic, can't be mapped as struct's fields. 
	// [Added since protocol version 2.0]
	DeveloperFields []proto.DeveloperField
	{{ end -}}
}

// New{{ .Name }} creates new {{ .Name }} struct based on given mesg. 
// If mesg is nil, it will return {{ .Name }} with all fields being set to its corresponding invalid value.
func New{{ .Name }}(mesg *proto.Message) *{{ .Name }} {
    vals := [{{ .MaxFieldNum }}]proto.Value{}

	{{ if gt .MaxFieldExpandNum 1 -}}
	var state [{{ byteDiv .MaxFieldExpandNum 8 | byteAdd 1 }}]uint8
	{{ end -}}

    {{ if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription"))  -}}
        var developerFields []proto.DeveloperField
    {{ end -}}
    if mesg != nil {
        for i := range mesg.Fields {
            if mesg.Fields[i].Num > {{ byteSub .MaxFieldNum 1 }} {
                continue
            }
			{{ if gt $.MaxFieldExpandNum 1 -}}
			if mesg.Fields[i].Num < {{ .MaxFieldExpandNum }} && mesg.Fields[i].IsExpandedField {
				pos := mesg.Fields[i].Num/8
				state[pos] |= 1 << (mesg.Fields[i].Num - (8 * pos))
			}
			{{ end -}}
            vals[mesg.Fields[i].Num] = mesg.Fields[i].Value
        }
        {{- if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription"))  }}
            developerFields = mesg.DeveloperFields
        {{ end -}}
    }


	return &{{ .Name }}{
		{{ range .Fields -}}
			{{ .Name }}: {{ .TypedValue }},
		{{ end }}
		{{ if gt .MaxFieldExpandNum 1 -}}
		state: state,
		{{ end }}
		{{- if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription"))  }}
		DeveloperFields: developerFields,
		{{ end }}
	}
}

// ToMesg converts {{ .Name }} into proto.Message. If options is nil, default options will be used.
func (m *{{ .Name }}) ToMesg(options *Options) proto.Message {
	if options == nil {
		options = defaultOptions
	} else if options.Factory == nil {
        options.Factory = factory.StandardFactory()
    }

    fac := options.Factory

    arr := pool.Get().(*[poolsize]proto.Field)
    fields := arr[:0]
    
    mesg := proto.Message{ Num: typedef.MesgNum{{ .Name }} }
	
    {{ range .Fields -}}
        {{ if and (eq .Type "bool") (eq .FixedArraySize 0) -}} 
		{
			field := fac.CreateField(mesg.Num, {{ .Num }})
			field.Value = {{ .ProtoValue }}
			fields = append(fields, field)
		}
		{{ else -}}
        if {{ .IsValidValue -}} {
			{{- if eq .CanExpand true -}} if expanded := m.IsExpandedField({{ .Num }}); !expanded || (expanded && options.IncludeExpandedFields) { {{ end }}
			field := fac.CreateField(mesg.Num, {{ .Num }})
			{{ if gt .FixedArraySize 0 -}}
			{{- /* DO NOT reslice directly from the struct (e.g. m.Velocity[:]), otherwise, we will keep referencing
				the struct since we promote the array from the same memory block as the struct. We must copy the array
				to local variable, so it will be promoted instead (we only need the local variable to escape to the heap),
				only then the struct can be garbage-collected on next GC's cycle. */ -}}
			copied := m.{{ .Name }}
			field.Value = {{ stringReplace .ProtoValue (printf "m.%s" .Name) "copied[:]" -1 }}
			{{ else -}}
			field.Value = {{ .ProtoValue }}
			{{ end -}}
			{{ if eq .CanExpand true -}}
				field.IsExpandedField = expanded
			{{ end -}}
			fields = append(fields, field)
			{{ if eq .CanExpand true -}} } {{ end -}}
        }
        {{ end -}}
	{{ end }}

    mesg.Fields = make([]proto.Field, len(fields))
    copy(mesg.Fields, fields)
    pool.Put(arr)

	{{ if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription"))  }}
	mesg.DeveloperFields = m.DeveloperFields
	{{ end }}

	return mesg
}

{{ range .DynamicFields -}}
// Get{{ .Name }} returns Dynamic Field interpretation of {{ .Name }}. Otherwise, returns the original value of {{ .Name }}.
// 
{{ range .SwitchCases -}} 
// Based on {{ .Name }}:
	{{ range .CondValues -}}
//   - name: "{{ .ReturnValue.Name }}" {{- if .ReturnValue.Units -}}, units: "{{ .ReturnValue.Units }}" {{ end }}, value: {{ .ReturnValue.Value }}
	{{ end -}}
{{ end -}}
// Otherwise:
//   - name: "{{ .Default.Name }}" {{- if .Default.Units -}}, units: "{{ .Default.Units }}" {{ end }}, value: {{ .Default.Value }}
func (m *{{ $.Name }}) Get{{ .Name }}() (name string, value any) {
{{ range .SwitchCases -}}
	switch {{ .Name -}} {
	{{- range .CondValues }}
	case {{ stringsJoin .Conds "," }}:
		return "{{ .ReturnValue.Name }}", {{ .ReturnValue.Value -}}
	{{ end}}
	}
{{ end -}}
	return "{{ .Default.Name }}", {{ .Default.Value }}
}
{{ end }}

{{ range .Fields -}}
{{ if eq .Type "time.Time" }}
// {{ .Name }}Uint32 returns {{ .Name }} in uint32 (seconds since FIT's epoch) instead of time.Time.
func (m *{{ $.Name }}) {{ .Name }}Uint32() uint32 { return datetime.ToUint32(m.{{ .Name }}) }
{{ end }}
{{ end }}

{{ range .Fields -}}
{{ if not (and (eq .Scale 1.0) (eq .Offset 0.0)) }}
// {{ .Name }}Scaled return {{ .Name }} in its scaled value.
// If {{ .Name }} value is invalid,{{ if .Array }} nil {{ else }} float64 invalid value {{ end -}} will be returned.
// 
// {{ .Comment }}
func (m *{{ $.Name }}) {{ .Name }}Scaled() {{ if gt .FixedArraySize 0 }} [{{ .FixedArraySize }}]float64 {{ else if .Array }} []float64 {{ else }} float64 {{ end -}} {
	if {{ .ComparableValue }} == {{ .InvalidValue }} {
		return {{ if gt .FixedArraySize 0 }} {{ .InvalidArrayValueScaled }} {{ else if .Array }} nil {{ else }} math.Float64frombits(basetype.Float64Invalid) {{ end -}}
	}
	{{- if gt .FixedArraySize 0 }}
		var vals [{{ .FixedArraySize }}]float64
		for i := range m.{{ .Name }} {
			if m.{{ .Name }}[i] == {{ .BaseTypeInvalid }} {
				vals[i] = math.Float64frombits(basetype.Float64Invalid)
				continue
			}
			vals[i] = float64(m.{{ .Name }}[i]) / {{ .Scale }} -{{ .Offset }}
		}
		return vals
	{{- else if .Array }}
		var vals = make([]float64, len(m.{{ .Name }}))
		for i := range m.{{ .Name }} {
			if m.{{ .Name }}[i] == {{ .BaseTypeInvalid }} {
				vals[i] = math.Float64frombits(basetype.Float64Invalid)
				continue
			}
			vals[i] = float64(m.{{ .Name }}[i]) / {{ .Scale }} - {{ .Offset }}
		}
		return vals
	{{- else }}
		return float64(m.{{ .Name }}) / {{ .Scale }} - {{ .Offset }}
	{{ end -}}
}
{{ end }}
{{ end }}


{{ range .Fields -}}
{{ if eq .Units "semicircles" }}
// {{ .Name }}Degrees returns {{ .Name }} in degrees instead of semicircles.
// If {{ .Name }} value is invalid, float64 invalid value will be returned.
func (m *{{ $.Name }}) {{ .Name }}Degrees() float64 { 
    if {{ .ComparableValue }} == {{ .InvalidValue }} {
        return math.Float64frombits(basetype.Float64Invalid)
    }
    return semicircles.ToDegrees(m.{{ .Name }})
 }
{{ end }}
{{ end }}

{{ range .Fields -}}
// Set{{ .Name }} sets {{ .Name }} value.
//
// {{ .Comment }}
func (m *{{ $.Name }}) Set{{ .Name }}(v {{ .Type }}) *{{ $.Name }} {
    m.{{ .Name }} = v
    return m
}

{{ if not (and (eq .Scale 1.0) (eq .Offset 0.0)) -}}
// Set{{ .Name }}Scaled is similar to Set{{ .Name }} except it accepts a scaled value.
// This method automatically converts the given value to its {{ .Type }} form, discarding any applied scale and offset.
// 
// {{ .Comment }}
func (m *{{ $.Name }}) Set{{ .Name }}Scaled({{ if gt .FixedArraySize 0 }} vs [{{ .FixedArraySize }}]float64 {{ else if .Array }} vs []float64 {{ else }} v float64 {{ end }}) *{{ $.Name }} {
	{{ if gt .FixedArraySize 0 -}}
	m.{{ .Name }} = {{ .InvalidValue }}
	for i := range vs {
		unscaled := (vs[i] + {{ .Offset }}) * {{ .Scale }}
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64({{ .BaseTypeInvalid }}) {
			continue
		}
		m.{{ .Name }}[i] = {{ extractExactlyType .Type }}(unscaled)
	}
	{{ else if .Array -}}
	if vs == {{ .InvalidValue }} {
		m.{{ .Name }} = {{ .InvalidValue }}
		return m
	}
	m.{{ .Name }} = make({{ .Type }}, len(vs))
	for i := range vs {
		unscaled := (vs[i] + {{ .Offset }}) * {{ .Scale }}
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64({{ .BaseTypeInvalid }}) {
			m.{{ .Name }}[i] = {{ extractExactlyType .Type }}({{ .BaseTypeInvalid }})
			continue
		}
		m.{{ .Name }}[i] = {{ extractExactlyType .Type }}(unscaled)
	}
    {{ else -}}
	unscaled := (v + {{ .Offset }}) * {{ .Scale }}
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64({{ .BaseTypeInvalid }}) {
		m.{{ .Name }} = {{ .Type }}({{ .BaseTypeInvalid }})
		return m
	}
	m.{{ .Name }} = {{ .Type }}(unscaled)
    {{ end -}}

    return m
}
{{ end -}}

{{ if eq .Units "semicircles" -}}
// Set{{ .Name }}Degrees is similar to Set{{ .Name }} except it accepts a value in degrees.
// This method will automatically convert given degrees value to semicircles ({{ .Type }}) form.
func (m *{{ $.Name }}) Set{{ .Name }}Degrees(degrees float64) *{{ $.Name }} {
    m.{{ .Name }} = semicircles.ToSemicircles(degrees)
    return m
}
{{ end -}}

{{ end }}

{{- if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription")) }}
// SetDeveloperFields {{ $.Name }}'s DeveloperFields.
func (m *{{ $.Name }}) SetDeveloperFields(developerFields ...proto.DeveloperField) *{{ $.Name }} {
    m.DeveloperFields = developerFields
    return m
}
{{ end }}

{{ if gt .MaxFieldExpandNum 1 -}}
// MarkAsExpandedField marks whether given fieldNum is an expanded field (field that being
// generated through a component expansion). Eligible for field number: {{- template "eligible_for_expanded_fields" . }}.
func (m *{{ $.Name }}) MarkAsExpandedField(fieldNum byte, flag bool) (ok bool) {
	switch fieldNum {
	case {{ template "eligible_for_expanded_fields" . }}:
	default:
		return false
	}
	pos := fieldNum/8
	bit := uint8(1) << (fieldNum - (8 * pos))
	m.state[pos] &^= bit
	if flag {
		m.state[pos] |= bit
	}
	return true
}

// IsExpandedField checks whether given fieldNum is a field generated through
// a component expansion. Eligible for field number: {{- template "eligible_for_expanded_fields" . }}.
func (m *{{ $.Name }}) IsExpandedField(fieldNum byte) bool {
	{{/* Simple check is enough since we validate on marking */ -}}
	if fieldNum >= {{ .MaxFieldExpandNum }} {
		return false
	}
	pos := fieldNum/8
	bit := uint8(1) << (fieldNum - (8 * pos))
	return m.state[pos] & bit == bit
}
{{ end }}

{{ end }}

{{ define "eligible_for_expanded_fields" }}
{{- $first := true -}}
{{ range $i, $v := .Fields -}}
	{{- if .CanExpand -}}
		{{- if $first -}} {{ $first = false }} {{ .Num }}
		{{- else -}}, {{ .Num }} {{- end }}
	{{- end -}}
{{- end -}}
{{ end }}

{{ define "util" }}
// Code generated by internal/cmd/fitgen/main.go. DO NOT EDIT.

// Copyright 2024 The FIT SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package {{ .Package }}

import (
    "github.com/muktihari/fit/proto"
    "sync"
)

const poolsize = {{ .MaxLenFields }} // Max fields' length from the entire messages.

var pool = sync.Pool{New: func() any { return new([poolsize]proto.Field) }}

{{ end }}