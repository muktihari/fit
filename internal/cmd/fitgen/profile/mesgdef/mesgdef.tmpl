{{ define "mesgdef" }}
// Code generated by internal/cmd/fitgen/main.go. DO NOT EDIT.
// SDK Version: {{ .SDKVersion }}

// Copyright 2023 The Fit SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package {{ .Package }}

import (
	"github.com/muktihari/fit/kit/typeconv"
	"github.com/muktihari/fit/profile/typedef"
	"github.com/muktihari/fit/proto"
	{{- if .Imports -}}
        {{ range $_, $v := .Imports }}
            {{ printf "%q" $v -}}
        {{ end }}
    {{ end }}
)

// {{ .Name }} is a {{ .Name }} message.
type {{ .Name }} struct {
	{{ range .Fields -}}
	{{ .Name }} {{ .Type }} {{ if .Comment }} // {{ .Comment }} {{ end }}
	{{ end }}

	{{- if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription")) }}
	// Developer Fields are dynamic, can't be mapped as struct's fields. 
	// [Added since protocol version 2.0]
	DeveloperFields []proto.DeveloperField
	{{- end -}}
}

// New{{ .Name }} creates new {{ .Name }} struct based on given mesg. If mesg is nil or mesg.Num is not equal to {{ .Name }} mesg number, it will return nil.
func New{{ .Name }}(mesg proto.Message) *{{ .Name }} {
	if mesg.Num != typedef.MesgNum{{ .Name }} {
		return nil
	}

    vals := [{{ .MaxFieldNum }}]any{}
	for i := range mesg.Fields {
		field := &mesg.Fields[i]
		if field.Num >= byte(len(vals)) {
			continue
		}
		vals[field.Num] = field.Value
	}

	return &{{ .Name }}{
		{{ range .Fields -}}
			{{ .Name }}: {{ .TypedValue }},
		{{ end -}}

		{{- if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription"))  }}
		DeveloperFields: mesg.DeveloperFields,
		{{ end }}
	}
}

// ToMesg converts {{ .Name }} into proto.Message.
func (m *{{ .Name }}) ToMesg(fac Factory) proto.Message {
    mesg := fac.CreateMesgOnly(typedef.MesgNum{{ .Name }})
	mesg.Fields = make([]proto.Field, 0, m.size())

    {{ range .Fields -}}
        if {{ .ComparableValue }} != {{ .InvalidValue }} {
            field := fac.CreateField(mesg.Num, {{ .Num }})
            field.Value = {{ .PrimitiveValue }}
            mesg.Fields = append(mesg.Fields, field)
        }
	{{ end }}

	{{ if and (not (eq .Name "FileId")) (not (eq .Name "DeveloperDataId")) (not (eq .Name "FieldDescription"))  }}
	mesg.DeveloperFields = m.DeveloperFields
	{{ end }}

	return mesg
}

// size returns size of {{ .Name }}'s valid fields.
func (m *{{ .Name }}) size() byte {
    var size byte
    {{ range .Fields -}}
        if {{ .ComparableValue }} != {{ .InvalidValue }} {
            size++
        }
	{{ end -}}
    return size
}

{{ end }}