// Copyright 2024 The FIT SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build ignore

package main

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"

	"github.com/muktihari/fit/internal/cmd/fitgen/pkg/strutil"
	"github.com/muktihari/fit/profile"
)

var (
	// Regardless the current working directory where this script is executed,
	// make generated files relative to this file.
	_, path, _, _ = runtime.Caller(0)
	dir           = filepath.Dir(path)
	filename      = filepath.Join(dir, "typedef_gen.go")
)

func main() {
	var buf bytes.Buffer

	buf.WriteString(`// Code generated by cmd/fitconv/fitprint/typedef.go using 'go generate'. DO NOT EDIT.

// Copyright 2024 The FIT SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package printer

import (
	"fmt"

	"github.com/muktihari/fit/proto"
	"github.com/muktihari/fit/profile"
	"github.com/muktihari/fit/profile/basetype"
	"github.com/muktihari/fit/profile/typedef"
)
`)

	buf.WriteString(fmt.Sprintf(`
// Compile-time assertion, build will fail if profile.Version is updated 
// but this code is not yet regenerated, ensuring we are generating safer code.
func _() { _ = [1]struct{}{}[profile.Version-%d] }`, profile.Version))

	profileTypes := profile.ListProfileType()

	buf.WriteString(`

func TypedefString(pt profile.ProfileType, v proto.Value) string {
	switch pt {`)

	for _, profileType := range profileTypes {
		if profileType <= profile.Bool {
			buf.WriteString(fmt.Sprintf(`
	case profile.%s:
		return "" // skip`,
				strutil.ToTitle(profileType.String()),
			))
			continue
		}

		valueTypeName := strutil.ToTitle(profileType.BaseType().String())
		valueTypeName = strings.Replace(valueTypeName, "sint", "int", 1)
		if valueTypeName == "Byte" || valueTypeName == "Enum" {
			valueTypeName = "Uint8"
		}

		typedefName := "typedef." + strutil.ToTitle(profileType.String())
		if typedefName == "typedef.FitBaseType" {
			typedefName = "basetype.BaseType"
		}

		switch profileType {
		case profile.DateTime,
			profile.LocalDateTime,
			profile.TimeIntoDay,
			profile.LocaltimeIntoDay:
			buf.WriteString(fmt.Sprintf(`
	case profile.%s:
		return "" // skip`,
				strutil.ToTitle(profileType.String()),
			))
			continue
		}

		buf.WriteString(fmt.Sprintf(`
	case profile.%s:
		return %s(v.%s()).String()`,
			strutil.ToTitle(profileType.String()),
			typedefName,
			valueTypeName,
		))
	}

	buf.WriteString(`
	}

	return fmt.Sprintf("%v", pt.BaseType().Invalid())
}`)

	err := os.WriteFile(filename, buf.Bytes(), 0666)
	if err != nil {
		fmt.Fprintf(os.Stderr, "typedef: %s\n", err)
		os.Exit(2)
	}

	buf.Reset()
	cmd := exec.Command("gofmt", "-s", "-w", filename)
	cmd.Stderr = &buf
	if err := cmd.Run(); err != nil {
		fmt.Fprintf(os.Stderr, "gofmt -s -w %s, stderr: \n%s\n", filename, buf.String())
		os.Exit(2)
	}
}
