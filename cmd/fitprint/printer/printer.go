// Copyright 2024 The FIT SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package printer

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"time"

	_ "unsafe"

	"github.com/muktihari/fit/decoder"
	"github.com/muktihari/fit/factory"
	"github.com/muktihari/fit/kit/datetime"
	"github.com/muktihari/fit/kit/scaleoffset"
	"github.com/muktihari/fit/kit/semicircles"
	"github.com/muktihari/fit/profile"
	"github.com/muktihari/fit/profile/basetype"
	"github.com/muktihari/fit/proto"
)

const fitprintGithubURL = "https://github.com/muktihari/fit/tree/master/cmd/fitprint"

//go:linkname bitsFromValue github.com/muktihari/fit/decoder.bitsFromValue
func bitsFromValue(value proto.Value) (bits uint32, ok bool)

//go:linkname valueFromBits github.com/muktihari/fit/decoder.valueFromBits
func valueFromBits(bits uint32, baseType basetype.BaseType) proto.Value

func Print(path string) error {
	ext := filepath.Ext(path)
	if strings.ToLower(ext) != ".fit" {
		return fmt.Errorf("expected ext: *.fit, got: %s", ext)
	}

	f, err := os.Open(path)
	if err != nil {
		return fmt.Errorf("could not open file %s: %w", path, err)
	}
	defer f.Close()

	abspath, err := filepath.Abs(path)
	if err != nil {
		abspath = path
	}
	base := filepath.Base(path)
	dir := filepath.Dir(path)

	name := base
	if len(ext) < len(base) {
		name = base[:len(base)-len(ext)]
	}
	name = name + "-fitprint.txt"

	resultPath := filepath.Join(dir, name)
	out, err := os.OpenFile(resultPath, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
	if err != nil {
		return err
	}
	defer out.Close()

	bw := bufio.NewWriter(out)
	defer bw.Flush()

	p := New(bw)
	defer p.Close()

	dec := decoder.New(f,
		decoder.WithMesgListener(p),
		decoder.WithBroadcastOnly(),
		decoder.WithIgnoreChecksum(),
	)

	fmt.Fprintf(bw, "File generated by %s\nFilepath: %q", fitprintGithubURL, abspath)

	for dec.Next() {
		fileHeader, err := dec.PeekFileHeader()
		if err != nil {
			return err
		}

		fmt.Fprintf(bw, `

File Header:
  - Size: %d
  - Protocol Version: %s (%d)
  - Profile Version: %d
  - DataSize: %d
  - DataType: %q
  - CRC: %d

`,
			fileHeader.Size,
			fmt.Sprintf("%d.%d",
				proto.VersionMajor(fileHeader.ProtocolVersion),
				proto.VersionMinor(fileHeader.ProtocolVersion)),
			fileHeader.ProtocolVersion,
			fileHeader.ProfileVersion,
			fileHeader.DataSize,
			fileHeader.DataType,
			fileHeader.CRC,
		)

		fit, err := dec.Decode()
		if err != nil {
			return fmt.Errorf("could not decode: %w", err)
		}

		p.Wait()

		fmt.Fprintf(bw, "\nFile CRC: %d", fit.CRC)
	}

	fmt.Printf("ðŸ“„ %q -> %q\n", path, resultPath)

	return nil
}

const channelBuffer = 1000

type printer struct {
	w      io.Writer
	poolc  chan proto.Message
	mesgc  chan proto.Message
	done   chan struct{}
	active bool
	count  int
}

func New(w io.Writer) *printer {
	p := &printer{w: w}
	p.reset()

	p.poolc = make(chan proto.Message, channelBuffer)
	for i := 0; i < channelBuffer; i++ {
		p.poolc <- proto.Message{}
	}

	go p.loop()
	return p
}

func (p *printer) loop() {
	for mesg := range p.mesgc {
		p.print(mesg)
		p.poolc <- mesg
		p.count++
	}
	close(p.done)
}

func (p *printer) reset() {
	p.mesgc = make(chan proto.Message, channelBuffer)
	p.done = make(chan struct{})
	p.count = 0
	p.active = true
}

func (p *printer) Wait() {
	if !p.active {
		return
	}
	close(p.mesgc)
	<-p.done
	p.active = false
}

func (p *printer) Close() {
	p.Wait()
	close(p.poolc)
}

var _ decoder.MesgListener = &printer{}

func (p *printer) OnMesg(mesg proto.Message) {
	if !p.active {
		p.reset()
		go p.loop()
		p.active = true
	}
	p.mesgc <- p.prep(mesg)
}

func (p *printer) prep(mesg proto.Message) proto.Message {
	m := <-p.poolc

	if cap(m.Fields) < len(mesg.Fields) {
		m.Fields = make([]proto.Field, len(mesg.Fields))
	}
	m.Fields = m.Fields[:len(mesg.Fields)]
	copy(m.Fields, mesg.Fields)
	mesg.Fields = m.Fields

	if cap(m.DeveloperFields) < len(mesg.DeveloperFields) {
		m.DeveloperFields = make([]proto.DeveloperField, len(mesg.DeveloperFields))
	}
	m.DeveloperFields = m.DeveloperFields[:len(mesg.DeveloperFields)]
	copy(m.DeveloperFields, mesg.DeveloperFields)
	mesg.DeveloperFields = m.DeveloperFields

	return mesg
}

func (p *printer) print(mesg proto.Message) {
	numstr := mesg.Num.String()
	if strings.HasPrefix(numstr, "MesgNumInvalid") {
		numstr = factory.NameUnknown
	}

	fmt.Fprintf(p.w, "%s (num: %d, fields[-]: %d, developerFields[+]: %d) [%d]:\n",
		numstr, mesg.Num, len(mesg.Fields), len(mesg.DeveloperFields), p.count)

	for j := range mesg.Fields {
		field := &mesg.Fields[j]

		var (
			isDynamicField = false
			name           = field.Name
			baseType       = field.BaseType
			profileType    = field.Type
			scale          = field.Scale
			offset         = field.Offset
			units          = field.Units
		)

		if subField := field.SubFieldSubtitution(&mesg); subField != nil {
			isDynamicField = true
			name = subField.Name
			baseType = subField.Type.BaseType()
			profileType = subField.Type
			scale = subField.Scale
			offset = subField.Offset
			units = subField.Units
		}

		valstr := formatFieldValue(
			field.Value,
			baseType,
			profileType,
			scale,
			offset,
			units,
			isDynamicField,
		)

		if units == "semicircles" {
			valstr = fmt.Sprintf("%s (%g degrees)", valstr, semicircles.ToDegrees(field.Value.Int32()))
		}

		if !field.Value.Valid(baseType) {
			valstr = fmt.Sprintf("%s (INVALID)", valstr)
		}

		if isDynamicField {
			typestr := field.BaseType.String() // Add parent type.
			if field.BaseType.String() != field.Type.String() {
				typestr = fmt.Sprintf("%s | %s", typestr, field.Type)
			}
			valstr = fmt.Sprintf("%s <<DynamicField: %q (type: %s)>>",
				valstr, field.Name, typestr)
		}

		if field.IsExpandedField {
			valstr = fmt.Sprintf("%s <<ExpandedField>>", valstr)
		}

		typestr := baseType.String()
		if baseType.String() != profileType.String() {
			typestr = fmt.Sprintf("%s | %s", typestr, profileType)
		}
		if field.Array {
			typestr += " array"
		}

		fmt.Fprintf(p.w, "  - %s (num: %d, type: %s): %v\n",
			name, field.Num, typestr, valstr,
		)
	}

	for i := range mesg.DeveloperFields {
		fmt.Fprintf(p.w, "  + %s (num: %d, type: %s): %v\n",
			mesg.DeveloperFields[i].Name,
			mesg.DeveloperFields[i].Num,
			mesg.DeveloperFields[i].BaseType,
			formatDeveloperFieldValue(&mesg.DeveloperFields[i]))
	}
}

func formatFieldValue(
	value proto.Value,
	baseType basetype.BaseType,
	profileType profile.ProfileType,
	scale, offset float64,
	units string,
	isDynamicField bool,
) string {
	switch profileType {
	case profile.DateTime, profile.LocalDateTime: // Special Case: time.Time
		return fmt.Sprintf("%q (%d)", datetime.ToTime(value).Format(time.RFC3339), value.Uint32())
	}

	if scale != 1 || offset != 0 { // Scaled Value
		return fmt.Sprintf("%v %s ((%v / %g) - %g)",
			scaleoffset.ApplyValue(value, scale, offset).Any(),
			units,
			value.Any(),
			scale,
			offset,
		)
	}

	switch value.Type() { // Format string value(s)
	case proto.TypeString:
		return strings.TrimSpace(fmt.Sprintf("%q %s", value.String(), units))
	case proto.TypeSliceString:
		sb := new(strings.Builder)
		sb.WriteString("[")
		vals := value.SliceString()
		for i := range vals {
			sb.WriteString(fmt.Sprintf("%q", vals[i]))
			if i != len(vals)-1 {
				sb.WriteString(", ")
			}
		}
		sb.WriteString("]")
		return strings.TrimSpace(fmt.Sprintf("%v %s", sb.String(), units))
	}

	valstr := strings.TrimSpace(fmt.Sprintf("%v %s", value.Any(), units))
	if !value.Valid(baseType) {
		return valstr
	}

	if value.Type() > proto.TypeString { // Array
		switch value.Type() {
		case proto.TypeSliceInt8:
			valstr = formatCast(value.SliceInt8(), baseType, profileType)
		case proto.TypeSliceUint8:
			valstr = formatCast(value.SliceUint8(), baseType, profileType)
		case proto.TypeSliceInt16:
			valstr = formatCast(value.SliceInt16(), baseType, profileType)
		case proto.TypeSliceUint16:
			valstr = formatCast(value.SliceUint16(), baseType, profileType)
		case proto.TypeSliceInt32:
			valstr = formatCast(value.SliceInt32(), baseType, profileType)
		case proto.TypeSliceUint32:
			valstr = formatCast(value.SliceUint32(), baseType, profileType)
		case proto.TypeSliceInt64:
			valstr = formatCast(value.SliceInt64(), baseType, profileType)
		case proto.TypeSliceUint64:
			valstr = formatCast(value.SliceUint64(), baseType, profileType)
		case proto.TypeSliceFloat32:
			valstr = formatCast(value.SliceFloat32(), baseType, profileType)
		case proto.TypeSliceFloat64:
			valstr = formatCast(value.SliceFloat64(), baseType, profileType)
		}
		return valstr
	}

	if isDynamicField { // Cast value as dynamic field's target type
		bits, _ := bitsFromValue(value)
		value = valueFromBits(bits, baseType)
	}
	ts := TypedefString(profileType, value)
	if strings.Contains(ts, "Invalid") {
		valstr = fmt.Sprintf("%s <unknown(%s)>", valstr, valstr)
	} else if ts != "" {
		valstr = fmt.Sprintf("%s <%s>", valstr, ts)
	}

	return valstr

}

func formatCast[S []E, E any](s S, bt basetype.BaseType, pt profile.ProfileType) string {
	ss := make([]string, 0, len(s))
	for i := range s {
		bits, _ := bitsFromValue(proto.Any(s[i]))
		val := valueFromBits(bits, bt)
		ts := TypedefString(pt, val)
		if strings.Contains(ts, "Invalid") {
			ss = append(ss, fmt.Sprintf("unknown(%v)", val.Any()))
		} else if ts != "" {
			ss = append(ss, ts)
		}
	}
	if len(ss) == 0 {
		return fmt.Sprintf("%v", s)
	}
	return fmt.Sprintf("%v <%v>", s, ss)
}

func formatDeveloperFieldValue(developerField *proto.DeveloperField) string {
	return fmt.Sprintf("%v %s", developerField.Value.Any(), developerField.Units)
}
