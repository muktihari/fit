// Copyright 2024 The FIT SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package printer

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"slices"
	"strconv"
	"strings"
	"time"

	"github.com/muktihari/fit/decoder"
	"github.com/muktihari/fit/kit/datetime"
	"github.com/muktihari/fit/kit/scaleoffset"
	"github.com/muktihari/fit/kit/semicircles"
	"github.com/muktihari/fit/profile"
	"github.com/muktihari/fit/profile/basetype"
	"github.com/muktihari/fit/profile/factory"
	"github.com/muktihari/fit/profile/mesgdef"
	"github.com/muktihari/fit/profile/untyped/mesgnum"
	"github.com/muktihari/fit/proto"
)

const fitprintGithubURL = "https://github.com/muktihari/fit/tree/master/cmd/fitprint"

func Print(path string) error {
	ext := filepath.Ext(path)
	if strings.ToLower(ext) != ".fit" {
		return fmt.Errorf("expected ext: *.fit, got: %s", ext)
	}

	f, err := os.Open(path)
	if err != nil {
		return fmt.Errorf("open file %s: %w", path, err)
	}
	defer f.Close()

	abspath, err := filepath.Abs(path)
	if err != nil {
		abspath = path
	}
	base := filepath.Base(path)
	dir := filepath.Dir(path)

	name := base
	if len(ext) < len(base) {
		name = base[:len(base)-len(ext)]
	}
	name = name + "-fitprint.txt"

	resultPath := filepath.Join(dir, name)
	out, err := os.OpenFile(resultPath, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
	if err != nil {
		return err
	}
	defer out.Close()

	bw := bufio.NewWriter(out)
	defer bw.Flush()

	p := New(bw)
	defer p.Close()

	dec := decoder.New(f,
		decoder.WithMesgDefListener(p),
		decoder.WithMesgListener(p),
		decoder.WithBroadcastOnly(),
		decoder.WithIgnoreChecksum(),
	)

	fmt.Fprintf(bw, "File generated by %s\nFilepath: %q", fitprintGithubURL, abspath)

	for dec.Next() {
		fileHeader, err := dec.PeekFileHeader()
		if err != nil {
			return err
		}

		fmt.Fprintf(bw, `

File Header:
  - Size: %d
  - Protocol Version: %s (%d)
  - Profile Version: %d
  - DataSize: %d
  - DataType: %q
  - CRC: %d

`,
			fileHeader.Size,
			fmt.Sprintf("%d.%d",
				fileHeader.ProtocolVersion.Major(),
				fileHeader.ProtocolVersion.Minor()),
			fileHeader.ProtocolVersion,
			fileHeader.ProfileVersion,
			fileHeader.DataSize,
			fileHeader.DataType,
			fileHeader.CRC,
		)

		fit, err := dec.Decode()
		if err != nil {
			return fmt.Errorf("decode: %w", err)
		}

		p.Wait()

		fmt.Fprintf(bw, "\nFile CRC: %d", fit.CRC)
	}

	fmt.Printf("ðŸ“„ %q -> %q\n", path, resultPath)

	return nil
}

const channelBuffer = 1000

type printer struct {
	w                       io.Writer
	localMessageDefinitions [proto.LocalMesgNumMask + 1]proto.MessageDefinition
	poolc                   chan proto.Message
	messagec                chan message
	done                    chan struct{}
	active                  bool
	count                   int

	fieldDescriptions []*mesgdef.FieldDescription
}

type message struct {
	proto.Message
	Size                      byte
	Reserved                  byte
	Architecture              byte
	FieldDefinitions          []proto.FieldDefinition
	DeveloperFieldDefinitions []proto.DeveloperFieldDefinition
}

func New(w io.Writer) *printer {
	p := &printer{w: w}
	p.reset()

	p.poolc = make(chan proto.Message, channelBuffer)
	for i := 0; i < channelBuffer; i++ {
		p.poolc <- proto.Message{}
	}

	go p.loop()
	return p
}

func (p *printer) loop() {
	for m := range p.messagec {
		switch m.Num {
		case mesgnum.FieldDescription:
			p.fieldDescriptions = append(p.fieldDescriptions, mesgdef.NewFieldDescription(&m.Message))
		}
		p.print(m)
		p.poolc <- m.Message
		p.count++
	}
	close(p.done)
}

func (p *printer) reset() {
	p.messagec = make(chan message, channelBuffer)
	p.done = make(chan struct{})
	p.count = 0
	p.active = true
}

func (p *printer) Wait() {
	if !p.active {
		return
	}
	close(p.messagec)
	<-p.done
	p.active = false
}

func (p *printer) Close() {
	p.Wait()
	close(p.poolc)
}

var _ decoder.MesgDefListener = (*printer)(nil)

func (p *printer) OnMesgDef(mesgDef proto.MessageDefinition) {
	p.localMessageDefinitions[proto.LocalMesgNum(mesgDef.Header)] = mesgDef
}

var _ decoder.MesgListener = (*printer)(nil)

func (p *printer) OnMesg(mesg proto.Message) {
	if !p.active {
		p.reset()
		go p.loop()
		p.active = true
	}
	p.messagec <- p.prep(mesg)
}

func (p *printer) prep(mesg proto.Message) message {
	m := <-p.poolc

	if cap(m.Fields) < len(mesg.Fields) {
		m.Fields = make([]proto.Field, len(mesg.Fields))
	}
	m.Fields = m.Fields[:len(mesg.Fields)]
	copy(m.Fields, mesg.Fields)
	mesg.Fields = m.Fields

	if cap(m.DeveloperFields) < len(mesg.DeveloperFields) {
		m.DeveloperFields = make([]proto.DeveloperField, len(mesg.DeveloperFields))
	}
	m.DeveloperFields = m.DeveloperFields[:len(mesg.DeveloperFields)]
	copy(m.DeveloperFields, mesg.DeveloperFields)
	mesg.DeveloperFields = m.DeveloperFields

	mesgDef := p.localMessageDefinitions[proto.LocalMesgNum(mesg.Header)]

	var size byte
	for _, v := range mesgDef.FieldDefinitions {
		size += v.Size
	}
	for _, v := range mesgDef.DeveloperFieldDefinitions {
		size += v.Size
	}

	return message{Message: mesg,
		Size:                      size,
		Reserved:                  mesgDef.Reserved,
		Architecture:              mesgDef.Architecture,
		FieldDefinitions:          slices.Clone(mesgDef.FieldDefinitions),
		DeveloperFieldDefinitions: slices.Clone(mesgDef.DeveloperFieldDefinitions),
	}
}

func (p *printer) print(m message) {
	numstr := m.Num.String()
	if strings.HasPrefix(numstr, "MesgNumInvalid") {
		numstr = factory.NameUnknown
	}

	var nFields, nExpandedField int
	for i := range m.Fields {
		if !m.Fields[i].IsExpandedField {
			nFields++
		} else {
			nExpandedField++
		}

	}

	fmt.Fprintf(p.w, "%s (num: %d, arch: %d, size: %d, fields[-]: %d, expandedFields[x]: %d, developerFields[+]: %d) [%d]:\n",
		numstr, m.Num, m.Architecture, m.Size, nFields, nExpandedField, len(m.DeveloperFields), p.count)

	for i := range m.Fields {
		field := &m.Fields[i]

		var (
			isDynamicField = false
			name           = field.Name
			baseType       = field.BaseType
			profileType    = field.Type
			scale          = field.Scale
			offset         = field.Offset
			units          = field.Units
			flag           = '-'
		)

		if subField := field.SubFieldSubtitution(&m.Message); subField != nil {
			isDynamicField = true
			name = subField.Name
			baseType = subField.Type.BaseType()
			profileType = subField.Type
			scale = subField.Scale
			offset = subField.Offset
			units = subField.Units
		}

		valstr := formatFieldValue(
			field.Value,
			baseType,
			profileType,
			scale,
			offset,
			units,
			isDynamicField,
		)

		if units == "semicircles" {
			valstr = fmt.Sprintf("%s (%g degrees)", valstr, semicircles.ToDegrees(field.Value.Int32()))
		}

		if !field.Value.Valid(baseType) {
			valstr = fmt.Sprintf("%s (INVALID)", valstr)
		}

		if isDynamicField {
			typestr := field.BaseType.String() // Add parent type.
			if field.BaseType.String() != field.Type.String() {
				typestr = fmt.Sprintf("%s | %s", typestr, field.Type)
			}
			valstr = fmt.Sprintf("%s <<DynamicField: %q (type: %s)>>",
				valstr, field.Name, typestr)
		}

		var size string
		if i < len(m.FieldDefinitions) {
			size = strconv.Itoa(int(m.FieldDefinitions[i].Size))
		}

		if field.IsExpandedField {
			flag = 'x'
			size = "?"
		}

		typestr := baseType.String()
		if baseType.String() != profileType.String() {
			typestr = fmt.Sprintf("%s | %s", typestr, profileType)
		}
		if field.Array {
			typestr += " array"
		}

		fmt.Fprintf(p.w, " %c %s (num: %d, type: %s, size: %s): %v\n",
			flag, name, field.Num, typestr, size, valstr,
		)
	}

	for k := range m.DeveloperFields {
		devField := &m.DeveloperFields[k]
		fieldDesc := p.getFieldDescription(devField.DeveloperDataIndex, devField.Num)
		if fieldDesc == nil {
			continue
		}
		fmt.Fprintf(p.w, " + %s (num: %d, type: %s, size: %d): %v\n",
			strings.Join(fieldDesc.FieldName, "|"),
			devField.Num,
			fieldDesc.FitBaseTypeId,
			m.DeveloperFieldDefinitions[k].Size,
			formatDeveloperFieldValue(devField.Value, strings.Join(fieldDesc.Units, "|")),
		)
	}
}

func (c *printer) getFieldDescription(developerDataIndex, fieldDefinitionNumber uint8) *mesgdef.FieldDescription {
	for _, fieldDesc := range c.fieldDescriptions {
		if fieldDesc.DeveloperDataIndex == developerDataIndex &&
			fieldDesc.FieldDefinitionNumber == fieldDefinitionNumber {
			return fieldDesc
		}
	}
	return nil
}

func formatFieldValue(
	value proto.Value,
	baseType basetype.BaseType,
	profileType profile.ProfileType,
	scale, offset float64,
	units string,
	isDynamicField bool,
) string {
	switch profileType {
	case profile.DateTime, profile.LocalDateTime: // Special Case: time.Time
		return fmt.Sprintf("%q (%d)", datetime.ToTime(value.Uint32()).Format(time.RFC3339), value.Uint32())
	}

	if scale != 1 || offset != 0 { // Scaled Value
		return fmt.Sprintf("%v %s ((%v / %g) - %g)",
			scaleoffset.ApplyValue(value, scale, offset).Any(),
			units,
			value.Any(),
			scale,
			offset,
		)
	}

	switch value.Type() { // Format string value(s)
	case proto.TypeString:
		return strings.TrimSpace(fmt.Sprintf("%q %s", value.String(), units))
	case proto.TypeSliceString:
		sb := new(strings.Builder)
		sb.WriteString("[")
		vals := value.SliceString()
		for i := range vals {
			sb.WriteString(fmt.Sprintf("%q", vals[i]))
			if i != len(vals)-1 {
				sb.WriteString(", ")
			}
		}
		sb.WriteString("]")
		return strings.TrimSpace(fmt.Sprintf("%v %s", sb.String(), units))
	}

	valstr := strings.TrimSpace(fmt.Sprintf("%v %s", value.Any(), units))
	if !value.Valid(baseType) {
		return valstr
	}

	if value.Type() > proto.TypeString { // Array
		switch value.Type() {
		case proto.TypeSliceInt8:
			valstr = formatCast(value.SliceInt8(), baseType, profileType)
		case proto.TypeSliceUint8:
			valstr = formatCast(value.SliceUint8(), baseType, profileType)
		case proto.TypeSliceInt16:
			valstr = formatCast(value.SliceInt16(), baseType, profileType)
		case proto.TypeSliceUint16:
			valstr = formatCast(value.SliceUint16(), baseType, profileType)
		case proto.TypeSliceInt32:
			valstr = formatCast(value.SliceInt32(), baseType, profileType)
		case proto.TypeSliceUint32:
			valstr = formatCast(value.SliceUint32(), baseType, profileType)
		case proto.TypeSliceInt64:
			valstr = formatCast(value.SliceInt64(), baseType, profileType)
		case proto.TypeSliceUint64:
			valstr = formatCast(value.SliceUint64(), baseType, profileType)
		case proto.TypeSliceFloat32:
			valstr = formatCast(value.SliceFloat32(), baseType, profileType)
		case proto.TypeSliceFloat64:
			valstr = formatCast(value.SliceFloat64(), baseType, profileType)
		}
		return valstr
	}

	if isDynamicField { // Cast value as dynamic field's target type
		value = castValue(value, baseType)
	}
	ts := TypedefString(profileType, value)
	if strings.Contains(ts, "Invalid") {
		valstr = fmt.Sprintf("%s <unknown(%s)>", valstr, valstr)
	} else if ts != "" {
		valstr = fmt.Sprintf("%s <%s>", valstr, ts)
	}

	return valstr

}

func formatCast[S []E, E any](s S, bt basetype.BaseType, pt profile.ProfileType) string {
	ss := make([]string, 0, len(s))
	for i := range s {
		val := castValue(proto.Any(s[i]), bt)
		ts := TypedefString(pt, val)
		if strings.Contains(ts, "Invalid") {
			ss = append(ss, fmt.Sprintf("unknown(%v)", val.Any()))
		} else if ts != "" {
			ss = append(ss, ts)
		}
	}
	if len(ss) == 0 {
		return fmt.Sprintf("%v", s)
	}
	return fmt.Sprintf("%v <%v>", s, ss)
}

func formatDeveloperFieldValue(value proto.Value, units string) string {
	return fmt.Sprintf("%v %s", value.Any(), units)
}

// castValue cast any integer value into targeted baseType.
// If it's not supported original value will be returned.
func castValue(val proto.Value, baseType basetype.BaseType) proto.Value {
	var value uint64
	switch val.Type() {
	case proto.TypeInt8:
		value = uint64(val.Int8())
	case proto.TypeUint8:
		value = uint64(val.Uint8())
	case proto.TypeInt16:
		value = uint64(val.Int16())
	case proto.TypeUint16:
		value = uint64(val.Uint16())
	case proto.TypeInt32:
		value = uint64(val.Int32())
	case proto.TypeUint32:
		value = uint64(val.Uint32())
	case proto.TypeInt64:
		value = uint64(val.Int64())
	case proto.TypeUint64:
		value = uint64(val.Uint64())
	}

	switch baseType {
	case basetype.Sint8:
		return proto.Int8(int8(value))
	case basetype.Enum, basetype.Uint8, basetype.Uint8z:
		return proto.Uint8(uint8(value))
	case basetype.Sint16:
		return proto.Int16(int16(value))
	case basetype.Uint16, basetype.Uint16z:
		return proto.Uint16(uint16(value))
	case basetype.Sint32:
		return proto.Int32(int32(value))
	case basetype.Uint32, basetype.Uint32z:
		return proto.Uint32(uint32(value))
	case basetype.Sint64:
		return proto.Int64(int64(value))
	case basetype.Uint64, basetype.Uint64z:
		return proto.Uint64(uint64(value))
	}

	return val
}
