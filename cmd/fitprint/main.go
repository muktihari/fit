// Copyright 2023 The FIT SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"github.com/muktihari/fit/decoder"
	"github.com/muktihari/fit/factory"
	"github.com/muktihari/fit/kit/datetime"
	"github.com/muktihari/fit/kit/scaleoffset"
	"github.com/muktihari/fit/kit/semicircles"
	"github.com/muktihari/fit/profile"
	"github.com/muktihari/fit/profile/typedef"
	"github.com/muktihari/fit/profile/untyped/fieldnum"
	"github.com/muktihari/fit/profile/untyped/mesgnum"
	"github.com/muktihari/fit/proto"
)

const fitprintGithubURL = "https://github.com/muktihari/fit/tree/master/cmd/fitprint"

func main() {
	if len(os.Args) < 2 {
		fmt.Fprintf(os.Stderr, "missing arguments\n")
		os.Exit(2)
	}
	for i, arg := range os.Args[1:] {
		if err := print(arg); err != nil {
			fmt.Printf("could not dump args[%d] %q: %v\n", i, arg, err)
		}
	}
}

func print(path string) error {
	ext := filepath.Ext(path)
	if strings.ToLower(ext) != ".fit" {
		return fmt.Errorf("expected ext: *.fit, got: %s", ext)
	}

	f, err := os.Open(path)
	if err != nil {
		return fmt.Errorf("could not open file %s: %w", path, err)
	}
	defer f.Close()

	abspath, err := filepath.Abs(path)
	if err != nil {
		abspath = path
	}
	base := filepath.Base(path)
	dir := filepath.Dir(path)

	name := base
	if len(ext) < len(base) {
		name = base[:len(base)-len(ext)]
	}
	name = name + ".txt"

	resultPath := filepath.Join(dir, name)
	out, err := os.OpenFile(resultPath, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
	if err != nil {
		return err
	}
	defer out.Close()

	bw := bufio.NewWriter(out)
	defer bw.Flush()

	dec := decoder.New(f, decoder.WithIgnoreChecksum())

	fmt.Fprintf(bw, "File generated by %s\nFilepath: %q", fitprintGithubURL, abspath)

	for dec.Next() {
		fit, err := dec.Decode()
		if err != nil {
			return fmt.Errorf("could not decode: %w", err)
		}

		fmt.Fprintf(bw, `
		
File Header:
  - Size: %d
  - Protocol Version: %s (%d)
  - Profile Version: %d
  - DataSize: %d
  - DataType: %q
  - CRC: %d

File CRC: %d

`,
			fit.FileHeader.Size,
			fmt.Sprintf("%d.%d",
				proto.VersionMajor(fit.FileHeader.ProtocolVersion),
				proto.VersionMinor(fit.FileHeader.ProtocolVersion)),
			fit.FileHeader.ProtocolVersion,
			fit.FileHeader.ProfileVersion,
			fit.FileHeader.DataSize,
			fit.FileHeader.DataType,
			fit.FileHeader.CRC,
			fit.CRC,
		)

		for i := range fit.Messages {
			printMesg(bw, i, &fit.Messages[i])
		}
	}

	fmt.Printf("ðŸ“„ %q -> %q\n", filepath.Join(dir, path), filepath.Join(dir, name))

	return nil
}

func printMesg(w io.Writer, index int, mesg *proto.Message) {
	numStr := mesg.Num.String()
	if strings.HasPrefix(numStr, "MesgNumInvalid") {
		numStr = factory.NameUnknown
	}

	fmt.Fprintf(w, "%s (num: %d, fields [-]: %d, developer fields [+]: %d) [%d]:\n",
		numStr, mesg.Num, len(mesg.Fields), len(mesg.DeveloperFields), index)

	for j := range mesg.Fields {
		field := &mesg.Fields[j]

		value := formatFieldValue(field, mesg)
		if field.Units == "semicircles" {
			value = fmt.Sprintf("%s (%g degrees)", value, semicircles.ToDegrees(field.Value.Int32()))
		}

		if mesg.Num == mesgnum.FileId { // Special Case
			switch field.Num {
			case fieldnum.FileIdManufacturer:
				value = fmt.Sprintf("%s <%s>", value, typedef.Manufacturer(field.Value.Uint16()))
			case fieldnum.FileIdProduct:
				if mesg.FieldValueByNum(fieldnum.FileIdManufacturer).Uint16() == 1 {
					value = fmt.Sprintf("%s <%s>", value, typedef.GarminProduct(field.Value.Uint16()))
				}
			case fieldnum.FileIdType:
				value = fmt.Sprintf("%s <%s>", value, typedef.File(field.Value.Uint8()))
			}
		}

		if !field.Value.Valid(field.BaseType) {
			value = fmt.Sprintf("%s (INVALID)", value)
		}
		typ := field.BaseType.String()
		if field.BaseType.String() != field.Type.String() {
			typ = fmt.Sprintf("%s | %s", typ, field.Type)
		}

		name := field.Name
		isDynamicField := false
		if subField := field.SubFieldSubtitution(mesg); subField != nil {
			name = subField.Name
			isDynamicField = true
		}

		if isDynamicField {
			value = fmt.Sprintf("%s <Dynamic Field -> Parent: %q>", value, field.Name)
		}

		array := ""
		if field.Array {
			array = " array"
		}

		fmt.Fprintf(w, "  - %s (num: %d, type: %s%s): %v\n",
			name,
			field.Num,
			typ,
			array,
			value,
		)
	}

	for i := range mesg.DeveloperFields {
		fmt.Fprintf(w, "  + %s (num: %d, type: %s): %v\n",
			mesg.DeveloperFields[i].Name,
			mesg.DeveloperFields[i].Num,
			mesg.DeveloperFields[i].BaseType,
			formatDeveloperFieldValue(&mesg.DeveloperFields[i]))
	}
}

func formatFieldValue(field *proto.Field, mesgRef *proto.Message) string {
	var (
		scale  = field.Scale
		offset = field.Offset
		units  = field.Units
	)

	if subField := field.SubFieldSubtitution(mesgRef); subField != nil {
		scale = subField.Scale
		offset = subField.Offset
		units = subField.Units
	}

	if field.Type == profile.DateTime {
		return fmt.Sprintf("%s (%d)", datetime.ToTime(field.Value), field.Value.Uint32())
	}

	if field.Scale == 1 && field.Offset == 0 {
		switch field.Value.Type() {
		case proto.TypeString:
			return strings.TrimSpace(fmt.Sprintf("%q %s", field.Value.String(), units))
		case proto.TypeSliceString:
			strbldr := new(strings.Builder)
			strbldr.WriteString("[")
			vals := field.Value.SliceString()
			for i := range vals {
				strbldr.WriteString(fmt.Sprintf("%q", vals[i]))
				if i != len(vals)-1 {
					strbldr.WriteString(", ")
				}
			}
			strbldr.WriteString("]")
			return strings.TrimSpace(fmt.Sprintf("%v %s", strbldr.String(), units))
		default:
			return strings.TrimSpace(fmt.Sprintf("%v %s", field.Value.Any(), units))
		}
	}
	return fmt.Sprintf("%v %s ((%v / %g) - %g)",
		scaleoffset.ApplyValue(field.Value, field.Scale, field.Offset).Any(),
		units,
		field.Value.Any(),
		scale,
		offset,
	)
}

func formatDeveloperFieldValue(developerField *proto.DeveloperField) string {
	return fmt.Sprintf("%v %s", developerField.Value.Any(), developerField.Units)
}
