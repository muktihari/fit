// Code generated by internal/cmd/fitgen/main.go. DO NOT EDIT.
// SDK Version: 21.126

// Copyright 2023 The Fit SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package mesgdef

import (
	"github.com/muktihari/fit/kit/datetime"
	"github.com/muktihari/fit/kit/typeconv"
	"github.com/muktihari/fit/profile/basetype"
	"github.com/muktihari/fit/profile/typedef"
	"github.com/muktihari/fit/proto"
	"time"
)

// BarometerData is a BarometerData message.
type BarometerData struct {
	Timestamp        time.Time // Units: s; Whole second part of the timestamp
	TimestampMs      uint16    // Units: ms; Millisecond part of the timestamp.
	SampleTimeOffset []uint16  // Array: [N]; Units: ms; Each time in the array describes the time at which the barometer sample with the corrosponding index was taken. The samples may span across seconds. Array size must match the number of samples in baro_cal
	BaroPres         []uint32  // Array: [N]; Units: Pa; These are the raw ADC reading. The samples may span across seconds. A conversion will need to be done on this data once read.

	// Developer Fields are dynamic, can't be mapped as struct's fields.
	// [Added since protocol version 2.0]
	DeveloperFields []proto.DeveloperField
}

// NewBarometerData creates new BarometerData struct based on given mesg.
// If mesg is nil, it will return BarometerData with all fields being set to its corresponding invalid value.
func NewBarometerData(mesg *proto.Message) *BarometerData {
	vals := [254]any{}

	var developerFields []proto.DeveloperField
	if mesg != nil {
		for i := range mesg.Fields {
			if mesg.Fields[i].Num >= byte(len(vals)) {
				continue
			}
			vals[mesg.Fields[i].Num] = mesg.Fields[i].Value
		}
		developerFields = mesg.DeveloperFields
	}

	return &BarometerData{
		Timestamp:        datetime.ToTime(vals[253]),
		TimestampMs:      typeconv.ToUint16[uint16](vals[0]),
		SampleTimeOffset: typeconv.ToSliceUint16[uint16](vals[1]),
		BaroPres:         typeconv.ToSliceUint32[uint32](vals[2]),

		DeveloperFields: developerFields,
	}
}

// ToMesg converts BarometerData into proto.Message.
func (m *BarometerData) ToMesg(fac Factory) proto.Message {
	mesg := fac.CreateMesgOnly(typedef.MesgNumBarometerData)
	mesg.Fields = make([]proto.Field, 0, m.size())

	if datetime.ToUint32(m.Timestamp) != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 253)
		field.Value = datetime.ToUint32(m.Timestamp)
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TimestampMs != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 0)
		field.Value = m.TimestampMs
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.SampleTimeOffset != nil {
		field := fac.CreateField(mesg.Num, 1)
		field.Value = m.SampleTimeOffset
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.BaroPres != nil {
		field := fac.CreateField(mesg.Num, 2)
		field.Value = m.BaroPres
		mesg.Fields = append(mesg.Fields, field)
	}

	mesg.DeveloperFields = m.DeveloperFields

	return mesg
}

// size returns size of BarometerData's valid fields.
func (m *BarometerData) size() byte {
	var size byte
	if datetime.ToUint32(m.Timestamp) != basetype.Uint32Invalid {
		size++
	}
	if m.TimestampMs != basetype.Uint16Invalid {
		size++
	}
	if m.SampleTimeOffset != nil {
		size++
	}
	if m.BaroPres != nil {
		size++
	}
	return size
}

// SetTimestamp sets BarometerData value.
//
// Units: s; Whole second part of the timestamp
func (m *BarometerData) SetTimestamp(v time.Time) *BarometerData {
	m.Timestamp = v
	return m
}

// SetTimestampMs sets BarometerData value.
//
// Units: ms; Millisecond part of the timestamp.
func (m *BarometerData) SetTimestampMs(v uint16) *BarometerData {
	m.TimestampMs = v
	return m
}

// SetSampleTimeOffset sets BarometerData value.
//
// Array: [N]; Units: ms; Each time in the array describes the time at which the barometer sample with the corrosponding index was taken. The samples may span across seconds. Array size must match the number of samples in baro_cal
func (m *BarometerData) SetSampleTimeOffset(v []uint16) *BarometerData {
	m.SampleTimeOffset = v
	return m
}

// SetBaroPres sets BarometerData value.
//
// Array: [N]; Units: Pa; These are the raw ADC reading. The samples may span across seconds. A conversion will need to be done on this data once read.
func (m *BarometerData) SetBaroPres(v []uint32) *BarometerData {
	m.BaroPres = v
	return m
}

// SetDeveloperFields BarometerData's DeveloperFields.
func (m *BarometerData) SetDeveloperFields(developerFields ...proto.DeveloperField) *BarometerData {
	m.DeveloperFields = developerFields
	return m
}
