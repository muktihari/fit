// Code generated by internal/cmd/fitgen/main.go. DO NOT EDIT.
// SDK Version: 21.126

// Copyright 2023 The Fit SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package mesgdef

import (
	"github.com/muktihari/fit/kit/typeconv"
	"github.com/muktihari/fit/profile/basetype"
	"github.com/muktihari/fit/profile/typedef"
	"github.com/muktihari/fit/proto"
)

// AccelerometerData is a AccelerometerData message.
type AccelerometerData struct {
	Timestamp                  typedef.DateTime // Units: s; Whole second part of the timestamp
	TimestampMs                uint16           // Units: ms; Millisecond part of the timestamp.
	SampleTimeOffset           []uint16         // Array: [N]; Units: ms; Each time in the array describes the time at which the accelerometer sample with the corrosponding index was taken. Limited to 30 samples in each message. The samples may span across seconds. Array size must match the number of samples in accel_x and accel_y and accel_z
	AccelX                     []uint16         // Array: [N]; Units: counts; These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
	AccelY                     []uint16         // Array: [N]; Units: counts; These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
	AccelZ                     []uint16         // Array: [N]; Units: counts; These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
	CalibratedAccelX           []float32        // Array: [N]; Units: g; Calibrated accel reading
	CalibratedAccelY           []float32        // Array: [N]; Units: g; Calibrated accel reading
	CalibratedAccelZ           []float32        // Array: [N]; Units: g; Calibrated accel reading
	CompressedCalibratedAccelX []int16          // Array: [N]; Units: mG; Calibrated accel reading
	CompressedCalibratedAccelY []int16          // Array: [N]; Units: mG; Calibrated accel reading
	CompressedCalibratedAccelZ []int16          // Array: [N]; Units: mG; Calibrated accel reading

	// Developer Fields are dynamic, can't be mapped as struct's fields.
	// [Added since protocol version 2.0]
	DeveloperFields []proto.DeveloperField
}

// NewAccelerometerData creates new AccelerometerData struct based on given mesg. If mesg is nil or mesg.Num is not equal to AccelerometerData mesg number, it will return nil.
func NewAccelerometerData(mesg proto.Message) *AccelerometerData {
	if mesg.Num != typedef.MesgNumAccelerometerData {
		return nil
	}

	vals := [254]any{}
	for i := range mesg.Fields {
		field := &mesg.Fields[i]
		if field.Num >= byte(len(vals)) {
			continue
		}
		vals[field.Num] = field.Value
	}

	return &AccelerometerData{
		Timestamp:                  typeconv.ToUint32[typedef.DateTime](vals[253]),
		TimestampMs:                typeconv.ToUint16[uint16](vals[0]),
		SampleTimeOffset:           typeconv.ToSliceUint16[uint16](vals[1]),
		AccelX:                     typeconv.ToSliceUint16[uint16](vals[2]),
		AccelY:                     typeconv.ToSliceUint16[uint16](vals[3]),
		AccelZ:                     typeconv.ToSliceUint16[uint16](vals[4]),
		CalibratedAccelX:           typeconv.ToSliceFloat32[float32](vals[5]),
		CalibratedAccelY:           typeconv.ToSliceFloat32[float32](vals[6]),
		CalibratedAccelZ:           typeconv.ToSliceFloat32[float32](vals[7]),
		CompressedCalibratedAccelX: typeconv.ToSliceSint16[int16](vals[8]),
		CompressedCalibratedAccelY: typeconv.ToSliceSint16[int16](vals[9]),
		CompressedCalibratedAccelZ: typeconv.ToSliceSint16[int16](vals[10]),

		DeveloperFields: mesg.DeveloperFields,
	}
}

// ToMesg converts AccelerometerData into proto.Message.
func (m *AccelerometerData) ToMesg(fac Factory) proto.Message {
	mesg := fac.CreateMesgOnly(typedef.MesgNumAccelerometerData)
	mesg.Fields = make([]proto.Field, 0, m.size())

	if typeconv.ToUint32[uint32](m.Timestamp) != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 253)
		field.Value = typeconv.ToUint32[uint32](m.Timestamp)
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TimestampMs != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 0)
		field.Value = m.TimestampMs
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.SampleTimeOffset != nil {
		field := fac.CreateField(mesg.Num, 1)
		field.Value = m.SampleTimeOffset
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AccelX != nil {
		field := fac.CreateField(mesg.Num, 2)
		field.Value = m.AccelX
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AccelY != nil {
		field := fac.CreateField(mesg.Num, 3)
		field.Value = m.AccelY
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AccelZ != nil {
		field := fac.CreateField(mesg.Num, 4)
		field.Value = m.AccelZ
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.CalibratedAccelX != nil {
		field := fac.CreateField(mesg.Num, 5)
		field.Value = m.CalibratedAccelX
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.CalibratedAccelY != nil {
		field := fac.CreateField(mesg.Num, 6)
		field.Value = m.CalibratedAccelY
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.CalibratedAccelZ != nil {
		field := fac.CreateField(mesg.Num, 7)
		field.Value = m.CalibratedAccelZ
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.CompressedCalibratedAccelX != nil {
		field := fac.CreateField(mesg.Num, 8)
		field.Value = m.CompressedCalibratedAccelX
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.CompressedCalibratedAccelY != nil {
		field := fac.CreateField(mesg.Num, 9)
		field.Value = m.CompressedCalibratedAccelY
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.CompressedCalibratedAccelZ != nil {
		field := fac.CreateField(mesg.Num, 10)
		field.Value = m.CompressedCalibratedAccelZ
		mesg.Fields = append(mesg.Fields, field)
	}

	mesg.DeveloperFields = m.DeveloperFields

	return mesg
}

// size returns size of AccelerometerData's valid fields.
func (m *AccelerometerData) size() byte {
	var size byte
	if typeconv.ToUint32[uint32](m.Timestamp) != basetype.Uint32Invalid {
		size++
	}
	if m.TimestampMs != basetype.Uint16Invalid {
		size++
	}
	if m.SampleTimeOffset != nil {
		size++
	}
	if m.AccelX != nil {
		size++
	}
	if m.AccelY != nil {
		size++
	}
	if m.AccelZ != nil {
		size++
	}
	if m.CalibratedAccelX != nil {
		size++
	}
	if m.CalibratedAccelY != nil {
		size++
	}
	if m.CalibratedAccelZ != nil {
		size++
	}
	if m.CompressedCalibratedAccelX != nil {
		size++
	}
	if m.CompressedCalibratedAccelY != nil {
		size++
	}
	if m.CompressedCalibratedAccelZ != nil {
		size++
	}
	return size
}
