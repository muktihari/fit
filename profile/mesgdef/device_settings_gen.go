// Code generated by internal/cmd/fitgen/main.go. DO NOT EDIT.
// SDK Version: 21.126

// Copyright 2023 The Fit SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package mesgdef

import (
	"github.com/muktihari/fit/kit/typeconv"
	"github.com/muktihari/fit/profile/basetype"
	"github.com/muktihari/fit/profile/typedef"
	"github.com/muktihari/fit/proto"
)

// DeviceSettings is a DeviceSettings message.
type DeviceSettings struct {
	ActiveTimeZone                      uint8                 // Index into time zone arrays.
	UtcOffset                           uint32                // Offset from system time. Required to convert timestamp from system time to UTC.
	TimeOffset                          []uint32              // Array: [N]; Units: s; Offset from system time.
	TimeMode                            []typedef.TimeMode    // Array: [N]; Display mode for the time
	TimeZoneOffset                      []int8                // Scale: 4; Array: [N]; Units: hr; timezone offset in 1/4 hour increments
	BacklightMode                       typedef.BacklightMode // Mode for backlight
	ActivityTrackerEnabled              bool                  // Enabled state of the activity tracker functionality
	ClockTime                           typedef.DateTime      // UTC timestamp used to set the devices clock and date
	PagesEnabled                        []uint16              // Array: [N]; Bitfield to configure enabled screens for each supported loop
	MoveAlertEnabled                    bool                  // Enabled state of the move alert
	DateMode                            typedef.DateMode      // Display mode for the date
	DisplayOrientation                  typedef.DisplayOrientation
	MountingSide                        typedef.Side
	DefaultPage                         []uint16                   // Array: [N]; Bitfield to indicate one page as default for each supported loop
	AutosyncMinSteps                    uint16                     // Units: steps; Minimum steps before an autosync can occur
	AutosyncMinTime                     uint16                     // Units: minutes; Minimum minutes before an autosync can occur
	LactateThresholdAutodetectEnabled   bool                       // Enable auto-detect setting for the lactate threshold feature.
	BleAutoUploadEnabled                bool                       // Automatically upload using BLE
	AutoSyncFrequency                   typedef.AutoSyncFrequency  // Helps to conserve battery by changing modes
	AutoActivityDetect                  typedef.AutoActivityDetect // Allows setting specific activities auto-activity detect enabled/disabled settings
	NumberOfScreens                     uint8                      // Number of screens configured to display
	SmartNotificationDisplayOrientation typedef.DisplayOrientation // Smart Notification display orientation
	TapInterface                        typedef.Switch
	TapSensitivity                      typedef.TapSensitivity // Used to hold the tap threshold setting

	// Developer Fields are dynamic, can't be mapped as struct's fields.
	// [Added since protocol version 2.0]
	DeveloperFields []proto.DeveloperField
}

// NewDeviceSettings creates new DeviceSettings struct based on given mesg. If mesg is nil or mesg.Num is not equal to DeviceSettings mesg number, it will return nil.
func NewDeviceSettings(mesg proto.Message) *DeviceSettings {
	if mesg.Num != typedef.MesgNumDeviceSettings {
		return nil
	}

	vals := [175]any{}
	for i := range mesg.Fields {
		field := &mesg.Fields[i]
		if field.Num >= byte(len(vals)) {
			continue
		}
		vals[field.Num] = field.Value
	}

	return &DeviceSettings{
		ActiveTimeZone:                      typeconv.ToUint8[uint8](vals[0]),
		UtcOffset:                           typeconv.ToUint32[uint32](vals[1]),
		TimeOffset:                          typeconv.ToSliceUint32[uint32](vals[2]),
		TimeMode:                            typeconv.ToSliceEnum[typedef.TimeMode](vals[4]),
		TimeZoneOffset:                      typeconv.ToSliceSint8[int8](vals[5]),
		BacklightMode:                       typeconv.ToEnum[typedef.BacklightMode](vals[12]),
		ActivityTrackerEnabled:              typeconv.ToBool[bool](vals[36]),
		ClockTime:                           typeconv.ToUint32[typedef.DateTime](vals[39]),
		PagesEnabled:                        typeconv.ToSliceUint16[uint16](vals[40]),
		MoveAlertEnabled:                    typeconv.ToBool[bool](vals[46]),
		DateMode:                            typeconv.ToEnum[typedef.DateMode](vals[47]),
		DisplayOrientation:                  typeconv.ToEnum[typedef.DisplayOrientation](vals[55]),
		MountingSide:                        typeconv.ToEnum[typedef.Side](vals[56]),
		DefaultPage:                         typeconv.ToSliceUint16[uint16](vals[57]),
		AutosyncMinSteps:                    typeconv.ToUint16[uint16](vals[58]),
		AutosyncMinTime:                     typeconv.ToUint16[uint16](vals[59]),
		LactateThresholdAutodetectEnabled:   typeconv.ToBool[bool](vals[80]),
		BleAutoUploadEnabled:                typeconv.ToBool[bool](vals[86]),
		AutoSyncFrequency:                   typeconv.ToEnum[typedef.AutoSyncFrequency](vals[89]),
		AutoActivityDetect:                  typeconv.ToUint32[typedef.AutoActivityDetect](vals[90]),
		NumberOfScreens:                     typeconv.ToUint8[uint8](vals[94]),
		SmartNotificationDisplayOrientation: typeconv.ToEnum[typedef.DisplayOrientation](vals[95]),
		TapInterface:                        typeconv.ToEnum[typedef.Switch](vals[134]),
		TapSensitivity:                      typeconv.ToEnum[typedef.TapSensitivity](vals[174]),

		DeveloperFields: mesg.DeveloperFields,
	}
}

// ToMesg converts DeviceSettings into proto.Message.
func (m *DeviceSettings) ToMesg(fac Factory) proto.Message {
	mesg := fac.CreateMesgOnly(typedef.MesgNumDeviceSettings)
	mesg.Fields = make([]proto.Field, 0, m.size())

	if m.ActiveTimeZone != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 0)
		field.Value = m.ActiveTimeZone
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.UtcOffset != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 1)
		field.Value = m.UtcOffset
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TimeOffset != nil {
		field := fac.CreateField(mesg.Num, 2)
		field.Value = m.TimeOffset
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToSliceEnum[byte](m.TimeMode) != nil {
		field := fac.CreateField(mesg.Num, 4)
		field.Value = typeconv.ToSliceEnum[byte](m.TimeMode)
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TimeZoneOffset != nil {
		field := fac.CreateField(mesg.Num, 5)
		field.Value = m.TimeZoneOffset
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToEnum[byte](m.BacklightMode) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 12)
		field.Value = typeconv.ToEnum[byte](m.BacklightMode)
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.ActivityTrackerEnabled != false {
		field := fac.CreateField(mesg.Num, 36)
		field.Value = m.ActivityTrackerEnabled
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToUint32[uint32](m.ClockTime) != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 39)
		field.Value = typeconv.ToUint32[uint32](m.ClockTime)
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.PagesEnabled != nil {
		field := fac.CreateField(mesg.Num, 40)
		field.Value = m.PagesEnabled
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MoveAlertEnabled != false {
		field := fac.CreateField(mesg.Num, 46)
		field.Value = m.MoveAlertEnabled
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToEnum[byte](m.DateMode) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 47)
		field.Value = typeconv.ToEnum[byte](m.DateMode)
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToEnum[byte](m.DisplayOrientation) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 55)
		field.Value = typeconv.ToEnum[byte](m.DisplayOrientation)
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToEnum[byte](m.MountingSide) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 56)
		field.Value = typeconv.ToEnum[byte](m.MountingSide)
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.DefaultPage != nil {
		field := fac.CreateField(mesg.Num, 57)
		field.Value = m.DefaultPage
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AutosyncMinSteps != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 58)
		field.Value = m.AutosyncMinSteps
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AutosyncMinTime != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 59)
		field.Value = m.AutosyncMinTime
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.LactateThresholdAutodetectEnabled != false {
		field := fac.CreateField(mesg.Num, 80)
		field.Value = m.LactateThresholdAutodetectEnabled
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.BleAutoUploadEnabled != false {
		field := fac.CreateField(mesg.Num, 86)
		field.Value = m.BleAutoUploadEnabled
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToEnum[byte](m.AutoSyncFrequency) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 89)
		field.Value = typeconv.ToEnum[byte](m.AutoSyncFrequency)
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToUint32[uint32](m.AutoActivityDetect) != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 90)
		field.Value = typeconv.ToUint32[uint32](m.AutoActivityDetect)
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.NumberOfScreens != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 94)
		field.Value = m.NumberOfScreens
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToEnum[byte](m.SmartNotificationDisplayOrientation) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 95)
		field.Value = typeconv.ToEnum[byte](m.SmartNotificationDisplayOrientation)
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToEnum[byte](m.TapInterface) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 134)
		field.Value = typeconv.ToEnum[byte](m.TapInterface)
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToEnum[byte](m.TapSensitivity) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 174)
		field.Value = typeconv.ToEnum[byte](m.TapSensitivity)
		mesg.Fields = append(mesg.Fields, field)
	}

	mesg.DeveloperFields = m.DeveloperFields

	return mesg
}

// size returns size of DeviceSettings's valid fields.
func (m *DeviceSettings) size() byte {
	var size byte
	if m.ActiveTimeZone != basetype.Uint8Invalid {
		size++
	}
	if m.UtcOffset != basetype.Uint32Invalid {
		size++
	}
	if m.TimeOffset != nil {
		size++
	}
	if typeconv.ToSliceEnum[byte](m.TimeMode) != nil {
		size++
	}
	if m.TimeZoneOffset != nil {
		size++
	}
	if typeconv.ToEnum[byte](m.BacklightMode) != basetype.EnumInvalid {
		size++
	}
	if m.ActivityTrackerEnabled != false {
		size++
	}
	if typeconv.ToUint32[uint32](m.ClockTime) != basetype.Uint32Invalid {
		size++
	}
	if m.PagesEnabled != nil {
		size++
	}
	if m.MoveAlertEnabled != false {
		size++
	}
	if typeconv.ToEnum[byte](m.DateMode) != basetype.EnumInvalid {
		size++
	}
	if typeconv.ToEnum[byte](m.DisplayOrientation) != basetype.EnumInvalid {
		size++
	}
	if typeconv.ToEnum[byte](m.MountingSide) != basetype.EnumInvalid {
		size++
	}
	if m.DefaultPage != nil {
		size++
	}
	if m.AutosyncMinSteps != basetype.Uint16Invalid {
		size++
	}
	if m.AutosyncMinTime != basetype.Uint16Invalid {
		size++
	}
	if m.LactateThresholdAutodetectEnabled != false {
		size++
	}
	if m.BleAutoUploadEnabled != false {
		size++
	}
	if typeconv.ToEnum[byte](m.AutoSyncFrequency) != basetype.EnumInvalid {
		size++
	}
	if typeconv.ToUint32[uint32](m.AutoActivityDetect) != basetype.Uint32Invalid {
		size++
	}
	if m.NumberOfScreens != basetype.Uint8Invalid {
		size++
	}
	if typeconv.ToEnum[byte](m.SmartNotificationDisplayOrientation) != basetype.EnumInvalid {
		size++
	}
	if typeconv.ToEnum[byte](m.TapInterface) != basetype.EnumInvalid {
		size++
	}
	if typeconv.ToEnum[byte](m.TapSensitivity) != basetype.EnumInvalid {
		size++
	}
	return size
}
