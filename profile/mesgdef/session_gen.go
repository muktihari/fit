// Code generated by internal/cmd/fitgen/main.go. DO NOT EDIT.
// SDK Version: 21.126

// Copyright 2023 The Fit SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package mesgdef

import (
	"github.com/muktihari/fit/kit/datetime"
	"github.com/muktihari/fit/kit/typeconv"
	"github.com/muktihari/fit/profile/basetype"
	"github.com/muktihari/fit/profile/typedef"
	"github.com/muktihari/fit/proto"
	"time"
)

// Session is a Session message.
type Session struct {
	MessageIndex                  typedef.MessageIndex // Selected bit is set for the current session.
	Timestamp                     time.Time            // Units: s; Sesson end time.
	Event                         typedef.Event        // session
	EventType                     typedef.EventType    // stop
	StartTime                     time.Time
	StartPositionLat              int32 // Units: semicircles;
	StartPositionLong             int32 // Units: semicircles;
	Sport                         typedef.Sport
	SubSport                      typedef.SubSport
	TotalElapsedTime              uint32 // Scale: 1000; Units: s; Time (includes pauses)
	TotalTimerTime                uint32 // Scale: 1000; Units: s; Timer Time (excludes pauses)
	TotalDistance                 uint32 // Scale: 100; Units: m;
	TotalCycles                   uint32 // Units: cycles;
	TotalCalories                 uint16 // Units: kcal;
	TotalFatCalories              uint16 // Units: kcal;
	AvgSpeed                      uint16 // Scale: 1000; Units: m/s; total_distance / total_timer_time
	MaxSpeed                      uint16 // Scale: 1000; Units: m/s;
	AvgHeartRate                  uint8  // Units: bpm; average heart rate (excludes pause time)
	MaxHeartRate                  uint8  // Units: bpm;
	AvgCadence                    uint8  // Units: rpm; total_cycles / total_timer_time if non_zero_avg_cadence otherwise total_cycles / total_elapsed_time
	MaxCadence                    uint8  // Units: rpm;
	AvgPower                      uint16 // Units: watts; total_power / total_timer_time if non_zero_avg_power otherwise total_power / total_elapsed_time
	MaxPower                      uint16 // Units: watts;
	TotalAscent                   uint16 // Units: m;
	TotalDescent                  uint16 // Units: m;
	TotalTrainingEffect           uint8  // Scale: 10;
	FirstLapIndex                 uint16
	NumLaps                       uint16
	EventGroup                    uint8
	Trigger                       typedef.SessionTrigger
	NecLat                        int32  // Units: semicircles; North east corner latitude
	NecLong                       int32  // Units: semicircles; North east corner longitude
	SwcLat                        int32  // Units: semicircles; South west corner latitude
	SwcLong                       int32  // Units: semicircles; South west corner longitude
	NumLengths                    uint16 // Units: lengths; # of lengths of swim pool
	NormalizedPower               uint16 // Units: watts;
	TrainingStressScore           uint16 // Scale: 10; Units: tss;
	IntensityFactor               uint16 // Scale: 1000; Units: if;
	LeftRightBalance              typedef.LeftRightBalance100
	EndPositionLat                int32              // Units: semicircles;
	EndPositionLong               int32              // Units: semicircles;
	AvgStrokeCount                uint32             // Scale: 10; Units: strokes/lap;
	AvgStrokeDistance             uint16             // Scale: 100; Units: m;
	SwimStroke                    typedef.SwimStroke // Units: swim_stroke;
	PoolLength                    uint16             // Scale: 100; Units: m;
	ThresholdPower                uint16             // Units: watts;
	PoolLengthUnit                typedef.DisplayMeasure
	NumActiveLengths              uint16   // Units: lengths; # of active lengths of swim pool
	TotalWork                     uint32   // Units: J;
	AvgAltitude                   uint16   // Scale: 5; Offset: 500; Units: m;
	MaxAltitude                   uint16   // Scale: 5; Offset: 500; Units: m;
	GpsAccuracy                   uint8    // Units: m;
	AvgGrade                      int16    // Scale: 100; Units: %;
	AvgPosGrade                   int16    // Scale: 100; Units: %;
	AvgNegGrade                   int16    // Scale: 100; Units: %;
	MaxPosGrade                   int16    // Scale: 100; Units: %;
	MaxNegGrade                   int16    // Scale: 100; Units: %;
	AvgTemperature                int8     // Units: C;
	MaxTemperature                int8     // Units: C;
	TotalMovingTime               uint32   // Scale: 1000; Units: s;
	AvgPosVerticalSpeed           int16    // Scale: 1000; Units: m/s;
	AvgNegVerticalSpeed           int16    // Scale: 1000; Units: m/s;
	MaxPosVerticalSpeed           int16    // Scale: 1000; Units: m/s;
	MaxNegVerticalSpeed           int16    // Scale: 1000; Units: m/s;
	MinHeartRate                  uint8    // Units: bpm;
	TimeInHrZone                  []uint32 // Array: [N]; Scale: 1000; Units: s;
	TimeInSpeedZone               []uint32 // Array: [N]; Scale: 1000; Units: s;
	TimeInCadenceZone             []uint32 // Array: [N]; Scale: 1000; Units: s;
	TimeInPowerZone               []uint32 // Array: [N]; Scale: 1000; Units: s;
	AvgLapTime                    uint32   // Scale: 1000; Units: s;
	BestLapIndex                  uint16
	MinAltitude                   uint16 // Scale: 5; Offset: 500; Units: m;
	PlayerScore                   uint16
	OpponentScore                 uint16
	OpponentName                  string
	StrokeCount                   []uint16 // Array: [N]; Units: counts; stroke_type enum used as the index
	ZoneCount                     []uint16 // Array: [N]; Units: counts; zone number used as the index
	MaxBallSpeed                  uint16   // Scale: 100; Units: m/s;
	AvgBallSpeed                  uint16   // Scale: 100; Units: m/s;
	AvgVerticalOscillation        uint16   // Scale: 10; Units: mm;
	AvgStanceTimePercent          uint16   // Scale: 100; Units: percent;
	AvgStanceTime                 uint16   // Scale: 10; Units: ms;
	AvgFractionalCadence          uint8    // Scale: 128; Units: rpm; fractional part of the avg_cadence
	MaxFractionalCadence          uint8    // Scale: 128; Units: rpm; fractional part of the max_cadence
	TotalFractionalCycles         uint8    // Scale: 128; Units: cycles; fractional part of the total_cycles
	AvgTotalHemoglobinConc        []uint16 // Array: [N]; Scale: 100; Units: g/dL; Avg saturated and unsaturated hemoglobin
	MinTotalHemoglobinConc        []uint16 // Array: [N]; Scale: 100; Units: g/dL; Min saturated and unsaturated hemoglobin
	MaxTotalHemoglobinConc        []uint16 // Array: [N]; Scale: 100; Units: g/dL; Max saturated and unsaturated hemoglobin
	AvgSaturatedHemoglobinPercent []uint16 // Array: [N]; Scale: 10; Units: %; Avg percentage of hemoglobin saturated with oxygen
	MinSaturatedHemoglobinPercent []uint16 // Array: [N]; Scale: 10; Units: %; Min percentage of hemoglobin saturated with oxygen
	MaxSaturatedHemoglobinPercent []uint16 // Array: [N]; Scale: 10; Units: %; Max percentage of hemoglobin saturated with oxygen
	AvgLeftTorqueEffectiveness    uint8    // Scale: 2; Units: percent;
	AvgRightTorqueEffectiveness   uint8    // Scale: 2; Units: percent;
	AvgLeftPedalSmoothness        uint8    // Scale: 2; Units: percent;
	AvgRightPedalSmoothness       uint8    // Scale: 2; Units: percent;
	AvgCombinedPedalSmoothness    uint8    // Scale: 2; Units: percent;
	SportProfileName              string   // Sport name from associated sport mesg
	SportIndex                    uint8
	TimeStanding                  uint32   // Scale: 1000; Units: s; Total time spend in the standing position
	StandCount                    uint16   // Number of transitions to the standing state
	AvgLeftPco                    int8     // Units: mm; Average platform center offset Left
	AvgRightPco                   int8     // Units: mm; Average platform center offset Right
	AvgLeftPowerPhase             []uint8  // Array: [N]; Scale: 0.7111111; Units: degrees; Average left power phase angles. Indexes defined by power_phase_type.
	AvgLeftPowerPhasePeak         []uint8  // Array: [N]; Scale: 0.7111111; Units: degrees; Average left power phase peak angles. Data value indexes defined by power_phase_type.
	AvgRightPowerPhase            []uint8  // Array: [N]; Scale: 0.7111111; Units: degrees; Average right power phase angles. Data value indexes defined by power_phase_type.
	AvgRightPowerPhasePeak        []uint8  // Array: [N]; Scale: 0.7111111; Units: degrees; Average right power phase peak angles data value indexes defined by power_phase_type.
	AvgPowerPosition              []uint16 // Array: [N]; Units: watts; Average power by position. Data value indexes defined by rider_position_type.
	MaxPowerPosition              []uint16 // Array: [N]; Units: watts; Maximum power by position. Data value indexes defined by rider_position_type.
	AvgCadencePosition            []uint8  // Array: [N]; Units: rpm; Average cadence by position. Data value indexes defined by rider_position_type.
	MaxCadencePosition            []uint8  // Array: [N]; Units: rpm; Maximum cadence by position. Data value indexes defined by rider_position_type.
	EnhancedAvgSpeed              uint32   // Scale: 1000; Units: m/s; total_distance / total_timer_time
	EnhancedMaxSpeed              uint32   // Scale: 1000; Units: m/s;
	EnhancedAvgAltitude           uint32   // Scale: 5; Offset: 500; Units: m;
	EnhancedMinAltitude           uint32   // Scale: 5; Offset: 500; Units: m;
	EnhancedMaxAltitude           uint32   // Scale: 5; Offset: 500; Units: m;
	AvgLevMotorPower              uint16   // Units: watts; lev average motor power during session
	MaxLevMotorPower              uint16   // Units: watts; lev maximum motor power during session
	LevBatteryConsumption         uint8    // Scale: 2; Units: percent; lev battery consumption during session
	AvgVerticalRatio              uint16   // Scale: 100; Units: percent;
	AvgStanceTimeBalance          uint16   // Scale: 100; Units: percent;
	AvgStepLength                 uint16   // Scale: 10; Units: mm;
	TotalAnaerobicTrainingEffect  uint8    // Scale: 10;
	AvgVam                        uint16   // Scale: 1000; Units: m/s;
	AvgDepth                      uint32   // Scale: 1000; Units: m; 0 if above water
	MaxDepth                      uint32   // Scale: 1000; Units: m; 0 if above water
	SurfaceInterval               uint32   // Units: s; Time since end of last dive
	StartCns                      uint8    // Units: percent;
	EndCns                        uint8    // Units: percent;
	StartN2                       uint16   // Units: percent;
	EndN2                         uint16   // Units: percent;
	AvgRespirationRate            uint8
	MaxRespirationRate            uint8
	MinRespirationRate            uint8
	MinTemperature                int8   // Units: C;
	O2Toxicity                    uint16 // Units: OTUs;
	DiveNumber                    uint32
	TrainingLoadPeak              int32   // Scale: 65536;
	EnhancedAvgRespirationRate    uint16  // Scale: 100; Units: Breaths/min;
	EnhancedMaxRespirationRate    uint16  // Scale: 100; Units: Breaths/min;
	EnhancedMinRespirationRate    uint16  // Scale: 100;
	TotalGrit                     float32 // Units: kGrit; The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes.
	TotalFlow                     float32 // Units: Flow; The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals.
	JumpCount                     uint16
	AvgGrit                       float32 // Units: kGrit; The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes.
	AvgFlow                       float32 // Units: Flow; The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals.
	AvgSpo2                       uint8   // Units: percent; Average SPO2 for the monitoring session
	AvgStress                     uint8   // Units: percent; Average stress for the monitoring session
	SdrrHrv                       uint8   // Units: mS; Standard deviation of R-R interval (SDRR) - Heart rate variability measure most useful for wellness users.
	RmssdHrv                      uint8   // Units: mS; Root mean square successive difference (RMSSD) - Heart rate variability measure most useful for athletes
	TotalFractionalAscent         uint8   // Scale: 100; Units: m; fractional part of total_ascent
	TotalFractionalDescent        uint8   // Scale: 100; Units: m; fractional part of total_descent
	AvgCoreTemperature            uint16  // Scale: 100; Units: C;
	MinCoreTemperature            uint16  // Scale: 100; Units: C;
	MaxCoreTemperature            uint16  // Scale: 100; Units: C;

	// Developer Fields are dynamic, can't be mapped as struct's fields.
	// [Added since protocol version 2.0]
	DeveloperFields []proto.DeveloperField
}

// NewSession creates new Session struct based on given mesg.
// If mesg is nil, it will return Session with all fields being set to its corresponding invalid value.
func NewSession(mesg *proto.Message) *Session {
	vals := [255]any{}

	var developerFields []proto.DeveloperField
	if mesg != nil {
		for i := range mesg.Fields {
			if mesg.Fields[i].Num >= byte(len(vals)) {
				continue
			}
			vals[mesg.Fields[i].Num] = mesg.Fields[i].Value
		}
		developerFields = mesg.DeveloperFields
	}

	return &Session{
		MessageIndex:                  typeconv.ToUint16[typedef.MessageIndex](vals[254]),
		Timestamp:                     datetime.ToTime(vals[253]),
		Event:                         typeconv.ToEnum[typedef.Event](vals[0]),
		EventType:                     typeconv.ToEnum[typedef.EventType](vals[1]),
		StartTime:                     datetime.ToTime(vals[2]),
		StartPositionLat:              typeconv.ToSint32[int32](vals[3]),
		StartPositionLong:             typeconv.ToSint32[int32](vals[4]),
		Sport:                         typeconv.ToEnum[typedef.Sport](vals[5]),
		SubSport:                      typeconv.ToEnum[typedef.SubSport](vals[6]),
		TotalElapsedTime:              typeconv.ToUint32[uint32](vals[7]),
		TotalTimerTime:                typeconv.ToUint32[uint32](vals[8]),
		TotalDistance:                 typeconv.ToUint32[uint32](vals[9]),
		TotalCycles:                   typeconv.ToUint32[uint32](vals[10]),
		TotalCalories:                 typeconv.ToUint16[uint16](vals[11]),
		TotalFatCalories:              typeconv.ToUint16[uint16](vals[13]),
		AvgSpeed:                      typeconv.ToUint16[uint16](vals[14]),
		MaxSpeed:                      typeconv.ToUint16[uint16](vals[15]),
		AvgHeartRate:                  typeconv.ToUint8[uint8](vals[16]),
		MaxHeartRate:                  typeconv.ToUint8[uint8](vals[17]),
		AvgCadence:                    typeconv.ToUint8[uint8](vals[18]),
		MaxCadence:                    typeconv.ToUint8[uint8](vals[19]),
		AvgPower:                      typeconv.ToUint16[uint16](vals[20]),
		MaxPower:                      typeconv.ToUint16[uint16](vals[21]),
		TotalAscent:                   typeconv.ToUint16[uint16](vals[22]),
		TotalDescent:                  typeconv.ToUint16[uint16](vals[23]),
		TotalTrainingEffect:           typeconv.ToUint8[uint8](vals[24]),
		FirstLapIndex:                 typeconv.ToUint16[uint16](vals[25]),
		NumLaps:                       typeconv.ToUint16[uint16](vals[26]),
		EventGroup:                    typeconv.ToUint8[uint8](vals[27]),
		Trigger:                       typeconv.ToEnum[typedef.SessionTrigger](vals[28]),
		NecLat:                        typeconv.ToSint32[int32](vals[29]),
		NecLong:                       typeconv.ToSint32[int32](vals[30]),
		SwcLat:                        typeconv.ToSint32[int32](vals[31]),
		SwcLong:                       typeconv.ToSint32[int32](vals[32]),
		NumLengths:                    typeconv.ToUint16[uint16](vals[33]),
		NormalizedPower:               typeconv.ToUint16[uint16](vals[34]),
		TrainingStressScore:           typeconv.ToUint16[uint16](vals[35]),
		IntensityFactor:               typeconv.ToUint16[uint16](vals[36]),
		LeftRightBalance:              typeconv.ToUint16[typedef.LeftRightBalance100](vals[37]),
		EndPositionLat:                typeconv.ToSint32[int32](vals[38]),
		EndPositionLong:               typeconv.ToSint32[int32](vals[39]),
		AvgStrokeCount:                typeconv.ToUint32[uint32](vals[41]),
		AvgStrokeDistance:             typeconv.ToUint16[uint16](vals[42]),
		SwimStroke:                    typeconv.ToEnum[typedef.SwimStroke](vals[43]),
		PoolLength:                    typeconv.ToUint16[uint16](vals[44]),
		ThresholdPower:                typeconv.ToUint16[uint16](vals[45]),
		PoolLengthUnit:                typeconv.ToEnum[typedef.DisplayMeasure](vals[46]),
		NumActiveLengths:              typeconv.ToUint16[uint16](vals[47]),
		TotalWork:                     typeconv.ToUint32[uint32](vals[48]),
		AvgAltitude:                   typeconv.ToUint16[uint16](vals[49]),
		MaxAltitude:                   typeconv.ToUint16[uint16](vals[50]),
		GpsAccuracy:                   typeconv.ToUint8[uint8](vals[51]),
		AvgGrade:                      typeconv.ToSint16[int16](vals[52]),
		AvgPosGrade:                   typeconv.ToSint16[int16](vals[53]),
		AvgNegGrade:                   typeconv.ToSint16[int16](vals[54]),
		MaxPosGrade:                   typeconv.ToSint16[int16](vals[55]),
		MaxNegGrade:                   typeconv.ToSint16[int16](vals[56]),
		AvgTemperature:                typeconv.ToSint8[int8](vals[57]),
		MaxTemperature:                typeconv.ToSint8[int8](vals[58]),
		TotalMovingTime:               typeconv.ToUint32[uint32](vals[59]),
		AvgPosVerticalSpeed:           typeconv.ToSint16[int16](vals[60]),
		AvgNegVerticalSpeed:           typeconv.ToSint16[int16](vals[61]),
		MaxPosVerticalSpeed:           typeconv.ToSint16[int16](vals[62]),
		MaxNegVerticalSpeed:           typeconv.ToSint16[int16](vals[63]),
		MinHeartRate:                  typeconv.ToUint8[uint8](vals[64]),
		TimeInHrZone:                  typeconv.ToSliceUint32[uint32](vals[65]),
		TimeInSpeedZone:               typeconv.ToSliceUint32[uint32](vals[66]),
		TimeInCadenceZone:             typeconv.ToSliceUint32[uint32](vals[67]),
		TimeInPowerZone:               typeconv.ToSliceUint32[uint32](vals[68]),
		AvgLapTime:                    typeconv.ToUint32[uint32](vals[69]),
		BestLapIndex:                  typeconv.ToUint16[uint16](vals[70]),
		MinAltitude:                   typeconv.ToUint16[uint16](vals[71]),
		PlayerScore:                   typeconv.ToUint16[uint16](vals[82]),
		OpponentScore:                 typeconv.ToUint16[uint16](vals[83]),
		OpponentName:                  typeconv.ToString[string](vals[84]),
		StrokeCount:                   typeconv.ToSliceUint16[uint16](vals[85]),
		ZoneCount:                     typeconv.ToSliceUint16[uint16](vals[86]),
		MaxBallSpeed:                  typeconv.ToUint16[uint16](vals[87]),
		AvgBallSpeed:                  typeconv.ToUint16[uint16](vals[88]),
		AvgVerticalOscillation:        typeconv.ToUint16[uint16](vals[89]),
		AvgStanceTimePercent:          typeconv.ToUint16[uint16](vals[90]),
		AvgStanceTime:                 typeconv.ToUint16[uint16](vals[91]),
		AvgFractionalCadence:          typeconv.ToUint8[uint8](vals[92]),
		MaxFractionalCadence:          typeconv.ToUint8[uint8](vals[93]),
		TotalFractionalCycles:         typeconv.ToUint8[uint8](vals[94]),
		AvgTotalHemoglobinConc:        typeconv.ToSliceUint16[uint16](vals[95]),
		MinTotalHemoglobinConc:        typeconv.ToSliceUint16[uint16](vals[96]),
		MaxTotalHemoglobinConc:        typeconv.ToSliceUint16[uint16](vals[97]),
		AvgSaturatedHemoglobinPercent: typeconv.ToSliceUint16[uint16](vals[98]),
		MinSaturatedHemoglobinPercent: typeconv.ToSliceUint16[uint16](vals[99]),
		MaxSaturatedHemoglobinPercent: typeconv.ToSliceUint16[uint16](vals[100]),
		AvgLeftTorqueEffectiveness:    typeconv.ToUint8[uint8](vals[101]),
		AvgRightTorqueEffectiveness:   typeconv.ToUint8[uint8](vals[102]),
		AvgLeftPedalSmoothness:        typeconv.ToUint8[uint8](vals[103]),
		AvgRightPedalSmoothness:       typeconv.ToUint8[uint8](vals[104]),
		AvgCombinedPedalSmoothness:    typeconv.ToUint8[uint8](vals[105]),
		SportProfileName:              typeconv.ToString[string](vals[110]),
		SportIndex:                    typeconv.ToUint8[uint8](vals[111]),
		TimeStanding:                  typeconv.ToUint32[uint32](vals[112]),
		StandCount:                    typeconv.ToUint16[uint16](vals[113]),
		AvgLeftPco:                    typeconv.ToSint8[int8](vals[114]),
		AvgRightPco:                   typeconv.ToSint8[int8](vals[115]),
		AvgLeftPowerPhase:             typeconv.ToSliceUint8[uint8](vals[116]),
		AvgLeftPowerPhasePeak:         typeconv.ToSliceUint8[uint8](vals[117]),
		AvgRightPowerPhase:            typeconv.ToSliceUint8[uint8](vals[118]),
		AvgRightPowerPhasePeak:        typeconv.ToSliceUint8[uint8](vals[119]),
		AvgPowerPosition:              typeconv.ToSliceUint16[uint16](vals[120]),
		MaxPowerPosition:              typeconv.ToSliceUint16[uint16](vals[121]),
		AvgCadencePosition:            typeconv.ToSliceUint8[uint8](vals[122]),
		MaxCadencePosition:            typeconv.ToSliceUint8[uint8](vals[123]),
		EnhancedAvgSpeed:              typeconv.ToUint32[uint32](vals[124]),
		EnhancedMaxSpeed:              typeconv.ToUint32[uint32](vals[125]),
		EnhancedAvgAltitude:           typeconv.ToUint32[uint32](vals[126]),
		EnhancedMinAltitude:           typeconv.ToUint32[uint32](vals[127]),
		EnhancedMaxAltitude:           typeconv.ToUint32[uint32](vals[128]),
		AvgLevMotorPower:              typeconv.ToUint16[uint16](vals[129]),
		MaxLevMotorPower:              typeconv.ToUint16[uint16](vals[130]),
		LevBatteryConsumption:         typeconv.ToUint8[uint8](vals[131]),
		AvgVerticalRatio:              typeconv.ToUint16[uint16](vals[132]),
		AvgStanceTimeBalance:          typeconv.ToUint16[uint16](vals[133]),
		AvgStepLength:                 typeconv.ToUint16[uint16](vals[134]),
		TotalAnaerobicTrainingEffect:  typeconv.ToUint8[uint8](vals[137]),
		AvgVam:                        typeconv.ToUint16[uint16](vals[139]),
		AvgDepth:                      typeconv.ToUint32[uint32](vals[140]),
		MaxDepth:                      typeconv.ToUint32[uint32](vals[141]),
		SurfaceInterval:               typeconv.ToUint32[uint32](vals[142]),
		StartCns:                      typeconv.ToUint8[uint8](vals[143]),
		EndCns:                        typeconv.ToUint8[uint8](vals[144]),
		StartN2:                       typeconv.ToUint16[uint16](vals[145]),
		EndN2:                         typeconv.ToUint16[uint16](vals[146]),
		AvgRespirationRate:            typeconv.ToUint8[uint8](vals[147]),
		MaxRespirationRate:            typeconv.ToUint8[uint8](vals[148]),
		MinRespirationRate:            typeconv.ToUint8[uint8](vals[149]),
		MinTemperature:                typeconv.ToSint8[int8](vals[150]),
		O2Toxicity:                    typeconv.ToUint16[uint16](vals[155]),
		DiveNumber:                    typeconv.ToUint32[uint32](vals[156]),
		TrainingLoadPeak:              typeconv.ToSint32[int32](vals[168]),
		EnhancedAvgRespirationRate:    typeconv.ToUint16[uint16](vals[169]),
		EnhancedMaxRespirationRate:    typeconv.ToUint16[uint16](vals[170]),
		EnhancedMinRespirationRate:    typeconv.ToUint16[uint16](vals[180]),
		TotalGrit:                     typeconv.ToFloat32[float32](vals[181]),
		TotalFlow:                     typeconv.ToFloat32[float32](vals[182]),
		JumpCount:                     typeconv.ToUint16[uint16](vals[183]),
		AvgGrit:                       typeconv.ToFloat32[float32](vals[186]),
		AvgFlow:                       typeconv.ToFloat32[float32](vals[187]),
		AvgSpo2:                       typeconv.ToUint8[uint8](vals[194]),
		AvgStress:                     typeconv.ToUint8[uint8](vals[195]),
		SdrrHrv:                       typeconv.ToUint8[uint8](vals[197]),
		RmssdHrv:                      typeconv.ToUint8[uint8](vals[198]),
		TotalFractionalAscent:         typeconv.ToUint8[uint8](vals[199]),
		TotalFractionalDescent:        typeconv.ToUint8[uint8](vals[200]),
		AvgCoreTemperature:            typeconv.ToUint16[uint16](vals[208]),
		MinCoreTemperature:            typeconv.ToUint16[uint16](vals[209]),
		MaxCoreTemperature:            typeconv.ToUint16[uint16](vals[210]),

		DeveloperFields: developerFields,
	}
}

// ToMesg converts Session into proto.Message.
func (m *Session) ToMesg(fac Factory) proto.Message {
	mesg := fac.CreateMesgOnly(typedef.MesgNumSession)
	mesg.Fields = make([]proto.Field, 0, m.size())

	if typeconv.ToUint16[uint16](m.MessageIndex) != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 254)
		field.Value = typeconv.ToUint16[uint16](m.MessageIndex)
		mesg.Fields = append(mesg.Fields, field)
	}
	if datetime.ToUint32(m.Timestamp) != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 253)
		field.Value = datetime.ToUint32(m.Timestamp)
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToEnum[byte](m.Event) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 0)
		field.Value = typeconv.ToEnum[byte](m.Event)
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToEnum[byte](m.EventType) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 1)
		field.Value = typeconv.ToEnum[byte](m.EventType)
		mesg.Fields = append(mesg.Fields, field)
	}
	if datetime.ToUint32(m.StartTime) != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 2)
		field.Value = datetime.ToUint32(m.StartTime)
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.StartPositionLat != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 3)
		field.Value = m.StartPositionLat
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.StartPositionLong != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 4)
		field.Value = m.StartPositionLong
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToEnum[byte](m.Sport) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 5)
		field.Value = typeconv.ToEnum[byte](m.Sport)
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToEnum[byte](m.SubSport) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 6)
		field.Value = typeconv.ToEnum[byte](m.SubSport)
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalElapsedTime != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 7)
		field.Value = m.TotalElapsedTime
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalTimerTime != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 8)
		field.Value = m.TotalTimerTime
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalDistance != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 9)
		field.Value = m.TotalDistance
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalCycles != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 10)
		field.Value = m.TotalCycles
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalCalories != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 11)
		field.Value = m.TotalCalories
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalFatCalories != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 13)
		field.Value = m.TotalFatCalories
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgSpeed != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 14)
		field.Value = m.AvgSpeed
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxSpeed != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 15)
		field.Value = m.MaxSpeed
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgHeartRate != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 16)
		field.Value = m.AvgHeartRate
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxHeartRate != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 17)
		field.Value = m.MaxHeartRate
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgCadence != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 18)
		field.Value = m.AvgCadence
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxCadence != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 19)
		field.Value = m.MaxCadence
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgPower != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 20)
		field.Value = m.AvgPower
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxPower != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 21)
		field.Value = m.MaxPower
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalAscent != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 22)
		field.Value = m.TotalAscent
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalDescent != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 23)
		field.Value = m.TotalDescent
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalTrainingEffect != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 24)
		field.Value = m.TotalTrainingEffect
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.FirstLapIndex != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 25)
		field.Value = m.FirstLapIndex
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.NumLaps != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 26)
		field.Value = m.NumLaps
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.EventGroup != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 27)
		field.Value = m.EventGroup
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToEnum[byte](m.Trigger) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 28)
		field.Value = typeconv.ToEnum[byte](m.Trigger)
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.NecLat != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 29)
		field.Value = m.NecLat
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.NecLong != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 30)
		field.Value = m.NecLong
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.SwcLat != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 31)
		field.Value = m.SwcLat
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.SwcLong != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 32)
		field.Value = m.SwcLong
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.NumLengths != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 33)
		field.Value = m.NumLengths
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.NormalizedPower != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 34)
		field.Value = m.NormalizedPower
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TrainingStressScore != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 35)
		field.Value = m.TrainingStressScore
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.IntensityFactor != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 36)
		field.Value = m.IntensityFactor
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToUint16[uint16](m.LeftRightBalance) != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 37)
		field.Value = typeconv.ToUint16[uint16](m.LeftRightBalance)
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.EndPositionLat != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 38)
		field.Value = m.EndPositionLat
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.EndPositionLong != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 39)
		field.Value = m.EndPositionLong
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgStrokeCount != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 41)
		field.Value = m.AvgStrokeCount
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgStrokeDistance != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 42)
		field.Value = m.AvgStrokeDistance
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToEnum[byte](m.SwimStroke) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 43)
		field.Value = typeconv.ToEnum[byte](m.SwimStroke)
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.PoolLength != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 44)
		field.Value = m.PoolLength
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.ThresholdPower != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 45)
		field.Value = m.ThresholdPower
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToEnum[byte](m.PoolLengthUnit) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 46)
		field.Value = typeconv.ToEnum[byte](m.PoolLengthUnit)
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.NumActiveLengths != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 47)
		field.Value = m.NumActiveLengths
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalWork != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 48)
		field.Value = m.TotalWork
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgAltitude != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 49)
		field.Value = m.AvgAltitude
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxAltitude != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 50)
		field.Value = m.MaxAltitude
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.GpsAccuracy != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 51)
		field.Value = m.GpsAccuracy
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgGrade != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 52)
		field.Value = m.AvgGrade
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgPosGrade != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 53)
		field.Value = m.AvgPosGrade
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgNegGrade != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 54)
		field.Value = m.AvgNegGrade
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxPosGrade != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 55)
		field.Value = m.MaxPosGrade
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxNegGrade != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 56)
		field.Value = m.MaxNegGrade
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgTemperature != basetype.Sint8Invalid {
		field := fac.CreateField(mesg.Num, 57)
		field.Value = m.AvgTemperature
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxTemperature != basetype.Sint8Invalid {
		field := fac.CreateField(mesg.Num, 58)
		field.Value = m.MaxTemperature
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalMovingTime != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 59)
		field.Value = m.TotalMovingTime
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgPosVerticalSpeed != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 60)
		field.Value = m.AvgPosVerticalSpeed
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgNegVerticalSpeed != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 61)
		field.Value = m.AvgNegVerticalSpeed
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxPosVerticalSpeed != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 62)
		field.Value = m.MaxPosVerticalSpeed
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxNegVerticalSpeed != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 63)
		field.Value = m.MaxNegVerticalSpeed
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MinHeartRate != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 64)
		field.Value = m.MinHeartRate
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TimeInHrZone != nil {
		field := fac.CreateField(mesg.Num, 65)
		field.Value = m.TimeInHrZone
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TimeInSpeedZone != nil {
		field := fac.CreateField(mesg.Num, 66)
		field.Value = m.TimeInSpeedZone
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TimeInCadenceZone != nil {
		field := fac.CreateField(mesg.Num, 67)
		field.Value = m.TimeInCadenceZone
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TimeInPowerZone != nil {
		field := fac.CreateField(mesg.Num, 68)
		field.Value = m.TimeInPowerZone
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgLapTime != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 69)
		field.Value = m.AvgLapTime
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.BestLapIndex != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 70)
		field.Value = m.BestLapIndex
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MinAltitude != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 71)
		field.Value = m.MinAltitude
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.PlayerScore != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 82)
		field.Value = m.PlayerScore
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.OpponentScore != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 83)
		field.Value = m.OpponentScore
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.OpponentName != basetype.StringInvalid && m.OpponentName != "" {
		field := fac.CreateField(mesg.Num, 84)
		field.Value = m.OpponentName
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.StrokeCount != nil {
		field := fac.CreateField(mesg.Num, 85)
		field.Value = m.StrokeCount
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.ZoneCount != nil {
		field := fac.CreateField(mesg.Num, 86)
		field.Value = m.ZoneCount
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxBallSpeed != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 87)
		field.Value = m.MaxBallSpeed
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgBallSpeed != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 88)
		field.Value = m.AvgBallSpeed
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgVerticalOscillation != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 89)
		field.Value = m.AvgVerticalOscillation
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgStanceTimePercent != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 90)
		field.Value = m.AvgStanceTimePercent
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgStanceTime != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 91)
		field.Value = m.AvgStanceTime
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgFractionalCadence != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 92)
		field.Value = m.AvgFractionalCadence
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxFractionalCadence != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 93)
		field.Value = m.MaxFractionalCadence
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalFractionalCycles != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 94)
		field.Value = m.TotalFractionalCycles
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgTotalHemoglobinConc != nil {
		field := fac.CreateField(mesg.Num, 95)
		field.Value = m.AvgTotalHemoglobinConc
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MinTotalHemoglobinConc != nil {
		field := fac.CreateField(mesg.Num, 96)
		field.Value = m.MinTotalHemoglobinConc
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxTotalHemoglobinConc != nil {
		field := fac.CreateField(mesg.Num, 97)
		field.Value = m.MaxTotalHemoglobinConc
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgSaturatedHemoglobinPercent != nil {
		field := fac.CreateField(mesg.Num, 98)
		field.Value = m.AvgSaturatedHemoglobinPercent
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MinSaturatedHemoglobinPercent != nil {
		field := fac.CreateField(mesg.Num, 99)
		field.Value = m.MinSaturatedHemoglobinPercent
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxSaturatedHemoglobinPercent != nil {
		field := fac.CreateField(mesg.Num, 100)
		field.Value = m.MaxSaturatedHemoglobinPercent
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgLeftTorqueEffectiveness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 101)
		field.Value = m.AvgLeftTorqueEffectiveness
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgRightTorqueEffectiveness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 102)
		field.Value = m.AvgRightTorqueEffectiveness
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgLeftPedalSmoothness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 103)
		field.Value = m.AvgLeftPedalSmoothness
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgRightPedalSmoothness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 104)
		field.Value = m.AvgRightPedalSmoothness
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgCombinedPedalSmoothness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 105)
		field.Value = m.AvgCombinedPedalSmoothness
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.SportProfileName != basetype.StringInvalid && m.SportProfileName != "" {
		field := fac.CreateField(mesg.Num, 110)
		field.Value = m.SportProfileName
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.SportIndex != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 111)
		field.Value = m.SportIndex
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TimeStanding != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 112)
		field.Value = m.TimeStanding
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.StandCount != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 113)
		field.Value = m.StandCount
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgLeftPco != basetype.Sint8Invalid {
		field := fac.CreateField(mesg.Num, 114)
		field.Value = m.AvgLeftPco
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgRightPco != basetype.Sint8Invalid {
		field := fac.CreateField(mesg.Num, 115)
		field.Value = m.AvgRightPco
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgLeftPowerPhase != nil {
		field := fac.CreateField(mesg.Num, 116)
		field.Value = m.AvgLeftPowerPhase
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgLeftPowerPhasePeak != nil {
		field := fac.CreateField(mesg.Num, 117)
		field.Value = m.AvgLeftPowerPhasePeak
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgRightPowerPhase != nil {
		field := fac.CreateField(mesg.Num, 118)
		field.Value = m.AvgRightPowerPhase
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgRightPowerPhasePeak != nil {
		field := fac.CreateField(mesg.Num, 119)
		field.Value = m.AvgRightPowerPhasePeak
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgPowerPosition != nil {
		field := fac.CreateField(mesg.Num, 120)
		field.Value = m.AvgPowerPosition
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxPowerPosition != nil {
		field := fac.CreateField(mesg.Num, 121)
		field.Value = m.MaxPowerPosition
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgCadencePosition != nil {
		field := fac.CreateField(mesg.Num, 122)
		field.Value = m.AvgCadencePosition
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxCadencePosition != nil {
		field := fac.CreateField(mesg.Num, 123)
		field.Value = m.MaxCadencePosition
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.EnhancedAvgSpeed != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 124)
		field.Value = m.EnhancedAvgSpeed
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.EnhancedMaxSpeed != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 125)
		field.Value = m.EnhancedMaxSpeed
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.EnhancedAvgAltitude != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 126)
		field.Value = m.EnhancedAvgAltitude
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.EnhancedMinAltitude != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 127)
		field.Value = m.EnhancedMinAltitude
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.EnhancedMaxAltitude != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 128)
		field.Value = m.EnhancedMaxAltitude
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgLevMotorPower != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 129)
		field.Value = m.AvgLevMotorPower
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxLevMotorPower != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 130)
		field.Value = m.MaxLevMotorPower
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.LevBatteryConsumption != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 131)
		field.Value = m.LevBatteryConsumption
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgVerticalRatio != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 132)
		field.Value = m.AvgVerticalRatio
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgStanceTimeBalance != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 133)
		field.Value = m.AvgStanceTimeBalance
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgStepLength != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 134)
		field.Value = m.AvgStepLength
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalAnaerobicTrainingEffect != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 137)
		field.Value = m.TotalAnaerobicTrainingEffect
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgVam != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 139)
		field.Value = m.AvgVam
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgDepth != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 140)
		field.Value = m.AvgDepth
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxDepth != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 141)
		field.Value = m.MaxDepth
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.SurfaceInterval != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 142)
		field.Value = m.SurfaceInterval
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.StartCns != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 143)
		field.Value = m.StartCns
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.EndCns != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 144)
		field.Value = m.EndCns
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.StartN2 != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 145)
		field.Value = m.StartN2
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.EndN2 != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 146)
		field.Value = m.EndN2
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgRespirationRate != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 147)
		field.Value = m.AvgRespirationRate
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxRespirationRate != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 148)
		field.Value = m.MaxRespirationRate
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MinRespirationRate != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 149)
		field.Value = m.MinRespirationRate
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MinTemperature != basetype.Sint8Invalid {
		field := fac.CreateField(mesg.Num, 150)
		field.Value = m.MinTemperature
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.O2Toxicity != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 155)
		field.Value = m.O2Toxicity
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.DiveNumber != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 156)
		field.Value = m.DiveNumber
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TrainingLoadPeak != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 168)
		field.Value = m.TrainingLoadPeak
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.EnhancedAvgRespirationRate != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 169)
		field.Value = m.EnhancedAvgRespirationRate
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.EnhancedMaxRespirationRate != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 170)
		field.Value = m.EnhancedMaxRespirationRate
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.EnhancedMinRespirationRate != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 180)
		field.Value = m.EnhancedMinRespirationRate
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToUint32[uint32](m.TotalGrit) != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 181)
		field.Value = m.TotalGrit
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToUint32[uint32](m.TotalFlow) != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 182)
		field.Value = m.TotalFlow
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.JumpCount != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 183)
		field.Value = m.JumpCount
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToUint32[uint32](m.AvgGrit) != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 186)
		field.Value = m.AvgGrit
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToUint32[uint32](m.AvgFlow) != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 187)
		field.Value = m.AvgFlow
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgSpo2 != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 194)
		field.Value = m.AvgSpo2
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgStress != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 195)
		field.Value = m.AvgStress
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.SdrrHrv != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 197)
		field.Value = m.SdrrHrv
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.RmssdHrv != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 198)
		field.Value = m.RmssdHrv
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalFractionalAscent != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 199)
		field.Value = m.TotalFractionalAscent
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalFractionalDescent != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 200)
		field.Value = m.TotalFractionalDescent
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgCoreTemperature != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 208)
		field.Value = m.AvgCoreTemperature
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MinCoreTemperature != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 209)
		field.Value = m.MinCoreTemperature
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxCoreTemperature != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 210)
		field.Value = m.MaxCoreTemperature
		mesg.Fields = append(mesg.Fields, field)
	}

	mesg.DeveloperFields = m.DeveloperFields

	return mesg
}

// size returns size of Session's valid fields.
func (m *Session) size() byte {
	var size byte
	if typeconv.ToUint16[uint16](m.MessageIndex) != basetype.Uint16Invalid {
		size++
	}
	if datetime.ToUint32(m.Timestamp) != basetype.Uint32Invalid {
		size++
	}
	if typeconv.ToEnum[byte](m.Event) != basetype.EnumInvalid {
		size++
	}
	if typeconv.ToEnum[byte](m.EventType) != basetype.EnumInvalid {
		size++
	}
	if datetime.ToUint32(m.StartTime) != basetype.Uint32Invalid {
		size++
	}
	if m.StartPositionLat != basetype.Sint32Invalid {
		size++
	}
	if m.StartPositionLong != basetype.Sint32Invalid {
		size++
	}
	if typeconv.ToEnum[byte](m.Sport) != basetype.EnumInvalid {
		size++
	}
	if typeconv.ToEnum[byte](m.SubSport) != basetype.EnumInvalid {
		size++
	}
	if m.TotalElapsedTime != basetype.Uint32Invalid {
		size++
	}
	if m.TotalTimerTime != basetype.Uint32Invalid {
		size++
	}
	if m.TotalDistance != basetype.Uint32Invalid {
		size++
	}
	if m.TotalCycles != basetype.Uint32Invalid {
		size++
	}
	if m.TotalCalories != basetype.Uint16Invalid {
		size++
	}
	if m.TotalFatCalories != basetype.Uint16Invalid {
		size++
	}
	if m.AvgSpeed != basetype.Uint16Invalid {
		size++
	}
	if m.MaxSpeed != basetype.Uint16Invalid {
		size++
	}
	if m.AvgHeartRate != basetype.Uint8Invalid {
		size++
	}
	if m.MaxHeartRate != basetype.Uint8Invalid {
		size++
	}
	if m.AvgCadence != basetype.Uint8Invalid {
		size++
	}
	if m.MaxCadence != basetype.Uint8Invalid {
		size++
	}
	if m.AvgPower != basetype.Uint16Invalid {
		size++
	}
	if m.MaxPower != basetype.Uint16Invalid {
		size++
	}
	if m.TotalAscent != basetype.Uint16Invalid {
		size++
	}
	if m.TotalDescent != basetype.Uint16Invalid {
		size++
	}
	if m.TotalTrainingEffect != basetype.Uint8Invalid {
		size++
	}
	if m.FirstLapIndex != basetype.Uint16Invalid {
		size++
	}
	if m.NumLaps != basetype.Uint16Invalid {
		size++
	}
	if m.EventGroup != basetype.Uint8Invalid {
		size++
	}
	if typeconv.ToEnum[byte](m.Trigger) != basetype.EnumInvalid {
		size++
	}
	if m.NecLat != basetype.Sint32Invalid {
		size++
	}
	if m.NecLong != basetype.Sint32Invalid {
		size++
	}
	if m.SwcLat != basetype.Sint32Invalid {
		size++
	}
	if m.SwcLong != basetype.Sint32Invalid {
		size++
	}
	if m.NumLengths != basetype.Uint16Invalid {
		size++
	}
	if m.NormalizedPower != basetype.Uint16Invalid {
		size++
	}
	if m.TrainingStressScore != basetype.Uint16Invalid {
		size++
	}
	if m.IntensityFactor != basetype.Uint16Invalid {
		size++
	}
	if typeconv.ToUint16[uint16](m.LeftRightBalance) != basetype.Uint16Invalid {
		size++
	}
	if m.EndPositionLat != basetype.Sint32Invalid {
		size++
	}
	if m.EndPositionLong != basetype.Sint32Invalid {
		size++
	}
	if m.AvgStrokeCount != basetype.Uint32Invalid {
		size++
	}
	if m.AvgStrokeDistance != basetype.Uint16Invalid {
		size++
	}
	if typeconv.ToEnum[byte](m.SwimStroke) != basetype.EnumInvalid {
		size++
	}
	if m.PoolLength != basetype.Uint16Invalid {
		size++
	}
	if m.ThresholdPower != basetype.Uint16Invalid {
		size++
	}
	if typeconv.ToEnum[byte](m.PoolLengthUnit) != basetype.EnumInvalid {
		size++
	}
	if m.NumActiveLengths != basetype.Uint16Invalid {
		size++
	}
	if m.TotalWork != basetype.Uint32Invalid {
		size++
	}
	if m.AvgAltitude != basetype.Uint16Invalid {
		size++
	}
	if m.MaxAltitude != basetype.Uint16Invalid {
		size++
	}
	if m.GpsAccuracy != basetype.Uint8Invalid {
		size++
	}
	if m.AvgGrade != basetype.Sint16Invalid {
		size++
	}
	if m.AvgPosGrade != basetype.Sint16Invalid {
		size++
	}
	if m.AvgNegGrade != basetype.Sint16Invalid {
		size++
	}
	if m.MaxPosGrade != basetype.Sint16Invalid {
		size++
	}
	if m.MaxNegGrade != basetype.Sint16Invalid {
		size++
	}
	if m.AvgTemperature != basetype.Sint8Invalid {
		size++
	}
	if m.MaxTemperature != basetype.Sint8Invalid {
		size++
	}
	if m.TotalMovingTime != basetype.Uint32Invalid {
		size++
	}
	if m.AvgPosVerticalSpeed != basetype.Sint16Invalid {
		size++
	}
	if m.AvgNegVerticalSpeed != basetype.Sint16Invalid {
		size++
	}
	if m.MaxPosVerticalSpeed != basetype.Sint16Invalid {
		size++
	}
	if m.MaxNegVerticalSpeed != basetype.Sint16Invalid {
		size++
	}
	if m.MinHeartRate != basetype.Uint8Invalid {
		size++
	}
	if m.TimeInHrZone != nil {
		size++
	}
	if m.TimeInSpeedZone != nil {
		size++
	}
	if m.TimeInCadenceZone != nil {
		size++
	}
	if m.TimeInPowerZone != nil {
		size++
	}
	if m.AvgLapTime != basetype.Uint32Invalid {
		size++
	}
	if m.BestLapIndex != basetype.Uint16Invalid {
		size++
	}
	if m.MinAltitude != basetype.Uint16Invalid {
		size++
	}
	if m.PlayerScore != basetype.Uint16Invalid {
		size++
	}
	if m.OpponentScore != basetype.Uint16Invalid {
		size++
	}
	if m.OpponentName != basetype.StringInvalid && m.OpponentName != "" {
		size++
	}
	if m.StrokeCount != nil {
		size++
	}
	if m.ZoneCount != nil {
		size++
	}
	if m.MaxBallSpeed != basetype.Uint16Invalid {
		size++
	}
	if m.AvgBallSpeed != basetype.Uint16Invalid {
		size++
	}
	if m.AvgVerticalOscillation != basetype.Uint16Invalid {
		size++
	}
	if m.AvgStanceTimePercent != basetype.Uint16Invalid {
		size++
	}
	if m.AvgStanceTime != basetype.Uint16Invalid {
		size++
	}
	if m.AvgFractionalCadence != basetype.Uint8Invalid {
		size++
	}
	if m.MaxFractionalCadence != basetype.Uint8Invalid {
		size++
	}
	if m.TotalFractionalCycles != basetype.Uint8Invalid {
		size++
	}
	if m.AvgTotalHemoglobinConc != nil {
		size++
	}
	if m.MinTotalHemoglobinConc != nil {
		size++
	}
	if m.MaxTotalHemoglobinConc != nil {
		size++
	}
	if m.AvgSaturatedHemoglobinPercent != nil {
		size++
	}
	if m.MinSaturatedHemoglobinPercent != nil {
		size++
	}
	if m.MaxSaturatedHemoglobinPercent != nil {
		size++
	}
	if m.AvgLeftTorqueEffectiveness != basetype.Uint8Invalid {
		size++
	}
	if m.AvgRightTorqueEffectiveness != basetype.Uint8Invalid {
		size++
	}
	if m.AvgLeftPedalSmoothness != basetype.Uint8Invalid {
		size++
	}
	if m.AvgRightPedalSmoothness != basetype.Uint8Invalid {
		size++
	}
	if m.AvgCombinedPedalSmoothness != basetype.Uint8Invalid {
		size++
	}
	if m.SportProfileName != basetype.StringInvalid && m.SportProfileName != "" {
		size++
	}
	if m.SportIndex != basetype.Uint8Invalid {
		size++
	}
	if m.TimeStanding != basetype.Uint32Invalid {
		size++
	}
	if m.StandCount != basetype.Uint16Invalid {
		size++
	}
	if m.AvgLeftPco != basetype.Sint8Invalid {
		size++
	}
	if m.AvgRightPco != basetype.Sint8Invalid {
		size++
	}
	if m.AvgLeftPowerPhase != nil {
		size++
	}
	if m.AvgLeftPowerPhasePeak != nil {
		size++
	}
	if m.AvgRightPowerPhase != nil {
		size++
	}
	if m.AvgRightPowerPhasePeak != nil {
		size++
	}
	if m.AvgPowerPosition != nil {
		size++
	}
	if m.MaxPowerPosition != nil {
		size++
	}
	if m.AvgCadencePosition != nil {
		size++
	}
	if m.MaxCadencePosition != nil {
		size++
	}
	if m.EnhancedAvgSpeed != basetype.Uint32Invalid {
		size++
	}
	if m.EnhancedMaxSpeed != basetype.Uint32Invalid {
		size++
	}
	if m.EnhancedAvgAltitude != basetype.Uint32Invalid {
		size++
	}
	if m.EnhancedMinAltitude != basetype.Uint32Invalid {
		size++
	}
	if m.EnhancedMaxAltitude != basetype.Uint32Invalid {
		size++
	}
	if m.AvgLevMotorPower != basetype.Uint16Invalid {
		size++
	}
	if m.MaxLevMotorPower != basetype.Uint16Invalid {
		size++
	}
	if m.LevBatteryConsumption != basetype.Uint8Invalid {
		size++
	}
	if m.AvgVerticalRatio != basetype.Uint16Invalid {
		size++
	}
	if m.AvgStanceTimeBalance != basetype.Uint16Invalid {
		size++
	}
	if m.AvgStepLength != basetype.Uint16Invalid {
		size++
	}
	if m.TotalAnaerobicTrainingEffect != basetype.Uint8Invalid {
		size++
	}
	if m.AvgVam != basetype.Uint16Invalid {
		size++
	}
	if m.AvgDepth != basetype.Uint32Invalid {
		size++
	}
	if m.MaxDepth != basetype.Uint32Invalid {
		size++
	}
	if m.SurfaceInterval != basetype.Uint32Invalid {
		size++
	}
	if m.StartCns != basetype.Uint8Invalid {
		size++
	}
	if m.EndCns != basetype.Uint8Invalid {
		size++
	}
	if m.StartN2 != basetype.Uint16Invalid {
		size++
	}
	if m.EndN2 != basetype.Uint16Invalid {
		size++
	}
	if m.AvgRespirationRate != basetype.Uint8Invalid {
		size++
	}
	if m.MaxRespirationRate != basetype.Uint8Invalid {
		size++
	}
	if m.MinRespirationRate != basetype.Uint8Invalid {
		size++
	}
	if m.MinTemperature != basetype.Sint8Invalid {
		size++
	}
	if m.O2Toxicity != basetype.Uint16Invalid {
		size++
	}
	if m.DiveNumber != basetype.Uint32Invalid {
		size++
	}
	if m.TrainingLoadPeak != basetype.Sint32Invalid {
		size++
	}
	if m.EnhancedAvgRespirationRate != basetype.Uint16Invalid {
		size++
	}
	if m.EnhancedMaxRespirationRate != basetype.Uint16Invalid {
		size++
	}
	if m.EnhancedMinRespirationRate != basetype.Uint16Invalid {
		size++
	}
	if typeconv.ToUint32[uint32](m.TotalGrit) != basetype.Uint32Invalid {
		size++
	}
	if typeconv.ToUint32[uint32](m.TotalFlow) != basetype.Uint32Invalid {
		size++
	}
	if m.JumpCount != basetype.Uint16Invalid {
		size++
	}
	if typeconv.ToUint32[uint32](m.AvgGrit) != basetype.Uint32Invalid {
		size++
	}
	if typeconv.ToUint32[uint32](m.AvgFlow) != basetype.Uint32Invalid {
		size++
	}
	if m.AvgSpo2 != basetype.Uint8Invalid {
		size++
	}
	if m.AvgStress != basetype.Uint8Invalid {
		size++
	}
	if m.SdrrHrv != basetype.Uint8Invalid {
		size++
	}
	if m.RmssdHrv != basetype.Uint8Invalid {
		size++
	}
	if m.TotalFractionalAscent != basetype.Uint8Invalid {
		size++
	}
	if m.TotalFractionalDescent != basetype.Uint8Invalid {
		size++
	}
	if m.AvgCoreTemperature != basetype.Uint16Invalid {
		size++
	}
	if m.MinCoreTemperature != basetype.Uint16Invalid {
		size++
	}
	if m.MaxCoreTemperature != basetype.Uint16Invalid {
		size++
	}
	return size
}

// SetMessageIndex sets Session value.
//
// Selected bit is set for the current session.
func (m *Session) SetMessageIndex(v typedef.MessageIndex) *Session {
	m.MessageIndex = v
	return m
}

// SetTimestamp sets Session value.
//
// Units: s; Sesson end time.
func (m *Session) SetTimestamp(v time.Time) *Session {
	m.Timestamp = v
	return m
}

// SetEvent sets Session value.
//
// session
func (m *Session) SetEvent(v typedef.Event) *Session {
	m.Event = v
	return m
}

// SetEventType sets Session value.
//
// stop
func (m *Session) SetEventType(v typedef.EventType) *Session {
	m.EventType = v
	return m
}

// SetStartTime sets Session value.
func (m *Session) SetStartTime(v time.Time) *Session {
	m.StartTime = v
	return m
}

// SetStartPositionLat sets Session value.
//
// Units: semicircles;
func (m *Session) SetStartPositionLat(v int32) *Session {
	m.StartPositionLat = v
	return m
}

// SetStartPositionLong sets Session value.
//
// Units: semicircles;
func (m *Session) SetStartPositionLong(v int32) *Session {
	m.StartPositionLong = v
	return m
}

// SetSport sets Session value.
func (m *Session) SetSport(v typedef.Sport) *Session {
	m.Sport = v
	return m
}

// SetSubSport sets Session value.
func (m *Session) SetSubSport(v typedef.SubSport) *Session {
	m.SubSport = v
	return m
}

// SetTotalElapsedTime sets Session value.
//
// Scale: 1000; Units: s; Time (includes pauses)
func (m *Session) SetTotalElapsedTime(v uint32) *Session {
	m.TotalElapsedTime = v
	return m
}

// SetTotalTimerTime sets Session value.
//
// Scale: 1000; Units: s; Timer Time (excludes pauses)
func (m *Session) SetTotalTimerTime(v uint32) *Session {
	m.TotalTimerTime = v
	return m
}

// SetTotalDistance sets Session value.
//
// Scale: 100; Units: m;
func (m *Session) SetTotalDistance(v uint32) *Session {
	m.TotalDistance = v
	return m
}

// SetTotalCycles sets Session value.
//
// Units: cycles;
func (m *Session) SetTotalCycles(v uint32) *Session {
	m.TotalCycles = v
	return m
}

// SetTotalCalories sets Session value.
//
// Units: kcal;
func (m *Session) SetTotalCalories(v uint16) *Session {
	m.TotalCalories = v
	return m
}

// SetTotalFatCalories sets Session value.
//
// Units: kcal;
func (m *Session) SetTotalFatCalories(v uint16) *Session {
	m.TotalFatCalories = v
	return m
}

// SetAvgSpeed sets Session value.
//
// Scale: 1000; Units: m/s; total_distance / total_timer_time
func (m *Session) SetAvgSpeed(v uint16) *Session {
	m.AvgSpeed = v
	return m
}

// SetMaxSpeed sets Session value.
//
// Scale: 1000; Units: m/s;
func (m *Session) SetMaxSpeed(v uint16) *Session {
	m.MaxSpeed = v
	return m
}

// SetAvgHeartRate sets Session value.
//
// Units: bpm; average heart rate (excludes pause time)
func (m *Session) SetAvgHeartRate(v uint8) *Session {
	m.AvgHeartRate = v
	return m
}

// SetMaxHeartRate sets Session value.
//
// Units: bpm;
func (m *Session) SetMaxHeartRate(v uint8) *Session {
	m.MaxHeartRate = v
	return m
}

// SetAvgCadence sets Session value.
//
// Units: rpm; total_cycles / total_timer_time if non_zero_avg_cadence otherwise total_cycles / total_elapsed_time
func (m *Session) SetAvgCadence(v uint8) *Session {
	m.AvgCadence = v
	return m
}

// SetMaxCadence sets Session value.
//
// Units: rpm;
func (m *Session) SetMaxCadence(v uint8) *Session {
	m.MaxCadence = v
	return m
}

// SetAvgPower sets Session value.
//
// Units: watts; total_power / total_timer_time if non_zero_avg_power otherwise total_power / total_elapsed_time
func (m *Session) SetAvgPower(v uint16) *Session {
	m.AvgPower = v
	return m
}

// SetMaxPower sets Session value.
//
// Units: watts;
func (m *Session) SetMaxPower(v uint16) *Session {
	m.MaxPower = v
	return m
}

// SetTotalAscent sets Session value.
//
// Units: m;
func (m *Session) SetTotalAscent(v uint16) *Session {
	m.TotalAscent = v
	return m
}

// SetTotalDescent sets Session value.
//
// Units: m;
func (m *Session) SetTotalDescent(v uint16) *Session {
	m.TotalDescent = v
	return m
}

// SetTotalTrainingEffect sets Session value.
//
// Scale: 10;
func (m *Session) SetTotalTrainingEffect(v uint8) *Session {
	m.TotalTrainingEffect = v
	return m
}

// SetFirstLapIndex sets Session value.
func (m *Session) SetFirstLapIndex(v uint16) *Session {
	m.FirstLapIndex = v
	return m
}

// SetNumLaps sets Session value.
func (m *Session) SetNumLaps(v uint16) *Session {
	m.NumLaps = v
	return m
}

// SetEventGroup sets Session value.
func (m *Session) SetEventGroup(v uint8) *Session {
	m.EventGroup = v
	return m
}

// SetTrigger sets Session value.
func (m *Session) SetTrigger(v typedef.SessionTrigger) *Session {
	m.Trigger = v
	return m
}

// SetNecLat sets Session value.
//
// Units: semicircles; North east corner latitude
func (m *Session) SetNecLat(v int32) *Session {
	m.NecLat = v
	return m
}

// SetNecLong sets Session value.
//
// Units: semicircles; North east corner longitude
func (m *Session) SetNecLong(v int32) *Session {
	m.NecLong = v
	return m
}

// SetSwcLat sets Session value.
//
// Units: semicircles; South west corner latitude
func (m *Session) SetSwcLat(v int32) *Session {
	m.SwcLat = v
	return m
}

// SetSwcLong sets Session value.
//
// Units: semicircles; South west corner longitude
func (m *Session) SetSwcLong(v int32) *Session {
	m.SwcLong = v
	return m
}

// SetNumLengths sets Session value.
//
// Units: lengths; # of lengths of swim pool
func (m *Session) SetNumLengths(v uint16) *Session {
	m.NumLengths = v
	return m
}

// SetNormalizedPower sets Session value.
//
// Units: watts;
func (m *Session) SetNormalizedPower(v uint16) *Session {
	m.NormalizedPower = v
	return m
}

// SetTrainingStressScore sets Session value.
//
// Scale: 10; Units: tss;
func (m *Session) SetTrainingStressScore(v uint16) *Session {
	m.TrainingStressScore = v
	return m
}

// SetIntensityFactor sets Session value.
//
// Scale: 1000; Units: if;
func (m *Session) SetIntensityFactor(v uint16) *Session {
	m.IntensityFactor = v
	return m
}

// SetLeftRightBalance sets Session value.
func (m *Session) SetLeftRightBalance(v typedef.LeftRightBalance100) *Session {
	m.LeftRightBalance = v
	return m
}

// SetEndPositionLat sets Session value.
//
// Units: semicircles;
func (m *Session) SetEndPositionLat(v int32) *Session {
	m.EndPositionLat = v
	return m
}

// SetEndPositionLong sets Session value.
//
// Units: semicircles;
func (m *Session) SetEndPositionLong(v int32) *Session {
	m.EndPositionLong = v
	return m
}

// SetAvgStrokeCount sets Session value.
//
// Scale: 10; Units: strokes/lap;
func (m *Session) SetAvgStrokeCount(v uint32) *Session {
	m.AvgStrokeCount = v
	return m
}

// SetAvgStrokeDistance sets Session value.
//
// Scale: 100; Units: m;
func (m *Session) SetAvgStrokeDistance(v uint16) *Session {
	m.AvgStrokeDistance = v
	return m
}

// SetSwimStroke sets Session value.
//
// Units: swim_stroke;
func (m *Session) SetSwimStroke(v typedef.SwimStroke) *Session {
	m.SwimStroke = v
	return m
}

// SetPoolLength sets Session value.
//
// Scale: 100; Units: m;
func (m *Session) SetPoolLength(v uint16) *Session {
	m.PoolLength = v
	return m
}

// SetThresholdPower sets Session value.
//
// Units: watts;
func (m *Session) SetThresholdPower(v uint16) *Session {
	m.ThresholdPower = v
	return m
}

// SetPoolLengthUnit sets Session value.
func (m *Session) SetPoolLengthUnit(v typedef.DisplayMeasure) *Session {
	m.PoolLengthUnit = v
	return m
}

// SetNumActiveLengths sets Session value.
//
// Units: lengths; # of active lengths of swim pool
func (m *Session) SetNumActiveLengths(v uint16) *Session {
	m.NumActiveLengths = v
	return m
}

// SetTotalWork sets Session value.
//
// Units: J;
func (m *Session) SetTotalWork(v uint32) *Session {
	m.TotalWork = v
	return m
}

// SetAvgAltitude sets Session value.
//
// Scale: 5; Offset: 500; Units: m;
func (m *Session) SetAvgAltitude(v uint16) *Session {
	m.AvgAltitude = v
	return m
}

// SetMaxAltitude sets Session value.
//
// Scale: 5; Offset: 500; Units: m;
func (m *Session) SetMaxAltitude(v uint16) *Session {
	m.MaxAltitude = v
	return m
}

// SetGpsAccuracy sets Session value.
//
// Units: m;
func (m *Session) SetGpsAccuracy(v uint8) *Session {
	m.GpsAccuracy = v
	return m
}

// SetAvgGrade sets Session value.
//
// Scale: 100; Units: %;
func (m *Session) SetAvgGrade(v int16) *Session {
	m.AvgGrade = v
	return m
}

// SetAvgPosGrade sets Session value.
//
// Scale: 100; Units: %;
func (m *Session) SetAvgPosGrade(v int16) *Session {
	m.AvgPosGrade = v
	return m
}

// SetAvgNegGrade sets Session value.
//
// Scale: 100; Units: %;
func (m *Session) SetAvgNegGrade(v int16) *Session {
	m.AvgNegGrade = v
	return m
}

// SetMaxPosGrade sets Session value.
//
// Scale: 100; Units: %;
func (m *Session) SetMaxPosGrade(v int16) *Session {
	m.MaxPosGrade = v
	return m
}

// SetMaxNegGrade sets Session value.
//
// Scale: 100; Units: %;
func (m *Session) SetMaxNegGrade(v int16) *Session {
	m.MaxNegGrade = v
	return m
}

// SetAvgTemperature sets Session value.
//
// Units: C;
func (m *Session) SetAvgTemperature(v int8) *Session {
	m.AvgTemperature = v
	return m
}

// SetMaxTemperature sets Session value.
//
// Units: C;
func (m *Session) SetMaxTemperature(v int8) *Session {
	m.MaxTemperature = v
	return m
}

// SetTotalMovingTime sets Session value.
//
// Scale: 1000; Units: s;
func (m *Session) SetTotalMovingTime(v uint32) *Session {
	m.TotalMovingTime = v
	return m
}

// SetAvgPosVerticalSpeed sets Session value.
//
// Scale: 1000; Units: m/s;
func (m *Session) SetAvgPosVerticalSpeed(v int16) *Session {
	m.AvgPosVerticalSpeed = v
	return m
}

// SetAvgNegVerticalSpeed sets Session value.
//
// Scale: 1000; Units: m/s;
func (m *Session) SetAvgNegVerticalSpeed(v int16) *Session {
	m.AvgNegVerticalSpeed = v
	return m
}

// SetMaxPosVerticalSpeed sets Session value.
//
// Scale: 1000; Units: m/s;
func (m *Session) SetMaxPosVerticalSpeed(v int16) *Session {
	m.MaxPosVerticalSpeed = v
	return m
}

// SetMaxNegVerticalSpeed sets Session value.
//
// Scale: 1000; Units: m/s;
func (m *Session) SetMaxNegVerticalSpeed(v int16) *Session {
	m.MaxNegVerticalSpeed = v
	return m
}

// SetMinHeartRate sets Session value.
//
// Units: bpm;
func (m *Session) SetMinHeartRate(v uint8) *Session {
	m.MinHeartRate = v
	return m
}

// SetTimeInHrZone sets Session value.
//
// Array: [N]; Scale: 1000; Units: s;
func (m *Session) SetTimeInHrZone(v []uint32) *Session {
	m.TimeInHrZone = v
	return m
}

// SetTimeInSpeedZone sets Session value.
//
// Array: [N]; Scale: 1000; Units: s;
func (m *Session) SetTimeInSpeedZone(v []uint32) *Session {
	m.TimeInSpeedZone = v
	return m
}

// SetTimeInCadenceZone sets Session value.
//
// Array: [N]; Scale: 1000; Units: s;
func (m *Session) SetTimeInCadenceZone(v []uint32) *Session {
	m.TimeInCadenceZone = v
	return m
}

// SetTimeInPowerZone sets Session value.
//
// Array: [N]; Scale: 1000; Units: s;
func (m *Session) SetTimeInPowerZone(v []uint32) *Session {
	m.TimeInPowerZone = v
	return m
}

// SetAvgLapTime sets Session value.
//
// Scale: 1000; Units: s;
func (m *Session) SetAvgLapTime(v uint32) *Session {
	m.AvgLapTime = v
	return m
}

// SetBestLapIndex sets Session value.
func (m *Session) SetBestLapIndex(v uint16) *Session {
	m.BestLapIndex = v
	return m
}

// SetMinAltitude sets Session value.
//
// Scale: 5; Offset: 500; Units: m;
func (m *Session) SetMinAltitude(v uint16) *Session {
	m.MinAltitude = v
	return m
}

// SetPlayerScore sets Session value.
func (m *Session) SetPlayerScore(v uint16) *Session {
	m.PlayerScore = v
	return m
}

// SetOpponentScore sets Session value.
func (m *Session) SetOpponentScore(v uint16) *Session {
	m.OpponentScore = v
	return m
}

// SetOpponentName sets Session value.
func (m *Session) SetOpponentName(v string) *Session {
	m.OpponentName = v
	return m
}

// SetStrokeCount sets Session value.
//
// Array: [N]; Units: counts; stroke_type enum used as the index
func (m *Session) SetStrokeCount(v []uint16) *Session {
	m.StrokeCount = v
	return m
}

// SetZoneCount sets Session value.
//
// Array: [N]; Units: counts; zone number used as the index
func (m *Session) SetZoneCount(v []uint16) *Session {
	m.ZoneCount = v
	return m
}

// SetMaxBallSpeed sets Session value.
//
// Scale: 100; Units: m/s;
func (m *Session) SetMaxBallSpeed(v uint16) *Session {
	m.MaxBallSpeed = v
	return m
}

// SetAvgBallSpeed sets Session value.
//
// Scale: 100; Units: m/s;
func (m *Session) SetAvgBallSpeed(v uint16) *Session {
	m.AvgBallSpeed = v
	return m
}

// SetAvgVerticalOscillation sets Session value.
//
// Scale: 10; Units: mm;
func (m *Session) SetAvgVerticalOscillation(v uint16) *Session {
	m.AvgVerticalOscillation = v
	return m
}

// SetAvgStanceTimePercent sets Session value.
//
// Scale: 100; Units: percent;
func (m *Session) SetAvgStanceTimePercent(v uint16) *Session {
	m.AvgStanceTimePercent = v
	return m
}

// SetAvgStanceTime sets Session value.
//
// Scale: 10; Units: ms;
func (m *Session) SetAvgStanceTime(v uint16) *Session {
	m.AvgStanceTime = v
	return m
}

// SetAvgFractionalCadence sets Session value.
//
// Scale: 128; Units: rpm; fractional part of the avg_cadence
func (m *Session) SetAvgFractionalCadence(v uint8) *Session {
	m.AvgFractionalCadence = v
	return m
}

// SetMaxFractionalCadence sets Session value.
//
// Scale: 128; Units: rpm; fractional part of the max_cadence
func (m *Session) SetMaxFractionalCadence(v uint8) *Session {
	m.MaxFractionalCadence = v
	return m
}

// SetTotalFractionalCycles sets Session value.
//
// Scale: 128; Units: cycles; fractional part of the total_cycles
func (m *Session) SetTotalFractionalCycles(v uint8) *Session {
	m.TotalFractionalCycles = v
	return m
}

// SetAvgTotalHemoglobinConc sets Session value.
//
// Array: [N]; Scale: 100; Units: g/dL; Avg saturated and unsaturated hemoglobin
func (m *Session) SetAvgTotalHemoglobinConc(v []uint16) *Session {
	m.AvgTotalHemoglobinConc = v
	return m
}

// SetMinTotalHemoglobinConc sets Session value.
//
// Array: [N]; Scale: 100; Units: g/dL; Min saturated and unsaturated hemoglobin
func (m *Session) SetMinTotalHemoglobinConc(v []uint16) *Session {
	m.MinTotalHemoglobinConc = v
	return m
}

// SetMaxTotalHemoglobinConc sets Session value.
//
// Array: [N]; Scale: 100; Units: g/dL; Max saturated and unsaturated hemoglobin
func (m *Session) SetMaxTotalHemoglobinConc(v []uint16) *Session {
	m.MaxTotalHemoglobinConc = v
	return m
}

// SetAvgSaturatedHemoglobinPercent sets Session value.
//
// Array: [N]; Scale: 10; Units: %; Avg percentage of hemoglobin saturated with oxygen
func (m *Session) SetAvgSaturatedHemoglobinPercent(v []uint16) *Session {
	m.AvgSaturatedHemoglobinPercent = v
	return m
}

// SetMinSaturatedHemoglobinPercent sets Session value.
//
// Array: [N]; Scale: 10; Units: %; Min percentage of hemoglobin saturated with oxygen
func (m *Session) SetMinSaturatedHemoglobinPercent(v []uint16) *Session {
	m.MinSaturatedHemoglobinPercent = v
	return m
}

// SetMaxSaturatedHemoglobinPercent sets Session value.
//
// Array: [N]; Scale: 10; Units: %; Max percentage of hemoglobin saturated with oxygen
func (m *Session) SetMaxSaturatedHemoglobinPercent(v []uint16) *Session {
	m.MaxSaturatedHemoglobinPercent = v
	return m
}

// SetAvgLeftTorqueEffectiveness sets Session value.
//
// Scale: 2; Units: percent;
func (m *Session) SetAvgLeftTorqueEffectiveness(v uint8) *Session {
	m.AvgLeftTorqueEffectiveness = v
	return m
}

// SetAvgRightTorqueEffectiveness sets Session value.
//
// Scale: 2; Units: percent;
func (m *Session) SetAvgRightTorqueEffectiveness(v uint8) *Session {
	m.AvgRightTorqueEffectiveness = v
	return m
}

// SetAvgLeftPedalSmoothness sets Session value.
//
// Scale: 2; Units: percent;
func (m *Session) SetAvgLeftPedalSmoothness(v uint8) *Session {
	m.AvgLeftPedalSmoothness = v
	return m
}

// SetAvgRightPedalSmoothness sets Session value.
//
// Scale: 2; Units: percent;
func (m *Session) SetAvgRightPedalSmoothness(v uint8) *Session {
	m.AvgRightPedalSmoothness = v
	return m
}

// SetAvgCombinedPedalSmoothness sets Session value.
//
// Scale: 2; Units: percent;
func (m *Session) SetAvgCombinedPedalSmoothness(v uint8) *Session {
	m.AvgCombinedPedalSmoothness = v
	return m
}

// SetSportProfileName sets Session value.
//
// Sport name from associated sport mesg
func (m *Session) SetSportProfileName(v string) *Session {
	m.SportProfileName = v
	return m
}

// SetSportIndex sets Session value.
func (m *Session) SetSportIndex(v uint8) *Session {
	m.SportIndex = v
	return m
}

// SetTimeStanding sets Session value.
//
// Scale: 1000; Units: s; Total time spend in the standing position
func (m *Session) SetTimeStanding(v uint32) *Session {
	m.TimeStanding = v
	return m
}

// SetStandCount sets Session value.
//
// Number of transitions to the standing state
func (m *Session) SetStandCount(v uint16) *Session {
	m.StandCount = v
	return m
}

// SetAvgLeftPco sets Session value.
//
// Units: mm; Average platform center offset Left
func (m *Session) SetAvgLeftPco(v int8) *Session {
	m.AvgLeftPco = v
	return m
}

// SetAvgRightPco sets Session value.
//
// Units: mm; Average platform center offset Right
func (m *Session) SetAvgRightPco(v int8) *Session {
	m.AvgRightPco = v
	return m
}

// SetAvgLeftPowerPhase sets Session value.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average left power phase angles. Indexes defined by power_phase_type.
func (m *Session) SetAvgLeftPowerPhase(v []uint8) *Session {
	m.AvgLeftPowerPhase = v
	return m
}

// SetAvgLeftPowerPhasePeak sets Session value.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average left power phase peak angles. Data value indexes defined by power_phase_type.
func (m *Session) SetAvgLeftPowerPhasePeak(v []uint8) *Session {
	m.AvgLeftPowerPhasePeak = v
	return m
}

// SetAvgRightPowerPhase sets Session value.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average right power phase angles. Data value indexes defined by power_phase_type.
func (m *Session) SetAvgRightPowerPhase(v []uint8) *Session {
	m.AvgRightPowerPhase = v
	return m
}

// SetAvgRightPowerPhasePeak sets Session value.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average right power phase peak angles data value indexes defined by power_phase_type.
func (m *Session) SetAvgRightPowerPhasePeak(v []uint8) *Session {
	m.AvgRightPowerPhasePeak = v
	return m
}

// SetAvgPowerPosition sets Session value.
//
// Array: [N]; Units: watts; Average power by position. Data value indexes defined by rider_position_type.
func (m *Session) SetAvgPowerPosition(v []uint16) *Session {
	m.AvgPowerPosition = v
	return m
}

// SetMaxPowerPosition sets Session value.
//
// Array: [N]; Units: watts; Maximum power by position. Data value indexes defined by rider_position_type.
func (m *Session) SetMaxPowerPosition(v []uint16) *Session {
	m.MaxPowerPosition = v
	return m
}

// SetAvgCadencePosition sets Session value.
//
// Array: [N]; Units: rpm; Average cadence by position. Data value indexes defined by rider_position_type.
func (m *Session) SetAvgCadencePosition(v []uint8) *Session {
	m.AvgCadencePosition = v
	return m
}

// SetMaxCadencePosition sets Session value.
//
// Array: [N]; Units: rpm; Maximum cadence by position. Data value indexes defined by rider_position_type.
func (m *Session) SetMaxCadencePosition(v []uint8) *Session {
	m.MaxCadencePosition = v
	return m
}

// SetEnhancedAvgSpeed sets Session value.
//
// Scale: 1000; Units: m/s; total_distance / total_timer_time
func (m *Session) SetEnhancedAvgSpeed(v uint32) *Session {
	m.EnhancedAvgSpeed = v
	return m
}

// SetEnhancedMaxSpeed sets Session value.
//
// Scale: 1000; Units: m/s;
func (m *Session) SetEnhancedMaxSpeed(v uint32) *Session {
	m.EnhancedMaxSpeed = v
	return m
}

// SetEnhancedAvgAltitude sets Session value.
//
// Scale: 5; Offset: 500; Units: m;
func (m *Session) SetEnhancedAvgAltitude(v uint32) *Session {
	m.EnhancedAvgAltitude = v
	return m
}

// SetEnhancedMinAltitude sets Session value.
//
// Scale: 5; Offset: 500; Units: m;
func (m *Session) SetEnhancedMinAltitude(v uint32) *Session {
	m.EnhancedMinAltitude = v
	return m
}

// SetEnhancedMaxAltitude sets Session value.
//
// Scale: 5; Offset: 500; Units: m;
func (m *Session) SetEnhancedMaxAltitude(v uint32) *Session {
	m.EnhancedMaxAltitude = v
	return m
}

// SetAvgLevMotorPower sets Session value.
//
// Units: watts; lev average motor power during session
func (m *Session) SetAvgLevMotorPower(v uint16) *Session {
	m.AvgLevMotorPower = v
	return m
}

// SetMaxLevMotorPower sets Session value.
//
// Units: watts; lev maximum motor power during session
func (m *Session) SetMaxLevMotorPower(v uint16) *Session {
	m.MaxLevMotorPower = v
	return m
}

// SetLevBatteryConsumption sets Session value.
//
// Scale: 2; Units: percent; lev battery consumption during session
func (m *Session) SetLevBatteryConsumption(v uint8) *Session {
	m.LevBatteryConsumption = v
	return m
}

// SetAvgVerticalRatio sets Session value.
//
// Scale: 100; Units: percent;
func (m *Session) SetAvgVerticalRatio(v uint16) *Session {
	m.AvgVerticalRatio = v
	return m
}

// SetAvgStanceTimeBalance sets Session value.
//
// Scale: 100; Units: percent;
func (m *Session) SetAvgStanceTimeBalance(v uint16) *Session {
	m.AvgStanceTimeBalance = v
	return m
}

// SetAvgStepLength sets Session value.
//
// Scale: 10; Units: mm;
func (m *Session) SetAvgStepLength(v uint16) *Session {
	m.AvgStepLength = v
	return m
}

// SetTotalAnaerobicTrainingEffect sets Session value.
//
// Scale: 10;
func (m *Session) SetTotalAnaerobicTrainingEffect(v uint8) *Session {
	m.TotalAnaerobicTrainingEffect = v
	return m
}

// SetAvgVam sets Session value.
//
// Scale: 1000; Units: m/s;
func (m *Session) SetAvgVam(v uint16) *Session {
	m.AvgVam = v
	return m
}

// SetAvgDepth sets Session value.
//
// Scale: 1000; Units: m; 0 if above water
func (m *Session) SetAvgDepth(v uint32) *Session {
	m.AvgDepth = v
	return m
}

// SetMaxDepth sets Session value.
//
// Scale: 1000; Units: m; 0 if above water
func (m *Session) SetMaxDepth(v uint32) *Session {
	m.MaxDepth = v
	return m
}

// SetSurfaceInterval sets Session value.
//
// Units: s; Time since end of last dive
func (m *Session) SetSurfaceInterval(v uint32) *Session {
	m.SurfaceInterval = v
	return m
}

// SetStartCns sets Session value.
//
// Units: percent;
func (m *Session) SetStartCns(v uint8) *Session {
	m.StartCns = v
	return m
}

// SetEndCns sets Session value.
//
// Units: percent;
func (m *Session) SetEndCns(v uint8) *Session {
	m.EndCns = v
	return m
}

// SetStartN2 sets Session value.
//
// Units: percent;
func (m *Session) SetStartN2(v uint16) *Session {
	m.StartN2 = v
	return m
}

// SetEndN2 sets Session value.
//
// Units: percent;
func (m *Session) SetEndN2(v uint16) *Session {
	m.EndN2 = v
	return m
}

// SetAvgRespirationRate sets Session value.
func (m *Session) SetAvgRespirationRate(v uint8) *Session {
	m.AvgRespirationRate = v
	return m
}

// SetMaxRespirationRate sets Session value.
func (m *Session) SetMaxRespirationRate(v uint8) *Session {
	m.MaxRespirationRate = v
	return m
}

// SetMinRespirationRate sets Session value.
func (m *Session) SetMinRespirationRate(v uint8) *Session {
	m.MinRespirationRate = v
	return m
}

// SetMinTemperature sets Session value.
//
// Units: C;
func (m *Session) SetMinTemperature(v int8) *Session {
	m.MinTemperature = v
	return m
}

// SetO2Toxicity sets Session value.
//
// Units: OTUs;
func (m *Session) SetO2Toxicity(v uint16) *Session {
	m.O2Toxicity = v
	return m
}

// SetDiveNumber sets Session value.
func (m *Session) SetDiveNumber(v uint32) *Session {
	m.DiveNumber = v
	return m
}

// SetTrainingLoadPeak sets Session value.
//
// Scale: 65536;
func (m *Session) SetTrainingLoadPeak(v int32) *Session {
	m.TrainingLoadPeak = v
	return m
}

// SetEnhancedAvgRespirationRate sets Session value.
//
// Scale: 100; Units: Breaths/min;
func (m *Session) SetEnhancedAvgRespirationRate(v uint16) *Session {
	m.EnhancedAvgRespirationRate = v
	return m
}

// SetEnhancedMaxRespirationRate sets Session value.
//
// Scale: 100; Units: Breaths/min;
func (m *Session) SetEnhancedMaxRespirationRate(v uint16) *Session {
	m.EnhancedMaxRespirationRate = v
	return m
}

// SetEnhancedMinRespirationRate sets Session value.
//
// Scale: 100;
func (m *Session) SetEnhancedMinRespirationRate(v uint16) *Session {
	m.EnhancedMinRespirationRate = v
	return m
}

// SetTotalGrit sets Session value.
//
// Units: kGrit; The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes.
func (m *Session) SetTotalGrit(v float32) *Session {
	m.TotalGrit = v
	return m
}

// SetTotalFlow sets Session value.
//
// Units: Flow; The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals.
func (m *Session) SetTotalFlow(v float32) *Session {
	m.TotalFlow = v
	return m
}

// SetJumpCount sets Session value.
func (m *Session) SetJumpCount(v uint16) *Session {
	m.JumpCount = v
	return m
}

// SetAvgGrit sets Session value.
//
// Units: kGrit; The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes.
func (m *Session) SetAvgGrit(v float32) *Session {
	m.AvgGrit = v
	return m
}

// SetAvgFlow sets Session value.
//
// Units: Flow; The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals.
func (m *Session) SetAvgFlow(v float32) *Session {
	m.AvgFlow = v
	return m
}

// SetAvgSpo2 sets Session value.
//
// Units: percent; Average SPO2 for the monitoring session
func (m *Session) SetAvgSpo2(v uint8) *Session {
	m.AvgSpo2 = v
	return m
}

// SetAvgStress sets Session value.
//
// Units: percent; Average stress for the monitoring session
func (m *Session) SetAvgStress(v uint8) *Session {
	m.AvgStress = v
	return m
}

// SetSdrrHrv sets Session value.
//
// Units: mS; Standard deviation of R-R interval (SDRR) - Heart rate variability measure most useful for wellness users.
func (m *Session) SetSdrrHrv(v uint8) *Session {
	m.SdrrHrv = v
	return m
}

// SetRmssdHrv sets Session value.
//
// Units: mS; Root mean square successive difference (RMSSD) - Heart rate variability measure most useful for athletes
func (m *Session) SetRmssdHrv(v uint8) *Session {
	m.RmssdHrv = v
	return m
}

// SetTotalFractionalAscent sets Session value.
//
// Scale: 100; Units: m; fractional part of total_ascent
func (m *Session) SetTotalFractionalAscent(v uint8) *Session {
	m.TotalFractionalAscent = v
	return m
}

// SetTotalFractionalDescent sets Session value.
//
// Scale: 100; Units: m; fractional part of total_descent
func (m *Session) SetTotalFractionalDescent(v uint8) *Session {
	m.TotalFractionalDescent = v
	return m
}

// SetAvgCoreTemperature sets Session value.
//
// Scale: 100; Units: C;
func (m *Session) SetAvgCoreTemperature(v uint16) *Session {
	m.AvgCoreTemperature = v
	return m
}

// SetMinCoreTemperature sets Session value.
//
// Scale: 100; Units: C;
func (m *Session) SetMinCoreTemperature(v uint16) *Session {
	m.MinCoreTemperature = v
	return m
}

// SetMaxCoreTemperature sets Session value.
//
// Scale: 100; Units: C;
func (m *Session) SetMaxCoreTemperature(v uint16) *Session {
	m.MaxCoreTemperature = v
	return m
}

// SetDeveloperFields Session's DeveloperFields.
func (m *Session) SetDeveloperFields(developerFields ...proto.DeveloperField) *Session {
	m.DeveloperFields = developerFields
	return m
}
