// Code generated by internal/cmd/fitgen/main.go. DO NOT EDIT.

// Copyright 2023 The FIT SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package mesgdef

import (
	"github.com/muktihari/fit/factory"
	"github.com/muktihari/fit/kit/datetime"
	"github.com/muktihari/fit/kit/semicircles"
	"github.com/muktihari/fit/profile/basetype"
	"github.com/muktihari/fit/profile/typedef"
	"github.com/muktihari/fit/proto"
	"math"
	"time"
)

// Record is a Record message.
//
// Note: The order of the fields is optimized using a memory alignment algorithm.
// Do not rely on field indices, such as when using reflection.
type Record struct {
	Timestamp                     time.Time // Units: s
	Speed1S                       []uint8   // Array: [N]; Scale: 16; Units: m/s; Speed at 1s intervals. Timestamp field indicates time of last array element.
	LeftPowerPhase                []uint8   // Array: [N]; Scale: 0.7111111; Units: degrees; Left power phase angles. Data value indexes defined by power_phase_type.
	LeftPowerPhasePeak            []uint8   // Array: [N]; Scale: 0.7111111; Units: degrees; Left power phase peak angles. Data value indexes defined by power_phase_type.
	RightPowerPhase               []uint8   // Array: [N]; Scale: 0.7111111; Units: degrees; Right power phase angles. Data value indexes defined by power_phase_type.
	RightPowerPhasePeak           []uint8   // Array: [N]; Scale: 0.7111111; Units: degrees; Right power phase peak angles. Data value indexes defined by power_phase_type.
	PositionLat                   int32     // Units: semicircles
	PositionLong                  int32     // Units: semicircles
	Distance                      uint32    // Scale: 100; Units: m
	TimeFromCourse                int32     // Scale: 1000; Units: s
	TotalCycles                   uint32    // Units: cycles
	AccumulatedPower              uint32    // Units: watts
	EnhancedSpeed                 uint32    // Scale: 1000; Units: m/s
	EnhancedAltitude              uint32    // Scale: 5; Offset: 500; Units: m
	AbsolutePressure              uint32    // Units: Pa; Includes atmospheric pressure
	Depth                         uint32    // Scale: 1000; Units: m; 0 if above water
	NextStopDepth                 uint32    // Scale: 1000; Units: m; 0 if above water
	NextStopTime                  uint32    // Units: s
	TimeToSurface                 uint32    // Units: s
	NdlTime                       uint32    // Units: s
	Grit                          float32   // The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes.
	Flow                          float32   // The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals.
	AirTimeRemaining              uint32    // Units: s
	AscentRate                    int32     // Scale: 1000; Units: m/s
	Altitude                      uint16    // Scale: 5; Offset: 500; Units: m
	Speed                         uint16    // Scale: 1000; Units: m/s
	Power                         uint16    // Units: watts
	Grade                         int16     // Scale: 100; Units: %
	CompressedAccumulatedPower    uint16    // Units: watts
	VerticalSpeed                 int16     // Scale: 1000; Units: m/s
	Calories                      uint16    // Units: kcal
	VerticalOscillation           uint16    // Scale: 10; Units: mm
	StanceTimePercent             uint16    // Scale: 100; Units: percent
	StanceTime                    uint16    // Scale: 10; Units: ms
	BallSpeed                     uint16    // Scale: 100; Units: m/s
	Cadence256                    uint16    // Scale: 256; Units: rpm; Log cadence and fractional cadence for backwards compatibility
	TotalHemoglobinConc           uint16    // Scale: 100; Units: g/dL; Total saturated and unsaturated hemoglobin
	TotalHemoglobinConcMin        uint16    // Scale: 100; Units: g/dL; Min saturated and unsaturated hemoglobin
	TotalHemoglobinConcMax        uint16    // Scale: 100; Units: g/dL; Max saturated and unsaturated hemoglobin
	SaturatedHemoglobinPercent    uint16    // Scale: 10; Units: %; Percentage of hemoglobin saturated with oxygen
	SaturatedHemoglobinPercentMin uint16    // Scale: 10; Units: %; Min percentage of hemoglobin saturated with oxygen
	SaturatedHemoglobinPercentMax uint16    // Scale: 10; Units: %; Max percentage of hemoglobin saturated with oxygen
	MotorPower                    uint16    // Units: watts; lev motor power
	VerticalRatio                 uint16    // Scale: 100; Units: percent
	StanceTimeBalance             uint16    // Scale: 100; Units: percent
	StepLength                    uint16    // Scale: 10; Units: mm
	CycleLength16                 uint16    // Scale: 100; Units: m; Supports larger cycle sizes needed for paddlesports. Max cycle size: 655.35
	N2Load                        uint16    // Units: percent
	EnhancedRespirationRate       uint16    // Scale: 100; Units: Breaths/min
	CurrentStress                 uint16    // Scale: 100; Current Stress value
	EbikeTravelRange              uint16    // Units: km
	PressureSac                   uint16    // Scale: 100; Units: bar/min; Pressure-based surface air consumption
	VolumeSac                     uint16    // Scale: 100; Units: L/min; Volumetric surface air consumption
	Rmv                           uint16    // Scale: 100; Units: L/min; Respiratory minute volume
	CoreTemperature               uint16    // Scale: 100; Units: C
	CompressedSpeedDistance       [3]byte   // Array: [3]; Units: m/s,m
	HeartRate                     uint8     // Units: bpm
	Cadence                       uint8     // Units: rpm
	Resistance                    uint8     // Relative. 0 is none 254 is Max.
	CycleLength                   uint8     // Scale: 100; Units: m
	Temperature                   int8      // Units: C
	Cycles                        uint8     // Units: cycles
	LeftRightBalance              typedef.LeftRightBalance
	GpsAccuracy                   uint8 // Units: m
	ActivityType                  typedef.ActivityType
	LeftTorqueEffectiveness       uint8 // Scale: 2; Units: percent
	RightTorqueEffectiveness      uint8 // Scale: 2; Units: percent
	LeftPedalSmoothness           uint8 // Scale: 2; Units: percent
	RightPedalSmoothness          uint8 // Scale: 2; Units: percent
	CombinedPedalSmoothness       uint8 // Scale: 2; Units: percent
	Time128                       uint8 // Scale: 128; Units: s
	StrokeType                    typedef.StrokeType
	Zone                          uint8
	FractionalCadence             uint8 // Scale: 128; Units: rpm
	DeviceIndex                   typedef.DeviceIndex
	LeftPco                       int8  // Units: mm; Left platform center offset
	RightPco                      int8  // Units: mm; Right platform center offset
	BatterySoc                    uint8 // Scale: 2; Units: percent; lev battery state of charge
	CnsLoad                       uint8 // Units: percent
	RespirationRate               uint8 // Units: s
	EbikeBatteryLevel             uint8 // Units: percent
	EbikeAssistMode               uint8 // Units: depends on sensor
	EbikeAssistLevelPercent       uint8 // Units: percent
	Po2                           uint8 // Scale: 100; Units: percent; Current partial pressure of oxygen

	state [14]uint8 // Used for tracking expanded fields.

	UnknownFields   []proto.Field          // UnknownFields are fields that are exist but they are not defined in Profile.xlsx
	DeveloperFields []proto.DeveloperField // DeveloperFields are custom data fields [Added since protocol version 2.0]
}

// NewRecord creates new Record struct based on given mesg.
// If mesg is nil, it will return Record with all fields being set to its corresponding invalid value.
func NewRecord(mesg *proto.Message) *Record {
	vals := [254]proto.Value{}

	var state [14]uint8
	var unknownFields []proto.Field
	var developerFields []proto.DeveloperField
	if mesg != nil {
		arr := pool.Get().(*[poolsize]proto.Field)
		unknownFields = arr[:0]
		for i := range mesg.Fields {
			if mesg.Fields[i].Num > 253 || mesg.Fields[i].Name == factory.NameUnknown {
				unknownFields = append(unknownFields, mesg.Fields[i])
				continue
			}
			if mesg.Fields[i].Num < 109 && mesg.Fields[i].IsExpandedField {
				pos := mesg.Fields[i].Num / 8
				state[pos] |= 1 << (mesg.Fields[i].Num - (8 * pos))
			}
			vals[mesg.Fields[i].Num] = mesg.Fields[i].Value
		}
		if len(unknownFields) == 0 {
			unknownFields = nil
		}
		unknownFields = append(unknownFields[:0:0], unknownFields...)
		pool.Put(arr)
		developerFields = mesg.DeveloperFields
	}

	return &Record{
		Timestamp:    datetime.ToTime(vals[253].Uint32()),
		PositionLat:  vals[0].Int32(),
		PositionLong: vals[1].Int32(),
		Altitude:     vals[2].Uint16(),
		HeartRate:    vals[3].Uint8(),
		Cadence:      vals[4].Uint8(),
		Distance:     vals[5].Uint32(),
		Speed:        vals[6].Uint16(),
		Power:        vals[7].Uint16(),
		CompressedSpeedDistance: func() (arr [3]uint8) {
			arr = [3]uint8{
				basetype.ByteInvalid,
				basetype.ByteInvalid,
				basetype.ByteInvalid,
			}
			copy(arr[:], vals[8].SliceUint8())
			return arr
		}(),
		Grade:                         vals[9].Int16(),
		Resistance:                    vals[10].Uint8(),
		TimeFromCourse:                vals[11].Int32(),
		CycleLength:                   vals[12].Uint8(),
		Temperature:                   vals[13].Int8(),
		Speed1S:                       vals[17].SliceUint8(),
		Cycles:                        vals[18].Uint8(),
		TotalCycles:                   vals[19].Uint32(),
		CompressedAccumulatedPower:    vals[28].Uint16(),
		AccumulatedPower:              vals[29].Uint32(),
		LeftRightBalance:              typedef.LeftRightBalance(vals[30].Uint8()),
		GpsAccuracy:                   vals[31].Uint8(),
		VerticalSpeed:                 vals[32].Int16(),
		Calories:                      vals[33].Uint16(),
		VerticalOscillation:           vals[39].Uint16(),
		StanceTimePercent:             vals[40].Uint16(),
		StanceTime:                    vals[41].Uint16(),
		ActivityType:                  typedef.ActivityType(vals[42].Uint8()),
		LeftTorqueEffectiveness:       vals[43].Uint8(),
		RightTorqueEffectiveness:      vals[44].Uint8(),
		LeftPedalSmoothness:           vals[45].Uint8(),
		RightPedalSmoothness:          vals[46].Uint8(),
		CombinedPedalSmoothness:       vals[47].Uint8(),
		Time128:                       vals[48].Uint8(),
		StrokeType:                    typedef.StrokeType(vals[49].Uint8()),
		Zone:                          vals[50].Uint8(),
		BallSpeed:                     vals[51].Uint16(),
		Cadence256:                    vals[52].Uint16(),
		FractionalCadence:             vals[53].Uint8(),
		TotalHemoglobinConc:           vals[54].Uint16(),
		TotalHemoglobinConcMin:        vals[55].Uint16(),
		TotalHemoglobinConcMax:        vals[56].Uint16(),
		SaturatedHemoglobinPercent:    vals[57].Uint16(),
		SaturatedHemoglobinPercentMin: vals[58].Uint16(),
		SaturatedHemoglobinPercentMax: vals[59].Uint16(),
		DeviceIndex:                   typedef.DeviceIndex(vals[62].Uint8()),
		LeftPco:                       vals[67].Int8(),
		RightPco:                      vals[68].Int8(),
		LeftPowerPhase:                vals[69].SliceUint8(),
		LeftPowerPhasePeak:            vals[70].SliceUint8(),
		RightPowerPhase:               vals[71].SliceUint8(),
		RightPowerPhasePeak:           vals[72].SliceUint8(),
		EnhancedSpeed:                 vals[73].Uint32(),
		EnhancedAltitude:              vals[78].Uint32(),
		BatterySoc:                    vals[81].Uint8(),
		MotorPower:                    vals[82].Uint16(),
		VerticalRatio:                 vals[83].Uint16(),
		StanceTimeBalance:             vals[84].Uint16(),
		StepLength:                    vals[85].Uint16(),
		CycleLength16:                 vals[87].Uint16(),
		AbsolutePressure:              vals[91].Uint32(),
		Depth:                         vals[92].Uint32(),
		NextStopDepth:                 vals[93].Uint32(),
		NextStopTime:                  vals[94].Uint32(),
		TimeToSurface:                 vals[95].Uint32(),
		NdlTime:                       vals[96].Uint32(),
		CnsLoad:                       vals[97].Uint8(),
		N2Load:                        vals[98].Uint16(),
		RespirationRate:               vals[99].Uint8(),
		EnhancedRespirationRate:       vals[108].Uint16(),
		Grit:                          vals[114].Float32(),
		Flow:                          vals[115].Float32(),
		CurrentStress:                 vals[116].Uint16(),
		EbikeTravelRange:              vals[117].Uint16(),
		EbikeBatteryLevel:             vals[118].Uint8(),
		EbikeAssistMode:               vals[119].Uint8(),
		EbikeAssistLevelPercent:       vals[120].Uint8(),
		AirTimeRemaining:              vals[123].Uint32(),
		PressureSac:                   vals[124].Uint16(),
		VolumeSac:                     vals[125].Uint16(),
		Rmv:                           vals[126].Uint16(),
		AscentRate:                    vals[127].Int32(),
		Po2:                           vals[129].Uint8(),
		CoreTemperature:               vals[139].Uint16(),

		state: state,

		UnknownFields:   unknownFields,
		DeveloperFields: developerFields,
	}
}

// ToMesg converts Record into proto.Message. If options is nil, default options will be used.
func (m *Record) ToMesg(options *Options) proto.Message {
	if options == nil {
		options = defaultOptions
	} else if options.Factory == nil {
		options.Factory = factory.StandardFactory()
	}

	fac := options.Factory

	arr := pool.Get().(*[poolsize]proto.Field)
	fields := arr[:0]

	mesg := proto.Message{Num: typedef.MesgNumRecord}

	if !m.Timestamp.Before(datetime.Epoch()) {
		field := fac.CreateField(mesg.Num, 253)
		field.Value = proto.Uint32(uint32(m.Timestamp.Sub(datetime.Epoch()).Seconds()))
		fields = append(fields, field)
	}
	if m.PositionLat != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 0)
		field.Value = proto.Int32(m.PositionLat)
		fields = append(fields, field)
	}
	if m.PositionLong != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 1)
		field.Value = proto.Int32(m.PositionLong)
		fields = append(fields, field)
	}
	if m.Altitude != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 2)
		field.Value = proto.Uint16(m.Altitude)
		fields = append(fields, field)
	}
	if m.HeartRate != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 3)
		field.Value = proto.Uint8(m.HeartRate)
		fields = append(fields, field)
	}
	if m.Cadence != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 4)
		field.Value = proto.Uint8(m.Cadence)
		fields = append(fields, field)
	}
	if m.Distance != basetype.Uint32Invalid {
		if expanded := m.IsExpandedField(5); !expanded || (expanded && options.IncludeExpandedFields) {
			field := fac.CreateField(mesg.Num, 5)
			field.Value = proto.Uint32(m.Distance)
			field.IsExpandedField = expanded
			fields = append(fields, field)
		}
	}
	if m.Speed != basetype.Uint16Invalid {
		if expanded := m.IsExpandedField(6); !expanded || (expanded && options.IncludeExpandedFields) {
			field := fac.CreateField(mesg.Num, 6)
			field.Value = proto.Uint16(m.Speed)
			field.IsExpandedField = expanded
			fields = append(fields, field)
		}
	}
	if m.Power != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 7)
		field.Value = proto.Uint16(m.Power)
		fields = append(fields, field)
	}
	if m.CompressedSpeedDistance != [3]uint8{
		basetype.ByteInvalid,
		basetype.ByteInvalid,
		basetype.ByteInvalid,
	} {
		field := fac.CreateField(mesg.Num, 8)
		copied := m.CompressedSpeedDistance
		field.Value = proto.SliceUint8(copied[:])
		fields = append(fields, field)
	}
	if m.Grade != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 9)
		field.Value = proto.Int16(m.Grade)
		fields = append(fields, field)
	}
	if m.Resistance != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 10)
		field.Value = proto.Uint8(m.Resistance)
		fields = append(fields, field)
	}
	if m.TimeFromCourse != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 11)
		field.Value = proto.Int32(m.TimeFromCourse)
		fields = append(fields, field)
	}
	if m.CycleLength != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 12)
		field.Value = proto.Uint8(m.CycleLength)
		fields = append(fields, field)
	}
	if m.Temperature != basetype.Sint8Invalid {
		field := fac.CreateField(mesg.Num, 13)
		field.Value = proto.Int8(m.Temperature)
		fields = append(fields, field)
	}
	if m.Speed1S != nil {
		field := fac.CreateField(mesg.Num, 17)
		field.Value = proto.SliceUint8(m.Speed1S)
		fields = append(fields, field)
	}
	if m.Cycles != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 18)
		field.Value = proto.Uint8(m.Cycles)
		fields = append(fields, field)
	}
	if m.TotalCycles != basetype.Uint32Invalid {
		if expanded := m.IsExpandedField(19); !expanded || (expanded && options.IncludeExpandedFields) {
			field := fac.CreateField(mesg.Num, 19)
			field.Value = proto.Uint32(m.TotalCycles)
			field.IsExpandedField = expanded
			fields = append(fields, field)
		}
	}
	if m.CompressedAccumulatedPower != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 28)
		field.Value = proto.Uint16(m.CompressedAccumulatedPower)
		fields = append(fields, field)
	}
	if m.AccumulatedPower != basetype.Uint32Invalid {
		if expanded := m.IsExpandedField(29); !expanded || (expanded && options.IncludeExpandedFields) {
			field := fac.CreateField(mesg.Num, 29)
			field.Value = proto.Uint32(m.AccumulatedPower)
			field.IsExpandedField = expanded
			fields = append(fields, field)
		}
	}
	if m.LeftRightBalance != typedef.LeftRightBalanceInvalid {
		field := fac.CreateField(mesg.Num, 30)
		field.Value = proto.Uint8(uint8(m.LeftRightBalance))
		fields = append(fields, field)
	}
	if m.GpsAccuracy != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 31)
		field.Value = proto.Uint8(m.GpsAccuracy)
		fields = append(fields, field)
	}
	if m.VerticalSpeed != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 32)
		field.Value = proto.Int16(m.VerticalSpeed)
		fields = append(fields, field)
	}
	if m.Calories != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 33)
		field.Value = proto.Uint16(m.Calories)
		fields = append(fields, field)
	}
	if m.VerticalOscillation != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 39)
		field.Value = proto.Uint16(m.VerticalOscillation)
		fields = append(fields, field)
	}
	if m.StanceTimePercent != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 40)
		field.Value = proto.Uint16(m.StanceTimePercent)
		fields = append(fields, field)
	}
	if m.StanceTime != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 41)
		field.Value = proto.Uint16(m.StanceTime)
		fields = append(fields, field)
	}
	if m.ActivityType != typedef.ActivityTypeInvalid {
		field := fac.CreateField(mesg.Num, 42)
		field.Value = proto.Uint8(byte(m.ActivityType))
		fields = append(fields, field)
	}
	if m.LeftTorqueEffectiveness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 43)
		field.Value = proto.Uint8(m.LeftTorqueEffectiveness)
		fields = append(fields, field)
	}
	if m.RightTorqueEffectiveness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 44)
		field.Value = proto.Uint8(m.RightTorqueEffectiveness)
		fields = append(fields, field)
	}
	if m.LeftPedalSmoothness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 45)
		field.Value = proto.Uint8(m.LeftPedalSmoothness)
		fields = append(fields, field)
	}
	if m.RightPedalSmoothness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 46)
		field.Value = proto.Uint8(m.RightPedalSmoothness)
		fields = append(fields, field)
	}
	if m.CombinedPedalSmoothness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 47)
		field.Value = proto.Uint8(m.CombinedPedalSmoothness)
		fields = append(fields, field)
	}
	if m.Time128 != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 48)
		field.Value = proto.Uint8(m.Time128)
		fields = append(fields, field)
	}
	if m.StrokeType != typedef.StrokeTypeInvalid {
		field := fac.CreateField(mesg.Num, 49)
		field.Value = proto.Uint8(byte(m.StrokeType))
		fields = append(fields, field)
	}
	if m.Zone != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 50)
		field.Value = proto.Uint8(m.Zone)
		fields = append(fields, field)
	}
	if m.BallSpeed != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 51)
		field.Value = proto.Uint16(m.BallSpeed)
		fields = append(fields, field)
	}
	if m.Cadence256 != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 52)
		field.Value = proto.Uint16(m.Cadence256)
		fields = append(fields, field)
	}
	if m.FractionalCadence != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 53)
		field.Value = proto.Uint8(m.FractionalCadence)
		fields = append(fields, field)
	}
	if m.TotalHemoglobinConc != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 54)
		field.Value = proto.Uint16(m.TotalHemoglobinConc)
		fields = append(fields, field)
	}
	if m.TotalHemoglobinConcMin != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 55)
		field.Value = proto.Uint16(m.TotalHemoglobinConcMin)
		fields = append(fields, field)
	}
	if m.TotalHemoglobinConcMax != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 56)
		field.Value = proto.Uint16(m.TotalHemoglobinConcMax)
		fields = append(fields, field)
	}
	if m.SaturatedHemoglobinPercent != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 57)
		field.Value = proto.Uint16(m.SaturatedHemoglobinPercent)
		fields = append(fields, field)
	}
	if m.SaturatedHemoglobinPercentMin != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 58)
		field.Value = proto.Uint16(m.SaturatedHemoglobinPercentMin)
		fields = append(fields, field)
	}
	if m.SaturatedHemoglobinPercentMax != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 59)
		field.Value = proto.Uint16(m.SaturatedHemoglobinPercentMax)
		fields = append(fields, field)
	}
	if m.DeviceIndex != typedef.DeviceIndexInvalid {
		field := fac.CreateField(mesg.Num, 62)
		field.Value = proto.Uint8(uint8(m.DeviceIndex))
		fields = append(fields, field)
	}
	if m.LeftPco != basetype.Sint8Invalid {
		field := fac.CreateField(mesg.Num, 67)
		field.Value = proto.Int8(m.LeftPco)
		fields = append(fields, field)
	}
	if m.RightPco != basetype.Sint8Invalid {
		field := fac.CreateField(mesg.Num, 68)
		field.Value = proto.Int8(m.RightPco)
		fields = append(fields, field)
	}
	if m.LeftPowerPhase != nil {
		field := fac.CreateField(mesg.Num, 69)
		field.Value = proto.SliceUint8(m.LeftPowerPhase)
		fields = append(fields, field)
	}
	if m.LeftPowerPhasePeak != nil {
		field := fac.CreateField(mesg.Num, 70)
		field.Value = proto.SliceUint8(m.LeftPowerPhasePeak)
		fields = append(fields, field)
	}
	if m.RightPowerPhase != nil {
		field := fac.CreateField(mesg.Num, 71)
		field.Value = proto.SliceUint8(m.RightPowerPhase)
		fields = append(fields, field)
	}
	if m.RightPowerPhasePeak != nil {
		field := fac.CreateField(mesg.Num, 72)
		field.Value = proto.SliceUint8(m.RightPowerPhasePeak)
		fields = append(fields, field)
	}
	if m.EnhancedSpeed != basetype.Uint32Invalid {
		if expanded := m.IsExpandedField(73); !expanded || (expanded && options.IncludeExpandedFields) {
			field := fac.CreateField(mesg.Num, 73)
			field.Value = proto.Uint32(m.EnhancedSpeed)
			field.IsExpandedField = expanded
			fields = append(fields, field)
		}
	}
	if m.EnhancedAltitude != basetype.Uint32Invalid {
		if expanded := m.IsExpandedField(78); !expanded || (expanded && options.IncludeExpandedFields) {
			field := fac.CreateField(mesg.Num, 78)
			field.Value = proto.Uint32(m.EnhancedAltitude)
			field.IsExpandedField = expanded
			fields = append(fields, field)
		}
	}
	if m.BatterySoc != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 81)
		field.Value = proto.Uint8(m.BatterySoc)
		fields = append(fields, field)
	}
	if m.MotorPower != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 82)
		field.Value = proto.Uint16(m.MotorPower)
		fields = append(fields, field)
	}
	if m.VerticalRatio != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 83)
		field.Value = proto.Uint16(m.VerticalRatio)
		fields = append(fields, field)
	}
	if m.StanceTimeBalance != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 84)
		field.Value = proto.Uint16(m.StanceTimeBalance)
		fields = append(fields, field)
	}
	if m.StepLength != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 85)
		field.Value = proto.Uint16(m.StepLength)
		fields = append(fields, field)
	}
	if m.CycleLength16 != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 87)
		field.Value = proto.Uint16(m.CycleLength16)
		fields = append(fields, field)
	}
	if m.AbsolutePressure != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 91)
		field.Value = proto.Uint32(m.AbsolutePressure)
		fields = append(fields, field)
	}
	if m.Depth != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 92)
		field.Value = proto.Uint32(m.Depth)
		fields = append(fields, field)
	}
	if m.NextStopDepth != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 93)
		field.Value = proto.Uint32(m.NextStopDepth)
		fields = append(fields, field)
	}
	if m.NextStopTime != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 94)
		field.Value = proto.Uint32(m.NextStopTime)
		fields = append(fields, field)
	}
	if m.TimeToSurface != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 95)
		field.Value = proto.Uint32(m.TimeToSurface)
		fields = append(fields, field)
	}
	if m.NdlTime != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 96)
		field.Value = proto.Uint32(m.NdlTime)
		fields = append(fields, field)
	}
	if m.CnsLoad != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 97)
		field.Value = proto.Uint8(m.CnsLoad)
		fields = append(fields, field)
	}
	if m.N2Load != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 98)
		field.Value = proto.Uint16(m.N2Load)
		fields = append(fields, field)
	}
	if m.RespirationRate != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 99)
		field.Value = proto.Uint8(m.RespirationRate)
		fields = append(fields, field)
	}
	if m.EnhancedRespirationRate != basetype.Uint16Invalid {
		if expanded := m.IsExpandedField(108); !expanded || (expanded && options.IncludeExpandedFields) {
			field := fac.CreateField(mesg.Num, 108)
			field.Value = proto.Uint16(m.EnhancedRespirationRate)
			field.IsExpandedField = expanded
			fields = append(fields, field)
		}
	}
	if math.Float32bits(m.Grit) != basetype.Float32Invalid {
		field := fac.CreateField(mesg.Num, 114)
		field.Value = proto.Float32(m.Grit)
		fields = append(fields, field)
	}
	if math.Float32bits(m.Flow) != basetype.Float32Invalid {
		field := fac.CreateField(mesg.Num, 115)
		field.Value = proto.Float32(m.Flow)
		fields = append(fields, field)
	}
	if m.CurrentStress != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 116)
		field.Value = proto.Uint16(m.CurrentStress)
		fields = append(fields, field)
	}
	if m.EbikeTravelRange != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 117)
		field.Value = proto.Uint16(m.EbikeTravelRange)
		fields = append(fields, field)
	}
	if m.EbikeBatteryLevel != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 118)
		field.Value = proto.Uint8(m.EbikeBatteryLevel)
		fields = append(fields, field)
	}
	if m.EbikeAssistMode != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 119)
		field.Value = proto.Uint8(m.EbikeAssistMode)
		fields = append(fields, field)
	}
	if m.EbikeAssistLevelPercent != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 120)
		field.Value = proto.Uint8(m.EbikeAssistLevelPercent)
		fields = append(fields, field)
	}
	if m.AirTimeRemaining != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 123)
		field.Value = proto.Uint32(m.AirTimeRemaining)
		fields = append(fields, field)
	}
	if m.PressureSac != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 124)
		field.Value = proto.Uint16(m.PressureSac)
		fields = append(fields, field)
	}
	if m.VolumeSac != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 125)
		field.Value = proto.Uint16(m.VolumeSac)
		fields = append(fields, field)
	}
	if m.Rmv != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 126)
		field.Value = proto.Uint16(m.Rmv)
		fields = append(fields, field)
	}
	if m.AscentRate != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 127)
		field.Value = proto.Int32(m.AscentRate)
		fields = append(fields, field)
	}
	if m.Po2 != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 129)
		field.Value = proto.Uint8(m.Po2)
		fields = append(fields, field)
	}
	if m.CoreTemperature != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 139)
		field.Value = proto.Uint16(m.CoreTemperature)
		fields = append(fields, field)
	}

	for i := range m.UnknownFields {
		fields = append(fields, m.UnknownFields[i])
	}

	mesg.Fields = make([]proto.Field, len(fields))
	copy(mesg.Fields, fields)
	pool.Put(arr)

	mesg.DeveloperFields = m.DeveloperFields

	return mesg
}

// TimestampUint32 returns Timestamp in uint32 (seconds since FIT's epoch) instead of time.Time.
func (m *Record) TimestampUint32() uint32 { return datetime.ToUint32(m.Timestamp) }

// AltitudeScaled return Altitude in its scaled value.
// If Altitude value is invalid, float64 invalid value will be returned.
//
// Scale: 5; Offset: 500; Units: m
func (m *Record) AltitudeScaled() float64 {
	if m.Altitude == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.Altitude)/5 - 500
}

// DistanceScaled return Distance in its scaled value.
// If Distance value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: m
func (m *Record) DistanceScaled() float64 {
	if m.Distance == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.Distance)/100 - 0
}

// SpeedScaled return Speed in its scaled value.
// If Speed value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: m/s
func (m *Record) SpeedScaled() float64 {
	if m.Speed == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.Speed)/1000 - 0
}

// GradeScaled return Grade in its scaled value.
// If Grade value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: %
func (m *Record) GradeScaled() float64 {
	if m.Grade == basetype.Sint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.Grade)/100 - 0
}

// TimeFromCourseScaled return TimeFromCourse in its scaled value.
// If TimeFromCourse value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: s
func (m *Record) TimeFromCourseScaled() float64 {
	if m.TimeFromCourse == basetype.Sint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.TimeFromCourse)/1000 - 0
}

// CycleLengthScaled return CycleLength in its scaled value.
// If CycleLength value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: m
func (m *Record) CycleLengthScaled() float64 {
	if m.CycleLength == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.CycleLength)/100 - 0
}

// Speed1SScaled return Speed1S in its scaled value.
// If Speed1S value is invalid, nil will be returned.
//
// Array: [N]; Scale: 16; Units: m/s; Speed at 1s intervals. Timestamp field indicates time of last array element.
func (m *Record) Speed1SScaled() []float64 {
	if m.Speed1S == nil {
		return nil
	}
	var vals = make([]float64, len(m.Speed1S))
	for i := range m.Speed1S {
		if m.Speed1S[i] == basetype.Uint8Invalid {
			vals[i] = math.Float64frombits(basetype.Float64Invalid)
			continue
		}
		vals[i] = float64(m.Speed1S[i])/16 - 0
	}
	return vals
}

// VerticalSpeedScaled return VerticalSpeed in its scaled value.
// If VerticalSpeed value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: m/s
func (m *Record) VerticalSpeedScaled() float64 {
	if m.VerticalSpeed == basetype.Sint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.VerticalSpeed)/1000 - 0
}

// VerticalOscillationScaled return VerticalOscillation in its scaled value.
// If VerticalOscillation value is invalid, float64 invalid value will be returned.
//
// Scale: 10; Units: mm
func (m *Record) VerticalOscillationScaled() float64 {
	if m.VerticalOscillation == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.VerticalOscillation)/10 - 0
}

// StanceTimePercentScaled return StanceTimePercent in its scaled value.
// If StanceTimePercent value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: percent
func (m *Record) StanceTimePercentScaled() float64 {
	if m.StanceTimePercent == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.StanceTimePercent)/100 - 0
}

// StanceTimeScaled return StanceTime in its scaled value.
// If StanceTime value is invalid, float64 invalid value will be returned.
//
// Scale: 10; Units: ms
func (m *Record) StanceTimeScaled() float64 {
	if m.StanceTime == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.StanceTime)/10 - 0
}

// LeftTorqueEffectivenessScaled return LeftTorqueEffectiveness in its scaled value.
// If LeftTorqueEffectiveness value is invalid, float64 invalid value will be returned.
//
// Scale: 2; Units: percent
func (m *Record) LeftTorqueEffectivenessScaled() float64 {
	if m.LeftTorqueEffectiveness == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.LeftTorqueEffectiveness)/2 - 0
}

// RightTorqueEffectivenessScaled return RightTorqueEffectiveness in its scaled value.
// If RightTorqueEffectiveness value is invalid, float64 invalid value will be returned.
//
// Scale: 2; Units: percent
func (m *Record) RightTorqueEffectivenessScaled() float64 {
	if m.RightTorqueEffectiveness == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.RightTorqueEffectiveness)/2 - 0
}

// LeftPedalSmoothnessScaled return LeftPedalSmoothness in its scaled value.
// If LeftPedalSmoothness value is invalid, float64 invalid value will be returned.
//
// Scale: 2; Units: percent
func (m *Record) LeftPedalSmoothnessScaled() float64 {
	if m.LeftPedalSmoothness == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.LeftPedalSmoothness)/2 - 0
}

// RightPedalSmoothnessScaled return RightPedalSmoothness in its scaled value.
// If RightPedalSmoothness value is invalid, float64 invalid value will be returned.
//
// Scale: 2; Units: percent
func (m *Record) RightPedalSmoothnessScaled() float64 {
	if m.RightPedalSmoothness == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.RightPedalSmoothness)/2 - 0
}

// CombinedPedalSmoothnessScaled return CombinedPedalSmoothness in its scaled value.
// If CombinedPedalSmoothness value is invalid, float64 invalid value will be returned.
//
// Scale: 2; Units: percent
func (m *Record) CombinedPedalSmoothnessScaled() float64 {
	if m.CombinedPedalSmoothness == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.CombinedPedalSmoothness)/2 - 0
}

// Time128Scaled return Time128 in its scaled value.
// If Time128 value is invalid, float64 invalid value will be returned.
//
// Scale: 128; Units: s
func (m *Record) Time128Scaled() float64 {
	if m.Time128 == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.Time128)/128 - 0
}

// BallSpeedScaled return BallSpeed in its scaled value.
// If BallSpeed value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: m/s
func (m *Record) BallSpeedScaled() float64 {
	if m.BallSpeed == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.BallSpeed)/100 - 0
}

// Cadence256Scaled return Cadence256 in its scaled value.
// If Cadence256 value is invalid, float64 invalid value will be returned.
//
// Scale: 256; Units: rpm; Log cadence and fractional cadence for backwards compatibility
func (m *Record) Cadence256Scaled() float64 {
	if m.Cadence256 == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.Cadence256)/256 - 0
}

// FractionalCadenceScaled return FractionalCadence in its scaled value.
// If FractionalCadence value is invalid, float64 invalid value will be returned.
//
// Scale: 128; Units: rpm
func (m *Record) FractionalCadenceScaled() float64 {
	if m.FractionalCadence == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.FractionalCadence)/128 - 0
}

// TotalHemoglobinConcScaled return TotalHemoglobinConc in its scaled value.
// If TotalHemoglobinConc value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: g/dL; Total saturated and unsaturated hemoglobin
func (m *Record) TotalHemoglobinConcScaled() float64 {
	if m.TotalHemoglobinConc == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.TotalHemoglobinConc)/100 - 0
}

// TotalHemoglobinConcMinScaled return TotalHemoglobinConcMin in its scaled value.
// If TotalHemoglobinConcMin value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: g/dL; Min saturated and unsaturated hemoglobin
func (m *Record) TotalHemoglobinConcMinScaled() float64 {
	if m.TotalHemoglobinConcMin == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.TotalHemoglobinConcMin)/100 - 0
}

// TotalHemoglobinConcMaxScaled return TotalHemoglobinConcMax in its scaled value.
// If TotalHemoglobinConcMax value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: g/dL; Max saturated and unsaturated hemoglobin
func (m *Record) TotalHemoglobinConcMaxScaled() float64 {
	if m.TotalHemoglobinConcMax == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.TotalHemoglobinConcMax)/100 - 0
}

// SaturatedHemoglobinPercentScaled return SaturatedHemoglobinPercent in its scaled value.
// If SaturatedHemoglobinPercent value is invalid, float64 invalid value will be returned.
//
// Scale: 10; Units: %; Percentage of hemoglobin saturated with oxygen
func (m *Record) SaturatedHemoglobinPercentScaled() float64 {
	if m.SaturatedHemoglobinPercent == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.SaturatedHemoglobinPercent)/10 - 0
}

// SaturatedHemoglobinPercentMinScaled return SaturatedHemoglobinPercentMin in its scaled value.
// If SaturatedHemoglobinPercentMin value is invalid, float64 invalid value will be returned.
//
// Scale: 10; Units: %; Min percentage of hemoglobin saturated with oxygen
func (m *Record) SaturatedHemoglobinPercentMinScaled() float64 {
	if m.SaturatedHemoglobinPercentMin == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.SaturatedHemoglobinPercentMin)/10 - 0
}

// SaturatedHemoglobinPercentMaxScaled return SaturatedHemoglobinPercentMax in its scaled value.
// If SaturatedHemoglobinPercentMax value is invalid, float64 invalid value will be returned.
//
// Scale: 10; Units: %; Max percentage of hemoglobin saturated with oxygen
func (m *Record) SaturatedHemoglobinPercentMaxScaled() float64 {
	if m.SaturatedHemoglobinPercentMax == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.SaturatedHemoglobinPercentMax)/10 - 0
}

// LeftPowerPhaseScaled return LeftPowerPhase in its scaled value.
// If LeftPowerPhase value is invalid, nil will be returned.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Left power phase angles. Data value indexes defined by power_phase_type.
func (m *Record) LeftPowerPhaseScaled() []float64 {
	if m.LeftPowerPhase == nil {
		return nil
	}
	var vals = make([]float64, len(m.LeftPowerPhase))
	for i := range m.LeftPowerPhase {
		if m.LeftPowerPhase[i] == basetype.Uint8Invalid {
			vals[i] = math.Float64frombits(basetype.Float64Invalid)
			continue
		}
		vals[i] = float64(m.LeftPowerPhase[i])/0.7111111 - 0
	}
	return vals
}

// LeftPowerPhasePeakScaled return LeftPowerPhasePeak in its scaled value.
// If LeftPowerPhasePeak value is invalid, nil will be returned.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Left power phase peak angles. Data value indexes defined by power_phase_type.
func (m *Record) LeftPowerPhasePeakScaled() []float64 {
	if m.LeftPowerPhasePeak == nil {
		return nil
	}
	var vals = make([]float64, len(m.LeftPowerPhasePeak))
	for i := range m.LeftPowerPhasePeak {
		if m.LeftPowerPhasePeak[i] == basetype.Uint8Invalid {
			vals[i] = math.Float64frombits(basetype.Float64Invalid)
			continue
		}
		vals[i] = float64(m.LeftPowerPhasePeak[i])/0.7111111 - 0
	}
	return vals
}

// RightPowerPhaseScaled return RightPowerPhase in its scaled value.
// If RightPowerPhase value is invalid, nil will be returned.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Right power phase angles. Data value indexes defined by power_phase_type.
func (m *Record) RightPowerPhaseScaled() []float64 {
	if m.RightPowerPhase == nil {
		return nil
	}
	var vals = make([]float64, len(m.RightPowerPhase))
	for i := range m.RightPowerPhase {
		if m.RightPowerPhase[i] == basetype.Uint8Invalid {
			vals[i] = math.Float64frombits(basetype.Float64Invalid)
			continue
		}
		vals[i] = float64(m.RightPowerPhase[i])/0.7111111 - 0
	}
	return vals
}

// RightPowerPhasePeakScaled return RightPowerPhasePeak in its scaled value.
// If RightPowerPhasePeak value is invalid, nil will be returned.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Right power phase peak angles. Data value indexes defined by power_phase_type.
func (m *Record) RightPowerPhasePeakScaled() []float64 {
	if m.RightPowerPhasePeak == nil {
		return nil
	}
	var vals = make([]float64, len(m.RightPowerPhasePeak))
	for i := range m.RightPowerPhasePeak {
		if m.RightPowerPhasePeak[i] == basetype.Uint8Invalid {
			vals[i] = math.Float64frombits(basetype.Float64Invalid)
			continue
		}
		vals[i] = float64(m.RightPowerPhasePeak[i])/0.7111111 - 0
	}
	return vals
}

// EnhancedSpeedScaled return EnhancedSpeed in its scaled value.
// If EnhancedSpeed value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: m/s
func (m *Record) EnhancedSpeedScaled() float64 {
	if m.EnhancedSpeed == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.EnhancedSpeed)/1000 - 0
}

// EnhancedAltitudeScaled return EnhancedAltitude in its scaled value.
// If EnhancedAltitude value is invalid, float64 invalid value will be returned.
//
// Scale: 5; Offset: 500; Units: m
func (m *Record) EnhancedAltitudeScaled() float64 {
	if m.EnhancedAltitude == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.EnhancedAltitude)/5 - 500
}

// BatterySocScaled return BatterySoc in its scaled value.
// If BatterySoc value is invalid, float64 invalid value will be returned.
//
// Scale: 2; Units: percent; lev battery state of charge
func (m *Record) BatterySocScaled() float64 {
	if m.BatterySoc == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.BatterySoc)/2 - 0
}

// VerticalRatioScaled return VerticalRatio in its scaled value.
// If VerticalRatio value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: percent
func (m *Record) VerticalRatioScaled() float64 {
	if m.VerticalRatio == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.VerticalRatio)/100 - 0
}

// StanceTimeBalanceScaled return StanceTimeBalance in its scaled value.
// If StanceTimeBalance value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: percent
func (m *Record) StanceTimeBalanceScaled() float64 {
	if m.StanceTimeBalance == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.StanceTimeBalance)/100 - 0
}

// StepLengthScaled return StepLength in its scaled value.
// If StepLength value is invalid, float64 invalid value will be returned.
//
// Scale: 10; Units: mm
func (m *Record) StepLengthScaled() float64 {
	if m.StepLength == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.StepLength)/10 - 0
}

// CycleLength16Scaled return CycleLength16 in its scaled value.
// If CycleLength16 value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: m; Supports larger cycle sizes needed for paddlesports. Max cycle size: 655.35
func (m *Record) CycleLength16Scaled() float64 {
	if m.CycleLength16 == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.CycleLength16)/100 - 0
}

// DepthScaled return Depth in its scaled value.
// If Depth value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: m; 0 if above water
func (m *Record) DepthScaled() float64 {
	if m.Depth == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.Depth)/1000 - 0
}

// NextStopDepthScaled return NextStopDepth in its scaled value.
// If NextStopDepth value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: m; 0 if above water
func (m *Record) NextStopDepthScaled() float64 {
	if m.NextStopDepth == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.NextStopDepth)/1000 - 0
}

// EnhancedRespirationRateScaled return EnhancedRespirationRate in its scaled value.
// If EnhancedRespirationRate value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: Breaths/min
func (m *Record) EnhancedRespirationRateScaled() float64 {
	if m.EnhancedRespirationRate == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.EnhancedRespirationRate)/100 - 0
}

// CurrentStressScaled return CurrentStress in its scaled value.
// If CurrentStress value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Current Stress value
func (m *Record) CurrentStressScaled() float64 {
	if m.CurrentStress == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.CurrentStress)/100 - 0
}

// PressureSacScaled return PressureSac in its scaled value.
// If PressureSac value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: bar/min; Pressure-based surface air consumption
func (m *Record) PressureSacScaled() float64 {
	if m.PressureSac == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.PressureSac)/100 - 0
}

// VolumeSacScaled return VolumeSac in its scaled value.
// If VolumeSac value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: L/min; Volumetric surface air consumption
func (m *Record) VolumeSacScaled() float64 {
	if m.VolumeSac == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.VolumeSac)/100 - 0
}

// RmvScaled return Rmv in its scaled value.
// If Rmv value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: L/min; Respiratory minute volume
func (m *Record) RmvScaled() float64 {
	if m.Rmv == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.Rmv)/100 - 0
}

// AscentRateScaled return AscentRate in its scaled value.
// If AscentRate value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: m/s
func (m *Record) AscentRateScaled() float64 {
	if m.AscentRate == basetype.Sint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AscentRate)/1000 - 0
}

// Po2Scaled return Po2 in its scaled value.
// If Po2 value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: percent; Current partial pressure of oxygen
func (m *Record) Po2Scaled() float64 {
	if m.Po2 == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.Po2)/100 - 0
}

// CoreTemperatureScaled return CoreTemperature in its scaled value.
// If CoreTemperature value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: C
func (m *Record) CoreTemperatureScaled() float64 {
	if m.CoreTemperature == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.CoreTemperature)/100 - 0
}

// PositionLatDegrees returns PositionLat in degrees instead of semicircles.
// If PositionLat value is invalid, float64 invalid value will be returned.
func (m *Record) PositionLatDegrees() float64 {
	return semicircles.ToDegrees(m.PositionLat)
}

// PositionLongDegrees returns PositionLong in degrees instead of semicircles.
// If PositionLong value is invalid, float64 invalid value will be returned.
func (m *Record) PositionLongDegrees() float64 {
	return semicircles.ToDegrees(m.PositionLong)
}

// SetTimestamp sets Timestamp value.
//
// Units: s
func (m *Record) SetTimestamp(v time.Time) *Record {
	m.Timestamp = v
	return m
}

// SetPositionLat sets PositionLat value.
//
// Units: semicircles
func (m *Record) SetPositionLat(v int32) *Record {
	m.PositionLat = v
	return m
}

// SetPositionLatDegrees is similar to SetPositionLat except it accepts a value in degrees.
// This method will automatically convert given degrees value to semicircles (int32) form.
func (m *Record) SetPositionLatDegrees(degrees float64) *Record {
	m.PositionLat = semicircles.ToSemicircles(degrees)
	return m
}

// SetPositionLong sets PositionLong value.
//
// Units: semicircles
func (m *Record) SetPositionLong(v int32) *Record {
	m.PositionLong = v
	return m
}

// SetPositionLongDegrees is similar to SetPositionLong except it accepts a value in degrees.
// This method will automatically convert given degrees value to semicircles (int32) form.
func (m *Record) SetPositionLongDegrees(degrees float64) *Record {
	m.PositionLong = semicircles.ToSemicircles(degrees)
	return m
}

// SetAltitude sets Altitude value.
//
// Scale: 5; Offset: 500; Units: m
func (m *Record) SetAltitude(v uint16) *Record {
	m.Altitude = v
	return m
}

// SetAltitudeScaled is similar to SetAltitude except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 5; Offset: 500; Units: m
func (m *Record) SetAltitudeScaled(v float64) *Record {
	unscaled := (v + 500) * 5
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.Altitude = uint16(basetype.Uint16Invalid)
		return m
	}
	m.Altitude = uint16(unscaled)
	return m
}

// SetHeartRate sets HeartRate value.
//
// Units: bpm
func (m *Record) SetHeartRate(v uint8) *Record {
	m.HeartRate = v
	return m
}

// SetCadence sets Cadence value.
//
// Units: rpm
func (m *Record) SetCadence(v uint8) *Record {
	m.Cadence = v
	return m
}

// SetDistance sets Distance value.
//
// Scale: 100; Units: m
func (m *Record) SetDistance(v uint32) *Record {
	m.Distance = v
	return m
}

// SetDistanceScaled is similar to SetDistance except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 100; Units: m
func (m *Record) SetDistanceScaled(v float64) *Record {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.Distance = uint32(basetype.Uint32Invalid)
		return m
	}
	m.Distance = uint32(unscaled)
	return m
}

// SetSpeed sets Speed value.
//
// Scale: 1000; Units: m/s
func (m *Record) SetSpeed(v uint16) *Record {
	m.Speed = v
	return m
}

// SetSpeedScaled is similar to SetSpeed except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: m/s
func (m *Record) SetSpeedScaled(v float64) *Record {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.Speed = uint16(basetype.Uint16Invalid)
		return m
	}
	m.Speed = uint16(unscaled)
	return m
}

// SetPower sets Power value.
//
// Units: watts
func (m *Record) SetPower(v uint16) *Record {
	m.Power = v
	return m
}

// SetCompressedSpeedDistance sets CompressedSpeedDistance value.
//
// Array: [3]; Units: m/s,m
func (m *Record) SetCompressedSpeedDistance(v [3]byte) *Record {
	m.CompressedSpeedDistance = v
	return m
}

// SetGrade sets Grade value.
//
// Scale: 100; Units: %
func (m *Record) SetGrade(v int16) *Record {
	m.Grade = v
	return m
}

// SetGradeScaled is similar to SetGrade except it accepts a scaled value.
// This method automatically converts the given value to its int16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: %
func (m *Record) SetGradeScaled(v float64) *Record {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Sint16Invalid) {
		m.Grade = int16(basetype.Sint16Invalid)
		return m
	}
	m.Grade = int16(unscaled)
	return m
}

// SetResistance sets Resistance value.
//
// Relative. 0 is none 254 is Max.
func (m *Record) SetResistance(v uint8) *Record {
	m.Resistance = v
	return m
}

// SetTimeFromCourse sets TimeFromCourse value.
//
// Scale: 1000; Units: s
func (m *Record) SetTimeFromCourse(v int32) *Record {
	m.TimeFromCourse = v
	return m
}

// SetTimeFromCourseScaled is similar to SetTimeFromCourse except it accepts a scaled value.
// This method automatically converts the given value to its int32 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: s
func (m *Record) SetTimeFromCourseScaled(v float64) *Record {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Sint32Invalid) {
		m.TimeFromCourse = int32(basetype.Sint32Invalid)
		return m
	}
	m.TimeFromCourse = int32(unscaled)
	return m
}

// SetCycleLength sets CycleLength value.
//
// Scale: 100; Units: m
func (m *Record) SetCycleLength(v uint8) *Record {
	m.CycleLength = v
	return m
}

// SetCycleLengthScaled is similar to SetCycleLength except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 100; Units: m
func (m *Record) SetCycleLengthScaled(v float64) *Record {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.CycleLength = uint8(basetype.Uint8Invalid)
		return m
	}
	m.CycleLength = uint8(unscaled)
	return m
}

// SetTemperature sets Temperature value.
//
// Units: C
func (m *Record) SetTemperature(v int8) *Record {
	m.Temperature = v
	return m
}

// SetSpeed1S sets Speed1S value.
//
// Array: [N]; Scale: 16; Units: m/s; Speed at 1s intervals. Timestamp field indicates time of last array element.
func (m *Record) SetSpeed1S(v []uint8) *Record {
	m.Speed1S = v
	return m
}

// SetSpeed1SScaled is similar to SetSpeed1S except it accepts a scaled value.
// This method automatically converts the given value to its []uint8 form, discarding any applied scale and offset.
//
// Array: [N]; Scale: 16; Units: m/s; Speed at 1s intervals. Timestamp field indicates time of last array element.
func (m *Record) SetSpeed1SScaled(vs []float64) *Record {
	if vs == nil {
		m.Speed1S = nil
		return m
	}
	m.Speed1S = make([]uint8, len(vs))
	for i := range vs {
		unscaled := (vs[i] + 0) * 16
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
			m.Speed1S[i] = uint8(basetype.Uint8Invalid)
			continue
		}
		m.Speed1S[i] = uint8(unscaled)
	}
	return m
}

// SetCycles sets Cycles value.
//
// Units: cycles
func (m *Record) SetCycles(v uint8) *Record {
	m.Cycles = v
	return m
}

// SetTotalCycles sets TotalCycles value.
//
// Units: cycles
func (m *Record) SetTotalCycles(v uint32) *Record {
	m.TotalCycles = v
	return m
}

// SetCompressedAccumulatedPower sets CompressedAccumulatedPower value.
//
// Units: watts
func (m *Record) SetCompressedAccumulatedPower(v uint16) *Record {
	m.CompressedAccumulatedPower = v
	return m
}

// SetAccumulatedPower sets AccumulatedPower value.
//
// Units: watts
func (m *Record) SetAccumulatedPower(v uint32) *Record {
	m.AccumulatedPower = v
	return m
}

// SetLeftRightBalance sets LeftRightBalance value.
func (m *Record) SetLeftRightBalance(v typedef.LeftRightBalance) *Record {
	m.LeftRightBalance = v
	return m
}

// SetGpsAccuracy sets GpsAccuracy value.
//
// Units: m
func (m *Record) SetGpsAccuracy(v uint8) *Record {
	m.GpsAccuracy = v
	return m
}

// SetVerticalSpeed sets VerticalSpeed value.
//
// Scale: 1000; Units: m/s
func (m *Record) SetVerticalSpeed(v int16) *Record {
	m.VerticalSpeed = v
	return m
}

// SetVerticalSpeedScaled is similar to SetVerticalSpeed except it accepts a scaled value.
// This method automatically converts the given value to its int16 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: m/s
func (m *Record) SetVerticalSpeedScaled(v float64) *Record {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Sint16Invalid) {
		m.VerticalSpeed = int16(basetype.Sint16Invalid)
		return m
	}
	m.VerticalSpeed = int16(unscaled)
	return m
}

// SetCalories sets Calories value.
//
// Units: kcal
func (m *Record) SetCalories(v uint16) *Record {
	m.Calories = v
	return m
}

// SetVerticalOscillation sets VerticalOscillation value.
//
// Scale: 10; Units: mm
func (m *Record) SetVerticalOscillation(v uint16) *Record {
	m.VerticalOscillation = v
	return m
}

// SetVerticalOscillationScaled is similar to SetVerticalOscillation except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 10; Units: mm
func (m *Record) SetVerticalOscillationScaled(v float64) *Record {
	unscaled := (v + 0) * 10
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.VerticalOscillation = uint16(basetype.Uint16Invalid)
		return m
	}
	m.VerticalOscillation = uint16(unscaled)
	return m
}

// SetStanceTimePercent sets StanceTimePercent value.
//
// Scale: 100; Units: percent
func (m *Record) SetStanceTimePercent(v uint16) *Record {
	m.StanceTimePercent = v
	return m
}

// SetStanceTimePercentScaled is similar to SetStanceTimePercent except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: percent
func (m *Record) SetStanceTimePercentScaled(v float64) *Record {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.StanceTimePercent = uint16(basetype.Uint16Invalid)
		return m
	}
	m.StanceTimePercent = uint16(unscaled)
	return m
}

// SetStanceTime sets StanceTime value.
//
// Scale: 10; Units: ms
func (m *Record) SetStanceTime(v uint16) *Record {
	m.StanceTime = v
	return m
}

// SetStanceTimeScaled is similar to SetStanceTime except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 10; Units: ms
func (m *Record) SetStanceTimeScaled(v float64) *Record {
	unscaled := (v + 0) * 10
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.StanceTime = uint16(basetype.Uint16Invalid)
		return m
	}
	m.StanceTime = uint16(unscaled)
	return m
}

// SetActivityType sets ActivityType value.
func (m *Record) SetActivityType(v typedef.ActivityType) *Record {
	m.ActivityType = v
	return m
}

// SetLeftTorqueEffectiveness sets LeftTorqueEffectiveness value.
//
// Scale: 2; Units: percent
func (m *Record) SetLeftTorqueEffectiveness(v uint8) *Record {
	m.LeftTorqueEffectiveness = v
	return m
}

// SetLeftTorqueEffectivenessScaled is similar to SetLeftTorqueEffectiveness except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 2; Units: percent
func (m *Record) SetLeftTorqueEffectivenessScaled(v float64) *Record {
	unscaled := (v + 0) * 2
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.LeftTorqueEffectiveness = uint8(basetype.Uint8Invalid)
		return m
	}
	m.LeftTorqueEffectiveness = uint8(unscaled)
	return m
}

// SetRightTorqueEffectiveness sets RightTorqueEffectiveness value.
//
// Scale: 2; Units: percent
func (m *Record) SetRightTorqueEffectiveness(v uint8) *Record {
	m.RightTorqueEffectiveness = v
	return m
}

// SetRightTorqueEffectivenessScaled is similar to SetRightTorqueEffectiveness except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 2; Units: percent
func (m *Record) SetRightTorqueEffectivenessScaled(v float64) *Record {
	unscaled := (v + 0) * 2
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.RightTorqueEffectiveness = uint8(basetype.Uint8Invalid)
		return m
	}
	m.RightTorqueEffectiveness = uint8(unscaled)
	return m
}

// SetLeftPedalSmoothness sets LeftPedalSmoothness value.
//
// Scale: 2; Units: percent
func (m *Record) SetLeftPedalSmoothness(v uint8) *Record {
	m.LeftPedalSmoothness = v
	return m
}

// SetLeftPedalSmoothnessScaled is similar to SetLeftPedalSmoothness except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 2; Units: percent
func (m *Record) SetLeftPedalSmoothnessScaled(v float64) *Record {
	unscaled := (v + 0) * 2
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.LeftPedalSmoothness = uint8(basetype.Uint8Invalid)
		return m
	}
	m.LeftPedalSmoothness = uint8(unscaled)
	return m
}

// SetRightPedalSmoothness sets RightPedalSmoothness value.
//
// Scale: 2; Units: percent
func (m *Record) SetRightPedalSmoothness(v uint8) *Record {
	m.RightPedalSmoothness = v
	return m
}

// SetRightPedalSmoothnessScaled is similar to SetRightPedalSmoothness except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 2; Units: percent
func (m *Record) SetRightPedalSmoothnessScaled(v float64) *Record {
	unscaled := (v + 0) * 2
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.RightPedalSmoothness = uint8(basetype.Uint8Invalid)
		return m
	}
	m.RightPedalSmoothness = uint8(unscaled)
	return m
}

// SetCombinedPedalSmoothness sets CombinedPedalSmoothness value.
//
// Scale: 2; Units: percent
func (m *Record) SetCombinedPedalSmoothness(v uint8) *Record {
	m.CombinedPedalSmoothness = v
	return m
}

// SetCombinedPedalSmoothnessScaled is similar to SetCombinedPedalSmoothness except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 2; Units: percent
func (m *Record) SetCombinedPedalSmoothnessScaled(v float64) *Record {
	unscaled := (v + 0) * 2
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.CombinedPedalSmoothness = uint8(basetype.Uint8Invalid)
		return m
	}
	m.CombinedPedalSmoothness = uint8(unscaled)
	return m
}

// SetTime128 sets Time128 value.
//
// Scale: 128; Units: s
func (m *Record) SetTime128(v uint8) *Record {
	m.Time128 = v
	return m
}

// SetTime128Scaled is similar to SetTime128 except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 128; Units: s
func (m *Record) SetTime128Scaled(v float64) *Record {
	unscaled := (v + 0) * 128
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.Time128 = uint8(basetype.Uint8Invalid)
		return m
	}
	m.Time128 = uint8(unscaled)
	return m
}

// SetStrokeType sets StrokeType value.
func (m *Record) SetStrokeType(v typedef.StrokeType) *Record {
	m.StrokeType = v
	return m
}

// SetZone sets Zone value.
func (m *Record) SetZone(v uint8) *Record {
	m.Zone = v
	return m
}

// SetBallSpeed sets BallSpeed value.
//
// Scale: 100; Units: m/s
func (m *Record) SetBallSpeed(v uint16) *Record {
	m.BallSpeed = v
	return m
}

// SetBallSpeedScaled is similar to SetBallSpeed except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: m/s
func (m *Record) SetBallSpeedScaled(v float64) *Record {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.BallSpeed = uint16(basetype.Uint16Invalid)
		return m
	}
	m.BallSpeed = uint16(unscaled)
	return m
}

// SetCadence256 sets Cadence256 value.
//
// Scale: 256; Units: rpm; Log cadence and fractional cadence for backwards compatibility
func (m *Record) SetCadence256(v uint16) *Record {
	m.Cadence256 = v
	return m
}

// SetCadence256Scaled is similar to SetCadence256 except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 256; Units: rpm; Log cadence and fractional cadence for backwards compatibility
func (m *Record) SetCadence256Scaled(v float64) *Record {
	unscaled := (v + 0) * 256
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.Cadence256 = uint16(basetype.Uint16Invalid)
		return m
	}
	m.Cadence256 = uint16(unscaled)
	return m
}

// SetFractionalCadence sets FractionalCadence value.
//
// Scale: 128; Units: rpm
func (m *Record) SetFractionalCadence(v uint8) *Record {
	m.FractionalCadence = v
	return m
}

// SetFractionalCadenceScaled is similar to SetFractionalCadence except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 128; Units: rpm
func (m *Record) SetFractionalCadenceScaled(v float64) *Record {
	unscaled := (v + 0) * 128
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.FractionalCadence = uint8(basetype.Uint8Invalid)
		return m
	}
	m.FractionalCadence = uint8(unscaled)
	return m
}

// SetTotalHemoglobinConc sets TotalHemoglobinConc value.
//
// Scale: 100; Units: g/dL; Total saturated and unsaturated hemoglobin
func (m *Record) SetTotalHemoglobinConc(v uint16) *Record {
	m.TotalHemoglobinConc = v
	return m
}

// SetTotalHemoglobinConcScaled is similar to SetTotalHemoglobinConc except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: g/dL; Total saturated and unsaturated hemoglobin
func (m *Record) SetTotalHemoglobinConcScaled(v float64) *Record {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.TotalHemoglobinConc = uint16(basetype.Uint16Invalid)
		return m
	}
	m.TotalHemoglobinConc = uint16(unscaled)
	return m
}

// SetTotalHemoglobinConcMin sets TotalHemoglobinConcMin value.
//
// Scale: 100; Units: g/dL; Min saturated and unsaturated hemoglobin
func (m *Record) SetTotalHemoglobinConcMin(v uint16) *Record {
	m.TotalHemoglobinConcMin = v
	return m
}

// SetTotalHemoglobinConcMinScaled is similar to SetTotalHemoglobinConcMin except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: g/dL; Min saturated and unsaturated hemoglobin
func (m *Record) SetTotalHemoglobinConcMinScaled(v float64) *Record {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.TotalHemoglobinConcMin = uint16(basetype.Uint16Invalid)
		return m
	}
	m.TotalHemoglobinConcMin = uint16(unscaled)
	return m
}

// SetTotalHemoglobinConcMax sets TotalHemoglobinConcMax value.
//
// Scale: 100; Units: g/dL; Max saturated and unsaturated hemoglobin
func (m *Record) SetTotalHemoglobinConcMax(v uint16) *Record {
	m.TotalHemoglobinConcMax = v
	return m
}

// SetTotalHemoglobinConcMaxScaled is similar to SetTotalHemoglobinConcMax except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: g/dL; Max saturated and unsaturated hemoglobin
func (m *Record) SetTotalHemoglobinConcMaxScaled(v float64) *Record {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.TotalHemoglobinConcMax = uint16(basetype.Uint16Invalid)
		return m
	}
	m.TotalHemoglobinConcMax = uint16(unscaled)
	return m
}

// SetSaturatedHemoglobinPercent sets SaturatedHemoglobinPercent value.
//
// Scale: 10; Units: %; Percentage of hemoglobin saturated with oxygen
func (m *Record) SetSaturatedHemoglobinPercent(v uint16) *Record {
	m.SaturatedHemoglobinPercent = v
	return m
}

// SetSaturatedHemoglobinPercentScaled is similar to SetSaturatedHemoglobinPercent except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 10; Units: %; Percentage of hemoglobin saturated with oxygen
func (m *Record) SetSaturatedHemoglobinPercentScaled(v float64) *Record {
	unscaled := (v + 0) * 10
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.SaturatedHemoglobinPercent = uint16(basetype.Uint16Invalid)
		return m
	}
	m.SaturatedHemoglobinPercent = uint16(unscaled)
	return m
}

// SetSaturatedHemoglobinPercentMin sets SaturatedHemoglobinPercentMin value.
//
// Scale: 10; Units: %; Min percentage of hemoglobin saturated with oxygen
func (m *Record) SetSaturatedHemoglobinPercentMin(v uint16) *Record {
	m.SaturatedHemoglobinPercentMin = v
	return m
}

// SetSaturatedHemoglobinPercentMinScaled is similar to SetSaturatedHemoglobinPercentMin except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 10; Units: %; Min percentage of hemoglobin saturated with oxygen
func (m *Record) SetSaturatedHemoglobinPercentMinScaled(v float64) *Record {
	unscaled := (v + 0) * 10
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.SaturatedHemoglobinPercentMin = uint16(basetype.Uint16Invalid)
		return m
	}
	m.SaturatedHemoglobinPercentMin = uint16(unscaled)
	return m
}

// SetSaturatedHemoglobinPercentMax sets SaturatedHemoglobinPercentMax value.
//
// Scale: 10; Units: %; Max percentage of hemoglobin saturated with oxygen
func (m *Record) SetSaturatedHemoglobinPercentMax(v uint16) *Record {
	m.SaturatedHemoglobinPercentMax = v
	return m
}

// SetSaturatedHemoglobinPercentMaxScaled is similar to SetSaturatedHemoglobinPercentMax except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 10; Units: %; Max percentage of hemoglobin saturated with oxygen
func (m *Record) SetSaturatedHemoglobinPercentMaxScaled(v float64) *Record {
	unscaled := (v + 0) * 10
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.SaturatedHemoglobinPercentMax = uint16(basetype.Uint16Invalid)
		return m
	}
	m.SaturatedHemoglobinPercentMax = uint16(unscaled)
	return m
}

// SetDeviceIndex sets DeviceIndex value.
func (m *Record) SetDeviceIndex(v typedef.DeviceIndex) *Record {
	m.DeviceIndex = v
	return m
}

// SetLeftPco sets LeftPco value.
//
// Units: mm; Left platform center offset
func (m *Record) SetLeftPco(v int8) *Record {
	m.LeftPco = v
	return m
}

// SetRightPco sets RightPco value.
//
// Units: mm; Right platform center offset
func (m *Record) SetRightPco(v int8) *Record {
	m.RightPco = v
	return m
}

// SetLeftPowerPhase sets LeftPowerPhase value.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Left power phase angles. Data value indexes defined by power_phase_type.
func (m *Record) SetLeftPowerPhase(v []uint8) *Record {
	m.LeftPowerPhase = v
	return m
}

// SetLeftPowerPhaseScaled is similar to SetLeftPowerPhase except it accepts a scaled value.
// This method automatically converts the given value to its []uint8 form, discarding any applied scale and offset.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Left power phase angles. Data value indexes defined by power_phase_type.
func (m *Record) SetLeftPowerPhaseScaled(vs []float64) *Record {
	if vs == nil {
		m.LeftPowerPhase = nil
		return m
	}
	m.LeftPowerPhase = make([]uint8, len(vs))
	for i := range vs {
		unscaled := (vs[i] + 0) * 0.7111111
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
			m.LeftPowerPhase[i] = uint8(basetype.Uint8Invalid)
			continue
		}
		m.LeftPowerPhase[i] = uint8(unscaled)
	}
	return m
}

// SetLeftPowerPhasePeak sets LeftPowerPhasePeak value.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Left power phase peak angles. Data value indexes defined by power_phase_type.
func (m *Record) SetLeftPowerPhasePeak(v []uint8) *Record {
	m.LeftPowerPhasePeak = v
	return m
}

// SetLeftPowerPhasePeakScaled is similar to SetLeftPowerPhasePeak except it accepts a scaled value.
// This method automatically converts the given value to its []uint8 form, discarding any applied scale and offset.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Left power phase peak angles. Data value indexes defined by power_phase_type.
func (m *Record) SetLeftPowerPhasePeakScaled(vs []float64) *Record {
	if vs == nil {
		m.LeftPowerPhasePeak = nil
		return m
	}
	m.LeftPowerPhasePeak = make([]uint8, len(vs))
	for i := range vs {
		unscaled := (vs[i] + 0) * 0.7111111
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
			m.LeftPowerPhasePeak[i] = uint8(basetype.Uint8Invalid)
			continue
		}
		m.LeftPowerPhasePeak[i] = uint8(unscaled)
	}
	return m
}

// SetRightPowerPhase sets RightPowerPhase value.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Right power phase angles. Data value indexes defined by power_phase_type.
func (m *Record) SetRightPowerPhase(v []uint8) *Record {
	m.RightPowerPhase = v
	return m
}

// SetRightPowerPhaseScaled is similar to SetRightPowerPhase except it accepts a scaled value.
// This method automatically converts the given value to its []uint8 form, discarding any applied scale and offset.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Right power phase angles. Data value indexes defined by power_phase_type.
func (m *Record) SetRightPowerPhaseScaled(vs []float64) *Record {
	if vs == nil {
		m.RightPowerPhase = nil
		return m
	}
	m.RightPowerPhase = make([]uint8, len(vs))
	for i := range vs {
		unscaled := (vs[i] + 0) * 0.7111111
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
			m.RightPowerPhase[i] = uint8(basetype.Uint8Invalid)
			continue
		}
		m.RightPowerPhase[i] = uint8(unscaled)
	}
	return m
}

// SetRightPowerPhasePeak sets RightPowerPhasePeak value.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Right power phase peak angles. Data value indexes defined by power_phase_type.
func (m *Record) SetRightPowerPhasePeak(v []uint8) *Record {
	m.RightPowerPhasePeak = v
	return m
}

// SetRightPowerPhasePeakScaled is similar to SetRightPowerPhasePeak except it accepts a scaled value.
// This method automatically converts the given value to its []uint8 form, discarding any applied scale and offset.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Right power phase peak angles. Data value indexes defined by power_phase_type.
func (m *Record) SetRightPowerPhasePeakScaled(vs []float64) *Record {
	if vs == nil {
		m.RightPowerPhasePeak = nil
		return m
	}
	m.RightPowerPhasePeak = make([]uint8, len(vs))
	for i := range vs {
		unscaled := (vs[i] + 0) * 0.7111111
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
			m.RightPowerPhasePeak[i] = uint8(basetype.Uint8Invalid)
			continue
		}
		m.RightPowerPhasePeak[i] = uint8(unscaled)
	}
	return m
}

// SetEnhancedSpeed sets EnhancedSpeed value.
//
// Scale: 1000; Units: m/s
func (m *Record) SetEnhancedSpeed(v uint32) *Record {
	m.EnhancedSpeed = v
	return m
}

// SetEnhancedSpeedScaled is similar to SetEnhancedSpeed except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: m/s
func (m *Record) SetEnhancedSpeedScaled(v float64) *Record {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.EnhancedSpeed = uint32(basetype.Uint32Invalid)
		return m
	}
	m.EnhancedSpeed = uint32(unscaled)
	return m
}

// SetEnhancedAltitude sets EnhancedAltitude value.
//
// Scale: 5; Offset: 500; Units: m
func (m *Record) SetEnhancedAltitude(v uint32) *Record {
	m.EnhancedAltitude = v
	return m
}

// SetEnhancedAltitudeScaled is similar to SetEnhancedAltitude except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 5; Offset: 500; Units: m
func (m *Record) SetEnhancedAltitudeScaled(v float64) *Record {
	unscaled := (v + 500) * 5
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.EnhancedAltitude = uint32(basetype.Uint32Invalid)
		return m
	}
	m.EnhancedAltitude = uint32(unscaled)
	return m
}

// SetBatterySoc sets BatterySoc value.
//
// Scale: 2; Units: percent; lev battery state of charge
func (m *Record) SetBatterySoc(v uint8) *Record {
	m.BatterySoc = v
	return m
}

// SetBatterySocScaled is similar to SetBatterySoc except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 2; Units: percent; lev battery state of charge
func (m *Record) SetBatterySocScaled(v float64) *Record {
	unscaled := (v + 0) * 2
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.BatterySoc = uint8(basetype.Uint8Invalid)
		return m
	}
	m.BatterySoc = uint8(unscaled)
	return m
}

// SetMotorPower sets MotorPower value.
//
// Units: watts; lev motor power
func (m *Record) SetMotorPower(v uint16) *Record {
	m.MotorPower = v
	return m
}

// SetVerticalRatio sets VerticalRatio value.
//
// Scale: 100; Units: percent
func (m *Record) SetVerticalRatio(v uint16) *Record {
	m.VerticalRatio = v
	return m
}

// SetVerticalRatioScaled is similar to SetVerticalRatio except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: percent
func (m *Record) SetVerticalRatioScaled(v float64) *Record {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.VerticalRatio = uint16(basetype.Uint16Invalid)
		return m
	}
	m.VerticalRatio = uint16(unscaled)
	return m
}

// SetStanceTimeBalance sets StanceTimeBalance value.
//
// Scale: 100; Units: percent
func (m *Record) SetStanceTimeBalance(v uint16) *Record {
	m.StanceTimeBalance = v
	return m
}

// SetStanceTimeBalanceScaled is similar to SetStanceTimeBalance except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: percent
func (m *Record) SetStanceTimeBalanceScaled(v float64) *Record {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.StanceTimeBalance = uint16(basetype.Uint16Invalid)
		return m
	}
	m.StanceTimeBalance = uint16(unscaled)
	return m
}

// SetStepLength sets StepLength value.
//
// Scale: 10; Units: mm
func (m *Record) SetStepLength(v uint16) *Record {
	m.StepLength = v
	return m
}

// SetStepLengthScaled is similar to SetStepLength except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 10; Units: mm
func (m *Record) SetStepLengthScaled(v float64) *Record {
	unscaled := (v + 0) * 10
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.StepLength = uint16(basetype.Uint16Invalid)
		return m
	}
	m.StepLength = uint16(unscaled)
	return m
}

// SetCycleLength16 sets CycleLength16 value.
//
// Scale: 100; Units: m; Supports larger cycle sizes needed for paddlesports. Max cycle size: 655.35
func (m *Record) SetCycleLength16(v uint16) *Record {
	m.CycleLength16 = v
	return m
}

// SetCycleLength16Scaled is similar to SetCycleLength16 except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: m; Supports larger cycle sizes needed for paddlesports. Max cycle size: 655.35
func (m *Record) SetCycleLength16Scaled(v float64) *Record {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.CycleLength16 = uint16(basetype.Uint16Invalid)
		return m
	}
	m.CycleLength16 = uint16(unscaled)
	return m
}

// SetAbsolutePressure sets AbsolutePressure value.
//
// Units: Pa; Includes atmospheric pressure
func (m *Record) SetAbsolutePressure(v uint32) *Record {
	m.AbsolutePressure = v
	return m
}

// SetDepth sets Depth value.
//
// Scale: 1000; Units: m; 0 if above water
func (m *Record) SetDepth(v uint32) *Record {
	m.Depth = v
	return m
}

// SetDepthScaled is similar to SetDepth except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: m; 0 if above water
func (m *Record) SetDepthScaled(v float64) *Record {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.Depth = uint32(basetype.Uint32Invalid)
		return m
	}
	m.Depth = uint32(unscaled)
	return m
}

// SetNextStopDepth sets NextStopDepth value.
//
// Scale: 1000; Units: m; 0 if above water
func (m *Record) SetNextStopDepth(v uint32) *Record {
	m.NextStopDepth = v
	return m
}

// SetNextStopDepthScaled is similar to SetNextStopDepth except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: m; 0 if above water
func (m *Record) SetNextStopDepthScaled(v float64) *Record {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.NextStopDepth = uint32(basetype.Uint32Invalid)
		return m
	}
	m.NextStopDepth = uint32(unscaled)
	return m
}

// SetNextStopTime sets NextStopTime value.
//
// Units: s
func (m *Record) SetNextStopTime(v uint32) *Record {
	m.NextStopTime = v
	return m
}

// SetTimeToSurface sets TimeToSurface value.
//
// Units: s
func (m *Record) SetTimeToSurface(v uint32) *Record {
	m.TimeToSurface = v
	return m
}

// SetNdlTime sets NdlTime value.
//
// Units: s
func (m *Record) SetNdlTime(v uint32) *Record {
	m.NdlTime = v
	return m
}

// SetCnsLoad sets CnsLoad value.
//
// Units: percent
func (m *Record) SetCnsLoad(v uint8) *Record {
	m.CnsLoad = v
	return m
}

// SetN2Load sets N2Load value.
//
// Units: percent
func (m *Record) SetN2Load(v uint16) *Record {
	m.N2Load = v
	return m
}

// SetRespirationRate sets RespirationRate value.
//
// Units: s
func (m *Record) SetRespirationRate(v uint8) *Record {
	m.RespirationRate = v
	return m
}

// SetEnhancedRespirationRate sets EnhancedRespirationRate value.
//
// Scale: 100; Units: Breaths/min
func (m *Record) SetEnhancedRespirationRate(v uint16) *Record {
	m.EnhancedRespirationRate = v
	return m
}

// SetEnhancedRespirationRateScaled is similar to SetEnhancedRespirationRate except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: Breaths/min
func (m *Record) SetEnhancedRespirationRateScaled(v float64) *Record {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.EnhancedRespirationRate = uint16(basetype.Uint16Invalid)
		return m
	}
	m.EnhancedRespirationRate = uint16(unscaled)
	return m
}

// SetGrit sets Grit value.
//
// The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes.
func (m *Record) SetGrit(v float32) *Record {
	m.Grit = v
	return m
}

// SetFlow sets Flow value.
//
// The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals.
func (m *Record) SetFlow(v float32) *Record {
	m.Flow = v
	return m
}

// SetCurrentStress sets CurrentStress value.
//
// Scale: 100; Current Stress value
func (m *Record) SetCurrentStress(v uint16) *Record {
	m.CurrentStress = v
	return m
}

// SetCurrentStressScaled is similar to SetCurrentStress except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 100; Current Stress value
func (m *Record) SetCurrentStressScaled(v float64) *Record {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.CurrentStress = uint16(basetype.Uint16Invalid)
		return m
	}
	m.CurrentStress = uint16(unscaled)
	return m
}

// SetEbikeTravelRange sets EbikeTravelRange value.
//
// Units: km
func (m *Record) SetEbikeTravelRange(v uint16) *Record {
	m.EbikeTravelRange = v
	return m
}

// SetEbikeBatteryLevel sets EbikeBatteryLevel value.
//
// Units: percent
func (m *Record) SetEbikeBatteryLevel(v uint8) *Record {
	m.EbikeBatteryLevel = v
	return m
}

// SetEbikeAssistMode sets EbikeAssistMode value.
//
// Units: depends on sensor
func (m *Record) SetEbikeAssistMode(v uint8) *Record {
	m.EbikeAssistMode = v
	return m
}

// SetEbikeAssistLevelPercent sets EbikeAssistLevelPercent value.
//
// Units: percent
func (m *Record) SetEbikeAssistLevelPercent(v uint8) *Record {
	m.EbikeAssistLevelPercent = v
	return m
}

// SetAirTimeRemaining sets AirTimeRemaining value.
//
// Units: s
func (m *Record) SetAirTimeRemaining(v uint32) *Record {
	m.AirTimeRemaining = v
	return m
}

// SetPressureSac sets PressureSac value.
//
// Scale: 100; Units: bar/min; Pressure-based surface air consumption
func (m *Record) SetPressureSac(v uint16) *Record {
	m.PressureSac = v
	return m
}

// SetPressureSacScaled is similar to SetPressureSac except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: bar/min; Pressure-based surface air consumption
func (m *Record) SetPressureSacScaled(v float64) *Record {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.PressureSac = uint16(basetype.Uint16Invalid)
		return m
	}
	m.PressureSac = uint16(unscaled)
	return m
}

// SetVolumeSac sets VolumeSac value.
//
// Scale: 100; Units: L/min; Volumetric surface air consumption
func (m *Record) SetVolumeSac(v uint16) *Record {
	m.VolumeSac = v
	return m
}

// SetVolumeSacScaled is similar to SetVolumeSac except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: L/min; Volumetric surface air consumption
func (m *Record) SetVolumeSacScaled(v float64) *Record {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.VolumeSac = uint16(basetype.Uint16Invalid)
		return m
	}
	m.VolumeSac = uint16(unscaled)
	return m
}

// SetRmv sets Rmv value.
//
// Scale: 100; Units: L/min; Respiratory minute volume
func (m *Record) SetRmv(v uint16) *Record {
	m.Rmv = v
	return m
}

// SetRmvScaled is similar to SetRmv except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: L/min; Respiratory minute volume
func (m *Record) SetRmvScaled(v float64) *Record {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.Rmv = uint16(basetype.Uint16Invalid)
		return m
	}
	m.Rmv = uint16(unscaled)
	return m
}

// SetAscentRate sets AscentRate value.
//
// Scale: 1000; Units: m/s
func (m *Record) SetAscentRate(v int32) *Record {
	m.AscentRate = v
	return m
}

// SetAscentRateScaled is similar to SetAscentRate except it accepts a scaled value.
// This method automatically converts the given value to its int32 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: m/s
func (m *Record) SetAscentRateScaled(v float64) *Record {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Sint32Invalid) {
		m.AscentRate = int32(basetype.Sint32Invalid)
		return m
	}
	m.AscentRate = int32(unscaled)
	return m
}

// SetPo2 sets Po2 value.
//
// Scale: 100; Units: percent; Current partial pressure of oxygen
func (m *Record) SetPo2(v uint8) *Record {
	m.Po2 = v
	return m
}

// SetPo2Scaled is similar to SetPo2 except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 100; Units: percent; Current partial pressure of oxygen
func (m *Record) SetPo2Scaled(v float64) *Record {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.Po2 = uint8(basetype.Uint8Invalid)
		return m
	}
	m.Po2 = uint8(unscaled)
	return m
}

// SetCoreTemperature sets CoreTemperature value.
//
// Scale: 100; Units: C
func (m *Record) SetCoreTemperature(v uint16) *Record {
	m.CoreTemperature = v
	return m
}

// SetCoreTemperatureScaled is similar to SetCoreTemperature except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: C
func (m *Record) SetCoreTemperatureScaled(v float64) *Record {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.CoreTemperature = uint16(basetype.Uint16Invalid)
		return m
	}
	m.CoreTemperature = uint16(unscaled)
	return m
}

// SetDeveloperFields Record's UnknownFields (fields that are exist but they are not defined in Profile.xlsx)
func (m *Record) SetUnknownFields(unknownFields ...proto.Field) *Record {
	m.UnknownFields = unknownFields
	return m
}

// SetDeveloperFields Record's DeveloperFields.
func (m *Record) SetDeveloperFields(developerFields ...proto.DeveloperField) *Record {
	m.DeveloperFields = developerFields
	return m
}

// MarkAsExpandedField marks whether given fieldNum is an expanded field (field that being
// generated through a component expansion). Eligible for field number: 5, 6, 19, 29, 73, 78, 108.
func (m *Record) MarkAsExpandedField(fieldNum byte, flag bool) (ok bool) {
	switch fieldNum {
	case 5, 6, 19, 29, 73, 78, 108:
	default:
		return false
	}
	pos := fieldNum / 8
	bit := uint8(1) << (fieldNum - (8 * pos))
	m.state[pos] &^= bit
	if flag {
		m.state[pos] |= bit
	}
	return true
}

// IsExpandedField checks whether given fieldNum is a field generated through
// a component expansion. Eligible for field number: 5, 6, 19, 29, 73, 78, 108.
func (m *Record) IsExpandedField(fieldNum byte) bool {
	if fieldNum >= 109 {
		return false
	}
	pos := fieldNum / 8
	bit := uint8(1) << (fieldNum - (8 * pos))
	return m.state[pos]&bit == bit
}
