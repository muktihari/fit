// Code generated by internal/cmd/fitgen/main.go. DO NOT EDIT.
// SDK Version: 21.126

// Copyright 2023 The Fit SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package mesgdef

import (
	"github.com/muktihari/fit/kit/typeconv"
	"github.com/muktihari/fit/profile/basetype"
	"github.com/muktihari/fit/profile/typedef"
	"github.com/muktihari/fit/proto"
)

// Record is a Record message.
type Record struct {
	Timestamp                     typedef.DateTime // Units: s;
	PositionLat                   int32            // Units: semicircles;
	PositionLong                  int32            // Units: semicircles;
	Altitude                      uint16           // Scale: 5; Offset: 500; Units: m;
	HeartRate                     uint8            // Units: bpm;
	Cadence                       uint8            // Units: rpm;
	Distance                      uint32           // Scale: 100; Units: m;
	Speed                         uint16           // Scale: 1000; Units: m/s;
	Power                         uint16           // Units: watts;
	CompressedSpeedDistance       []byte           // Scale: 100; Array: [3]; Units: m/s,m;
	Grade                         int16            // Scale: 100; Units: %;
	Resistance                    uint8            // Relative. 0 is none 254 is Max.
	TimeFromCourse                int32            // Scale: 1000; Units: s;
	CycleLength                   uint8            // Scale: 100; Units: m;
	Temperature                   int8             // Units: C;
	Speed1S                       []uint8          // Scale: 16; Array: [N]; Units: m/s; Speed at 1s intervals. Timestamp field indicates time of last array element.
	Cycles                        uint8            // Units: cycles;
	TotalCycles                   uint32           // Units: cycles;
	CompressedAccumulatedPower    uint16           // Units: watts;
	AccumulatedPower              uint32           // Units: watts;
	LeftRightBalance              typedef.LeftRightBalance
	GpsAccuracy                   uint8  // Units: m;
	VerticalSpeed                 int16  // Scale: 1000; Units: m/s;
	Calories                      uint16 // Units: kcal;
	VerticalOscillation           uint16 // Scale: 10; Units: mm;
	StanceTimePercent             uint16 // Scale: 100; Units: percent;
	StanceTime                    uint16 // Scale: 10; Units: ms;
	ActivityType                  typedef.ActivityType
	LeftTorqueEffectiveness       uint8 // Scale: 2; Units: percent;
	RightTorqueEffectiveness      uint8 // Scale: 2; Units: percent;
	LeftPedalSmoothness           uint8 // Scale: 2; Units: percent;
	RightPedalSmoothness          uint8 // Scale: 2; Units: percent;
	CombinedPedalSmoothness       uint8 // Scale: 2; Units: percent;
	Time128                       uint8 // Scale: 128; Units: s;
	StrokeType                    typedef.StrokeType
	Zone                          uint8
	BallSpeed                     uint16 // Scale: 100; Units: m/s;
	Cadence256                    uint16 // Scale: 256; Units: rpm; Log cadence and fractional cadence for backwards compatability
	FractionalCadence             uint8  // Scale: 128; Units: rpm;
	TotalHemoglobinConc           uint16 // Scale: 100; Units: g/dL; Total saturated and unsaturated hemoglobin
	TotalHemoglobinConcMin        uint16 // Scale: 100; Units: g/dL; Min saturated and unsaturated hemoglobin
	TotalHemoglobinConcMax        uint16 // Scale: 100; Units: g/dL; Max saturated and unsaturated hemoglobin
	SaturatedHemoglobinPercent    uint16 // Scale: 10; Units: %; Percentage of hemoglobin saturated with oxygen
	SaturatedHemoglobinPercentMin uint16 // Scale: 10; Units: %; Min percentage of hemoglobin saturated with oxygen
	SaturatedHemoglobinPercentMax uint16 // Scale: 10; Units: %; Max percentage of hemoglobin saturated with oxygen
	DeviceIndex                   typedef.DeviceIndex
	LeftPco                       int8    // Units: mm; Left platform center offset
	RightPco                      int8    // Units: mm; Right platform center offset
	LeftPowerPhase                []uint8 // Scale: 0.7111111; Array: [N]; Units: degrees; Left power phase angles. Data value indexes defined by power_phase_type.
	LeftPowerPhasePeak            []uint8 // Scale: 0.7111111; Array: [N]; Units: degrees; Left power phase peak angles. Data value indexes defined by power_phase_type.
	RightPowerPhase               []uint8 // Scale: 0.7111111; Array: [N]; Units: degrees; Right power phase angles. Data value indexes defined by power_phase_type.
	RightPowerPhasePeak           []uint8 // Scale: 0.7111111; Array: [N]; Units: degrees; Right power phase peak angles. Data value indexes defined by power_phase_type.
	EnhancedSpeed                 uint32  // Scale: 1000; Units: m/s;
	EnhancedAltitude              uint32  // Scale: 5; Offset: 500; Units: m;
	BatterySoc                    uint8   // Scale: 2; Units: percent; lev battery state of charge
	MotorPower                    uint16  // Units: watts; lev motor power
	VerticalRatio                 uint16  // Scale: 100; Units: percent;
	StanceTimeBalance             uint16  // Scale: 100; Units: percent;
	StepLength                    uint16  // Scale: 10; Units: mm;
	CycleLength16                 uint16  // Scale: 100; Units: m; Supports larger cycle sizes needed for paddlesports. Max cycle size: 655.35
	AbsolutePressure              uint32  // Units: Pa; Includes atmospheric pressure
	Depth                         uint32  // Scale: 1000; Units: m; 0 if above water
	NextStopDepth                 uint32  // Scale: 1000; Units: m; 0 if above water
	NextStopTime                  uint32  // Units: s;
	TimeToSurface                 uint32  // Units: s;
	NdlTime                       uint32  // Units: s;
	CnsLoad                       uint8   // Units: percent;
	N2Load                        uint16  // Units: percent;
	RespirationRate               uint8   // Units: s;
	EnhancedRespirationRate       uint16  // Scale: 100; Units: Breaths/min;
	Grit                          float32 // The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes.
	Flow                          float32 // The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals.
	CurrentStress                 uint16  // Scale: 100; Current Stress value
	EbikeTravelRange              uint16  // Units: km;
	EbikeBatteryLevel             uint8   // Units: percent;
	EbikeAssistMode               uint8   // Units: depends on sensor;
	EbikeAssistLevelPercent       uint8   // Units: percent;
	AirTimeRemaining              uint32  // Units: s;
	PressureSac                   uint16  // Scale: 100; Units: bar/min; Pressure-based surface air consumption
	VolumeSac                     uint16  // Scale: 100; Units: L/min; Volumetric surface air consumption
	Rmv                           uint16  // Scale: 100; Units: L/min; Respiratory minute volume
	AscentRate                    int32   // Scale: 1000; Units: m/s;
	Po2                           uint8   // Scale: 100; Units: percent; Current partial pressure of oxygen
	CoreTemperature               uint16  // Scale: 100; Units: C;

	// Developer Fields are dynamic, can't be mapped as struct's fields.
	// [Added since protocol version 2.0]
	DeveloperFields []proto.DeveloperField
}

// NewRecord creates new Record struct based on given mesg. If mesg is nil or mesg.Num is not equal to Record mesg number, it will return nil.
func NewRecord(mesg proto.Message) *Record {
	if mesg.Num != typedef.MesgNumRecord {
		return nil
	}

	vals := [254]any{}
	for i := range mesg.Fields {
		field := &mesg.Fields[i]
		if field.Num >= byte(len(vals)) {
			continue
		}
		vals[field.Num] = field.Value
	}

	return &Record{
		Timestamp:                     typeconv.ToUint32[typedef.DateTime](vals[253]),
		PositionLat:                   typeconv.ToSint32[int32](vals[0]),
		PositionLong:                  typeconv.ToSint32[int32](vals[1]),
		Altitude:                      typeconv.ToUint16[uint16](vals[2]),
		HeartRate:                     typeconv.ToUint8[uint8](vals[3]),
		Cadence:                       typeconv.ToUint8[uint8](vals[4]),
		Distance:                      typeconv.ToUint32[uint32](vals[5]),
		Speed:                         typeconv.ToUint16[uint16](vals[6]),
		Power:                         typeconv.ToUint16[uint16](vals[7]),
		CompressedSpeedDistance:       typeconv.ToSliceByte[byte](vals[8]),
		Grade:                         typeconv.ToSint16[int16](vals[9]),
		Resistance:                    typeconv.ToUint8[uint8](vals[10]),
		TimeFromCourse:                typeconv.ToSint32[int32](vals[11]),
		CycleLength:                   typeconv.ToUint8[uint8](vals[12]),
		Temperature:                   typeconv.ToSint8[int8](vals[13]),
		Speed1S:                       typeconv.ToSliceUint8[uint8](vals[17]),
		Cycles:                        typeconv.ToUint8[uint8](vals[18]),
		TotalCycles:                   typeconv.ToUint32[uint32](vals[19]),
		CompressedAccumulatedPower:    typeconv.ToUint16[uint16](vals[28]),
		AccumulatedPower:              typeconv.ToUint32[uint32](vals[29]),
		LeftRightBalance:              typeconv.ToUint8[typedef.LeftRightBalance](vals[30]),
		GpsAccuracy:                   typeconv.ToUint8[uint8](vals[31]),
		VerticalSpeed:                 typeconv.ToSint16[int16](vals[32]),
		Calories:                      typeconv.ToUint16[uint16](vals[33]),
		VerticalOscillation:           typeconv.ToUint16[uint16](vals[39]),
		StanceTimePercent:             typeconv.ToUint16[uint16](vals[40]),
		StanceTime:                    typeconv.ToUint16[uint16](vals[41]),
		ActivityType:                  typeconv.ToEnum[typedef.ActivityType](vals[42]),
		LeftTorqueEffectiveness:       typeconv.ToUint8[uint8](vals[43]),
		RightTorqueEffectiveness:      typeconv.ToUint8[uint8](vals[44]),
		LeftPedalSmoothness:           typeconv.ToUint8[uint8](vals[45]),
		RightPedalSmoothness:          typeconv.ToUint8[uint8](vals[46]),
		CombinedPedalSmoothness:       typeconv.ToUint8[uint8](vals[47]),
		Time128:                       typeconv.ToUint8[uint8](vals[48]),
		StrokeType:                    typeconv.ToEnum[typedef.StrokeType](vals[49]),
		Zone:                          typeconv.ToUint8[uint8](vals[50]),
		BallSpeed:                     typeconv.ToUint16[uint16](vals[51]),
		Cadence256:                    typeconv.ToUint16[uint16](vals[52]),
		FractionalCadence:             typeconv.ToUint8[uint8](vals[53]),
		TotalHemoglobinConc:           typeconv.ToUint16[uint16](vals[54]),
		TotalHemoglobinConcMin:        typeconv.ToUint16[uint16](vals[55]),
		TotalHemoglobinConcMax:        typeconv.ToUint16[uint16](vals[56]),
		SaturatedHemoglobinPercent:    typeconv.ToUint16[uint16](vals[57]),
		SaturatedHemoglobinPercentMin: typeconv.ToUint16[uint16](vals[58]),
		SaturatedHemoglobinPercentMax: typeconv.ToUint16[uint16](vals[59]),
		DeviceIndex:                   typeconv.ToUint8[typedef.DeviceIndex](vals[62]),
		LeftPco:                       typeconv.ToSint8[int8](vals[67]),
		RightPco:                      typeconv.ToSint8[int8](vals[68]),
		LeftPowerPhase:                typeconv.ToSliceUint8[uint8](vals[69]),
		LeftPowerPhasePeak:            typeconv.ToSliceUint8[uint8](vals[70]),
		RightPowerPhase:               typeconv.ToSliceUint8[uint8](vals[71]),
		RightPowerPhasePeak:           typeconv.ToSliceUint8[uint8](vals[72]),
		EnhancedSpeed:                 typeconv.ToUint32[uint32](vals[73]),
		EnhancedAltitude:              typeconv.ToUint32[uint32](vals[78]),
		BatterySoc:                    typeconv.ToUint8[uint8](vals[81]),
		MotorPower:                    typeconv.ToUint16[uint16](vals[82]),
		VerticalRatio:                 typeconv.ToUint16[uint16](vals[83]),
		StanceTimeBalance:             typeconv.ToUint16[uint16](vals[84]),
		StepLength:                    typeconv.ToUint16[uint16](vals[85]),
		CycleLength16:                 typeconv.ToUint16[uint16](vals[87]),
		AbsolutePressure:              typeconv.ToUint32[uint32](vals[91]),
		Depth:                         typeconv.ToUint32[uint32](vals[92]),
		NextStopDepth:                 typeconv.ToUint32[uint32](vals[93]),
		NextStopTime:                  typeconv.ToUint32[uint32](vals[94]),
		TimeToSurface:                 typeconv.ToUint32[uint32](vals[95]),
		NdlTime:                       typeconv.ToUint32[uint32](vals[96]),
		CnsLoad:                       typeconv.ToUint8[uint8](vals[97]),
		N2Load:                        typeconv.ToUint16[uint16](vals[98]),
		RespirationRate:               typeconv.ToUint8[uint8](vals[99]),
		EnhancedRespirationRate:       typeconv.ToUint16[uint16](vals[108]),
		Grit:                          typeconv.ToFloat32[float32](vals[114]),
		Flow:                          typeconv.ToFloat32[float32](vals[115]),
		CurrentStress:                 typeconv.ToUint16[uint16](vals[116]),
		EbikeTravelRange:              typeconv.ToUint16[uint16](vals[117]),
		EbikeBatteryLevel:             typeconv.ToUint8[uint8](vals[118]),
		EbikeAssistMode:               typeconv.ToUint8[uint8](vals[119]),
		EbikeAssistLevelPercent:       typeconv.ToUint8[uint8](vals[120]),
		AirTimeRemaining:              typeconv.ToUint32[uint32](vals[123]),
		PressureSac:                   typeconv.ToUint16[uint16](vals[124]),
		VolumeSac:                     typeconv.ToUint16[uint16](vals[125]),
		Rmv:                           typeconv.ToUint16[uint16](vals[126]),
		AscentRate:                    typeconv.ToSint32[int32](vals[127]),
		Po2:                           typeconv.ToUint8[uint8](vals[129]),
		CoreTemperature:               typeconv.ToUint16[uint16](vals[139]),

		DeveloperFields: mesg.DeveloperFields,
	}
}

// ToMesg converts Record into proto.Message.
func (m *Record) ToMesg(fac Factory) proto.Message {
	mesg := fac.CreateMesgOnly(typedef.MesgNumRecord)
	mesg.Fields = make([]proto.Field, 0, m.size())

	if typeconv.ToUint32[uint32](m.Timestamp) != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 253)
		field.Value = typeconv.ToUint32[uint32](m.Timestamp)
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.PositionLat != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 0)
		field.Value = m.PositionLat
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.PositionLong != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 1)
		field.Value = m.PositionLong
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Altitude != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 2)
		field.Value = m.Altitude
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.HeartRate != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 3)
		field.Value = m.HeartRate
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Cadence != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 4)
		field.Value = m.Cadence
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Distance != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 5)
		field.Value = m.Distance
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Speed != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 6)
		field.Value = m.Speed
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Power != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 7)
		field.Value = m.Power
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.CompressedSpeedDistance != nil {
		field := fac.CreateField(mesg.Num, 8)
		field.Value = m.CompressedSpeedDistance
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Grade != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 9)
		field.Value = m.Grade
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Resistance != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 10)
		field.Value = m.Resistance
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TimeFromCourse != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 11)
		field.Value = m.TimeFromCourse
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.CycleLength != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 12)
		field.Value = m.CycleLength
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Temperature != basetype.Sint8Invalid {
		field := fac.CreateField(mesg.Num, 13)
		field.Value = m.Temperature
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Speed1S != nil {
		field := fac.CreateField(mesg.Num, 17)
		field.Value = m.Speed1S
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Cycles != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 18)
		field.Value = m.Cycles
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalCycles != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 19)
		field.Value = m.TotalCycles
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.CompressedAccumulatedPower != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 28)
		field.Value = m.CompressedAccumulatedPower
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AccumulatedPower != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 29)
		field.Value = m.AccumulatedPower
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToUint8[uint8](m.LeftRightBalance) != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 30)
		field.Value = typeconv.ToUint8[uint8](m.LeftRightBalance)
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.GpsAccuracy != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 31)
		field.Value = m.GpsAccuracy
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.VerticalSpeed != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 32)
		field.Value = m.VerticalSpeed
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Calories != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 33)
		field.Value = m.Calories
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.VerticalOscillation != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 39)
		field.Value = m.VerticalOscillation
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.StanceTimePercent != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 40)
		field.Value = m.StanceTimePercent
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.StanceTime != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 41)
		field.Value = m.StanceTime
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToEnum[byte](m.ActivityType) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 42)
		field.Value = typeconv.ToEnum[byte](m.ActivityType)
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.LeftTorqueEffectiveness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 43)
		field.Value = m.LeftTorqueEffectiveness
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.RightTorqueEffectiveness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 44)
		field.Value = m.RightTorqueEffectiveness
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.LeftPedalSmoothness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 45)
		field.Value = m.LeftPedalSmoothness
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.RightPedalSmoothness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 46)
		field.Value = m.RightPedalSmoothness
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.CombinedPedalSmoothness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 47)
		field.Value = m.CombinedPedalSmoothness
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Time128 != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 48)
		field.Value = m.Time128
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToEnum[byte](m.StrokeType) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 49)
		field.Value = typeconv.ToEnum[byte](m.StrokeType)
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Zone != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 50)
		field.Value = m.Zone
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.BallSpeed != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 51)
		field.Value = m.BallSpeed
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Cadence256 != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 52)
		field.Value = m.Cadence256
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.FractionalCadence != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 53)
		field.Value = m.FractionalCadence
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalHemoglobinConc != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 54)
		field.Value = m.TotalHemoglobinConc
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalHemoglobinConcMin != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 55)
		field.Value = m.TotalHemoglobinConcMin
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalHemoglobinConcMax != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 56)
		field.Value = m.TotalHemoglobinConcMax
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.SaturatedHemoglobinPercent != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 57)
		field.Value = m.SaturatedHemoglobinPercent
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.SaturatedHemoglobinPercentMin != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 58)
		field.Value = m.SaturatedHemoglobinPercentMin
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.SaturatedHemoglobinPercentMax != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 59)
		field.Value = m.SaturatedHemoglobinPercentMax
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToUint8[uint8](m.DeviceIndex) != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 62)
		field.Value = typeconv.ToUint8[uint8](m.DeviceIndex)
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.LeftPco != basetype.Sint8Invalid {
		field := fac.CreateField(mesg.Num, 67)
		field.Value = m.LeftPco
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.RightPco != basetype.Sint8Invalid {
		field := fac.CreateField(mesg.Num, 68)
		field.Value = m.RightPco
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.LeftPowerPhase != nil {
		field := fac.CreateField(mesg.Num, 69)
		field.Value = m.LeftPowerPhase
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.LeftPowerPhasePeak != nil {
		field := fac.CreateField(mesg.Num, 70)
		field.Value = m.LeftPowerPhasePeak
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.RightPowerPhase != nil {
		field := fac.CreateField(mesg.Num, 71)
		field.Value = m.RightPowerPhase
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.RightPowerPhasePeak != nil {
		field := fac.CreateField(mesg.Num, 72)
		field.Value = m.RightPowerPhasePeak
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.EnhancedSpeed != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 73)
		field.Value = m.EnhancedSpeed
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.EnhancedAltitude != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 78)
		field.Value = m.EnhancedAltitude
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.BatterySoc != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 81)
		field.Value = m.BatterySoc
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MotorPower != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 82)
		field.Value = m.MotorPower
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.VerticalRatio != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 83)
		field.Value = m.VerticalRatio
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.StanceTimeBalance != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 84)
		field.Value = m.StanceTimeBalance
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.StepLength != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 85)
		field.Value = m.StepLength
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.CycleLength16 != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 87)
		field.Value = m.CycleLength16
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AbsolutePressure != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 91)
		field.Value = m.AbsolutePressure
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Depth != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 92)
		field.Value = m.Depth
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.NextStopDepth != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 93)
		field.Value = m.NextStopDepth
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.NextStopTime != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 94)
		field.Value = m.NextStopTime
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TimeToSurface != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 95)
		field.Value = m.TimeToSurface
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.NdlTime != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 96)
		field.Value = m.NdlTime
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.CnsLoad != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 97)
		field.Value = m.CnsLoad
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.N2Load != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 98)
		field.Value = m.N2Load
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.RespirationRate != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 99)
		field.Value = m.RespirationRate
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.EnhancedRespirationRate != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 108)
		field.Value = m.EnhancedRespirationRate
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToUint32[uint32](m.Grit) != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 114)
		field.Value = m.Grit
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToUint32[uint32](m.Flow) != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 115)
		field.Value = m.Flow
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.CurrentStress != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 116)
		field.Value = m.CurrentStress
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.EbikeTravelRange != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 117)
		field.Value = m.EbikeTravelRange
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.EbikeBatteryLevel != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 118)
		field.Value = m.EbikeBatteryLevel
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.EbikeAssistMode != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 119)
		field.Value = m.EbikeAssistMode
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.EbikeAssistLevelPercent != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 120)
		field.Value = m.EbikeAssistLevelPercent
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AirTimeRemaining != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 123)
		field.Value = m.AirTimeRemaining
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.PressureSac != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 124)
		field.Value = m.PressureSac
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.VolumeSac != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 125)
		field.Value = m.VolumeSac
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Rmv != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 126)
		field.Value = m.Rmv
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AscentRate != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 127)
		field.Value = m.AscentRate
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Po2 != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 129)
		field.Value = m.Po2
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.CoreTemperature != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 139)
		field.Value = m.CoreTemperature
		mesg.Fields = append(mesg.Fields, field)
	}

	mesg.DeveloperFields = m.DeveloperFields

	return mesg
}

// size returns size of Record's valid fields.
func (m *Record) size() byte {
	var size byte
	if typeconv.ToUint32[uint32](m.Timestamp) != basetype.Uint32Invalid {
		size++
	}
	if m.PositionLat != basetype.Sint32Invalid {
		size++
	}
	if m.PositionLong != basetype.Sint32Invalid {
		size++
	}
	if m.Altitude != basetype.Uint16Invalid {
		size++
	}
	if m.HeartRate != basetype.Uint8Invalid {
		size++
	}
	if m.Cadence != basetype.Uint8Invalid {
		size++
	}
	if m.Distance != basetype.Uint32Invalid {
		size++
	}
	if m.Speed != basetype.Uint16Invalid {
		size++
	}
	if m.Power != basetype.Uint16Invalid {
		size++
	}
	if m.CompressedSpeedDistance != nil {
		size++
	}
	if m.Grade != basetype.Sint16Invalid {
		size++
	}
	if m.Resistance != basetype.Uint8Invalid {
		size++
	}
	if m.TimeFromCourse != basetype.Sint32Invalid {
		size++
	}
	if m.CycleLength != basetype.Uint8Invalid {
		size++
	}
	if m.Temperature != basetype.Sint8Invalid {
		size++
	}
	if m.Speed1S != nil {
		size++
	}
	if m.Cycles != basetype.Uint8Invalid {
		size++
	}
	if m.TotalCycles != basetype.Uint32Invalid {
		size++
	}
	if m.CompressedAccumulatedPower != basetype.Uint16Invalid {
		size++
	}
	if m.AccumulatedPower != basetype.Uint32Invalid {
		size++
	}
	if typeconv.ToUint8[uint8](m.LeftRightBalance) != basetype.Uint8Invalid {
		size++
	}
	if m.GpsAccuracy != basetype.Uint8Invalid {
		size++
	}
	if m.VerticalSpeed != basetype.Sint16Invalid {
		size++
	}
	if m.Calories != basetype.Uint16Invalid {
		size++
	}
	if m.VerticalOscillation != basetype.Uint16Invalid {
		size++
	}
	if m.StanceTimePercent != basetype.Uint16Invalid {
		size++
	}
	if m.StanceTime != basetype.Uint16Invalid {
		size++
	}
	if typeconv.ToEnum[byte](m.ActivityType) != basetype.EnumInvalid {
		size++
	}
	if m.LeftTorqueEffectiveness != basetype.Uint8Invalid {
		size++
	}
	if m.RightTorqueEffectiveness != basetype.Uint8Invalid {
		size++
	}
	if m.LeftPedalSmoothness != basetype.Uint8Invalid {
		size++
	}
	if m.RightPedalSmoothness != basetype.Uint8Invalid {
		size++
	}
	if m.CombinedPedalSmoothness != basetype.Uint8Invalid {
		size++
	}
	if m.Time128 != basetype.Uint8Invalid {
		size++
	}
	if typeconv.ToEnum[byte](m.StrokeType) != basetype.EnumInvalid {
		size++
	}
	if m.Zone != basetype.Uint8Invalid {
		size++
	}
	if m.BallSpeed != basetype.Uint16Invalid {
		size++
	}
	if m.Cadence256 != basetype.Uint16Invalid {
		size++
	}
	if m.FractionalCadence != basetype.Uint8Invalid {
		size++
	}
	if m.TotalHemoglobinConc != basetype.Uint16Invalid {
		size++
	}
	if m.TotalHemoglobinConcMin != basetype.Uint16Invalid {
		size++
	}
	if m.TotalHemoglobinConcMax != basetype.Uint16Invalid {
		size++
	}
	if m.SaturatedHemoglobinPercent != basetype.Uint16Invalid {
		size++
	}
	if m.SaturatedHemoglobinPercentMin != basetype.Uint16Invalid {
		size++
	}
	if m.SaturatedHemoglobinPercentMax != basetype.Uint16Invalid {
		size++
	}
	if typeconv.ToUint8[uint8](m.DeviceIndex) != basetype.Uint8Invalid {
		size++
	}
	if m.LeftPco != basetype.Sint8Invalid {
		size++
	}
	if m.RightPco != basetype.Sint8Invalid {
		size++
	}
	if m.LeftPowerPhase != nil {
		size++
	}
	if m.LeftPowerPhasePeak != nil {
		size++
	}
	if m.RightPowerPhase != nil {
		size++
	}
	if m.RightPowerPhasePeak != nil {
		size++
	}
	if m.EnhancedSpeed != basetype.Uint32Invalid {
		size++
	}
	if m.EnhancedAltitude != basetype.Uint32Invalid {
		size++
	}
	if m.BatterySoc != basetype.Uint8Invalid {
		size++
	}
	if m.MotorPower != basetype.Uint16Invalid {
		size++
	}
	if m.VerticalRatio != basetype.Uint16Invalid {
		size++
	}
	if m.StanceTimeBalance != basetype.Uint16Invalid {
		size++
	}
	if m.StepLength != basetype.Uint16Invalid {
		size++
	}
	if m.CycleLength16 != basetype.Uint16Invalid {
		size++
	}
	if m.AbsolutePressure != basetype.Uint32Invalid {
		size++
	}
	if m.Depth != basetype.Uint32Invalid {
		size++
	}
	if m.NextStopDepth != basetype.Uint32Invalid {
		size++
	}
	if m.NextStopTime != basetype.Uint32Invalid {
		size++
	}
	if m.TimeToSurface != basetype.Uint32Invalid {
		size++
	}
	if m.NdlTime != basetype.Uint32Invalid {
		size++
	}
	if m.CnsLoad != basetype.Uint8Invalid {
		size++
	}
	if m.N2Load != basetype.Uint16Invalid {
		size++
	}
	if m.RespirationRate != basetype.Uint8Invalid {
		size++
	}
	if m.EnhancedRespirationRate != basetype.Uint16Invalid {
		size++
	}
	if typeconv.ToUint32[uint32](m.Grit) != basetype.Uint32Invalid {
		size++
	}
	if typeconv.ToUint32[uint32](m.Flow) != basetype.Uint32Invalid {
		size++
	}
	if m.CurrentStress != basetype.Uint16Invalid {
		size++
	}
	if m.EbikeTravelRange != basetype.Uint16Invalid {
		size++
	}
	if m.EbikeBatteryLevel != basetype.Uint8Invalid {
		size++
	}
	if m.EbikeAssistMode != basetype.Uint8Invalid {
		size++
	}
	if m.EbikeAssistLevelPercent != basetype.Uint8Invalid {
		size++
	}
	if m.AirTimeRemaining != basetype.Uint32Invalid {
		size++
	}
	if m.PressureSac != basetype.Uint16Invalid {
		size++
	}
	if m.VolumeSac != basetype.Uint16Invalid {
		size++
	}
	if m.Rmv != basetype.Uint16Invalid {
		size++
	}
	if m.AscentRate != basetype.Sint32Invalid {
		size++
	}
	if m.Po2 != basetype.Uint8Invalid {
		size++
	}
	if m.CoreTemperature != basetype.Uint16Invalid {
		size++
	}
	return size
}
