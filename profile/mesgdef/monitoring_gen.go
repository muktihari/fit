// Code generated by internal/cmd/fitgen/main.go. DO NOT EDIT.
// SDK Version: 21.126

// Copyright 2023 The Fit SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package mesgdef

import (
	"github.com/muktihari/fit/kit/typeconv"
	"github.com/muktihari/fit/profile/basetype"
	"github.com/muktihari/fit/profile/typedef"
	"github.com/muktihari/fit/proto"
)

// Monitoring is a Monitoring message.
type Monitoring struct {
	Timestamp                    typedef.DateTime    // Units: s; Must align to logging interval, for example, time must be 00:00:00 for daily log.
	DeviceIndex                  typedef.DeviceIndex // Associates this data to device_info message. Not required for file with single device (sensor).
	Calories                     uint16              // Units: kcal; Accumulated total calories. Maintained by MonitoringReader for each activity_type. See SDK documentation
	Distance                     uint32              // Scale: 100; Units: m; Accumulated distance. Maintained by MonitoringReader for each activity_type. See SDK documentation.
	Cycles                       uint32              // Scale: 2; Units: cycles; Accumulated cycles. Maintained by MonitoringReader for each activity_type. See SDK documentation.
	ActiveTime                   uint32              // Scale: 1000; Units: s;
	ActivityType                 typedef.ActivityType
	ActivitySubtype              typedef.ActivitySubtype
	ActivityLevel                typedef.ActivityLevel
	Distance16                   uint16                // Units: 100 * m;
	Cycles16                     uint16                // Units: 2 * cycles (steps);
	ActiveTime16                 uint16                // Units: s;
	LocalTimestamp               typedef.LocalDateTime // Must align to logging interval, for example, time must be 00:00:00 for daily log.
	Temperature                  int16                 // Scale: 100; Units: C; Avg temperature during the logging interval ended at timestamp
	TemperatureMin               int16                 // Scale: 100; Units: C; Min temperature during the logging interval ended at timestamp
	TemperatureMax               int16                 // Scale: 100; Units: C; Max temperature during the logging interval ended at timestamp
	ActivityTime                 []uint16              // Array: [8]; Units: minutes; Indexed using minute_activity_level enum
	ActiveCalories               uint16                // Units: kcal;
	CurrentActivityTypeIntensity byte                  // Indicates single type / intensity for duration since last monitoring message.
	TimestampMin8                uint8                 // Units: min;
	Timestamp16                  uint16                // Units: s;
	HeartRate                    uint8                 // Units: bpm;
	Intensity                    uint8                 // Scale: 10;
	DurationMin                  uint16                // Units: min;
	Duration                     uint32                // Units: s;
	Ascent                       uint32                // Scale: 1000; Units: m;
	Descent                      uint32                // Scale: 1000; Units: m;
	ModerateActivityMinutes      uint16                // Units: minutes;
	VigorousActivityMinutes      uint16                // Units: minutes;

	// Developer Fields are dynamic, can't be mapped as struct's fields.
	// [Added since protocol version 2.0]
	DeveloperFields []proto.DeveloperField
}

// NewMonitoring creates new Monitoring struct based on given mesg. If mesg is nil or mesg.Num is not equal to Monitoring mesg number, it will return nil.
func NewMonitoring(mesg proto.Message) *Monitoring {
	if mesg.Num != typedef.MesgNumMonitoring {
		return nil
	}

	vals := [254]any{}
	for i := range mesg.Fields {
		field := &mesg.Fields[i]
		if field.Num >= byte(len(vals)) {
			continue
		}
		vals[field.Num] = field.Value
	}

	return &Monitoring{
		Timestamp:                    typeconv.ToUint32[typedef.DateTime](vals[253]),
		DeviceIndex:                  typeconv.ToUint8[typedef.DeviceIndex](vals[0]),
		Calories:                     typeconv.ToUint16[uint16](vals[1]),
		Distance:                     typeconv.ToUint32[uint32](vals[2]),
		Cycles:                       typeconv.ToUint32[uint32](vals[3]),
		ActiveTime:                   typeconv.ToUint32[uint32](vals[4]),
		ActivityType:                 typeconv.ToEnum[typedef.ActivityType](vals[5]),
		ActivitySubtype:              typeconv.ToEnum[typedef.ActivitySubtype](vals[6]),
		ActivityLevel:                typeconv.ToEnum[typedef.ActivityLevel](vals[7]),
		Distance16:                   typeconv.ToUint16[uint16](vals[8]),
		Cycles16:                     typeconv.ToUint16[uint16](vals[9]),
		ActiveTime16:                 typeconv.ToUint16[uint16](vals[10]),
		LocalTimestamp:               typeconv.ToUint32[typedef.LocalDateTime](vals[11]),
		Temperature:                  typeconv.ToSint16[int16](vals[12]),
		TemperatureMin:               typeconv.ToSint16[int16](vals[14]),
		TemperatureMax:               typeconv.ToSint16[int16](vals[15]),
		ActivityTime:                 typeconv.ToSliceUint16[uint16](vals[16]),
		ActiveCalories:               typeconv.ToUint16[uint16](vals[19]),
		CurrentActivityTypeIntensity: typeconv.ToByte[byte](vals[24]),
		TimestampMin8:                typeconv.ToUint8[uint8](vals[25]),
		Timestamp16:                  typeconv.ToUint16[uint16](vals[26]),
		HeartRate:                    typeconv.ToUint8[uint8](vals[27]),
		Intensity:                    typeconv.ToUint8[uint8](vals[28]),
		DurationMin:                  typeconv.ToUint16[uint16](vals[29]),
		Duration:                     typeconv.ToUint32[uint32](vals[30]),
		Ascent:                       typeconv.ToUint32[uint32](vals[31]),
		Descent:                      typeconv.ToUint32[uint32](vals[32]),
		ModerateActivityMinutes:      typeconv.ToUint16[uint16](vals[33]),
		VigorousActivityMinutes:      typeconv.ToUint16[uint16](vals[34]),

		DeveloperFields: mesg.DeveloperFields,
	}
}

// ToMesg converts Monitoring into proto.Message.
func (m *Monitoring) ToMesg(fac Factory) proto.Message {
	mesg := fac.CreateMesgOnly(typedef.MesgNumMonitoring)
	mesg.Fields = make([]proto.Field, 0, m.size())

	if typeconv.ToUint32[uint32](m.Timestamp) != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 253)
		field.Value = typeconv.ToUint32[uint32](m.Timestamp)
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToUint8[uint8](m.DeviceIndex) != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 0)
		field.Value = typeconv.ToUint8[uint8](m.DeviceIndex)
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Calories != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 1)
		field.Value = m.Calories
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Distance != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 2)
		field.Value = m.Distance
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Cycles != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 3)
		field.Value = m.Cycles
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.ActiveTime != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 4)
		field.Value = m.ActiveTime
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToEnum[byte](m.ActivityType) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 5)
		field.Value = typeconv.ToEnum[byte](m.ActivityType)
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToEnum[byte](m.ActivitySubtype) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 6)
		field.Value = typeconv.ToEnum[byte](m.ActivitySubtype)
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToEnum[byte](m.ActivityLevel) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 7)
		field.Value = typeconv.ToEnum[byte](m.ActivityLevel)
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Distance16 != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 8)
		field.Value = m.Distance16
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Cycles16 != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 9)
		field.Value = m.Cycles16
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.ActiveTime16 != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 10)
		field.Value = m.ActiveTime16
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToUint32[uint32](m.LocalTimestamp) != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 11)
		field.Value = typeconv.ToUint32[uint32](m.LocalTimestamp)
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Temperature != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 12)
		field.Value = m.Temperature
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TemperatureMin != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 14)
		field.Value = m.TemperatureMin
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TemperatureMax != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 15)
		field.Value = m.TemperatureMax
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.ActivityTime != nil {
		field := fac.CreateField(mesg.Num, 16)
		field.Value = m.ActivityTime
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.ActiveCalories != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 19)
		field.Value = m.ActiveCalories
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.CurrentActivityTypeIntensity != basetype.ByteInvalid {
		field := fac.CreateField(mesg.Num, 24)
		field.Value = m.CurrentActivityTypeIntensity
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TimestampMin8 != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 25)
		field.Value = m.TimestampMin8
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Timestamp16 != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 26)
		field.Value = m.Timestamp16
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.HeartRate != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 27)
		field.Value = m.HeartRate
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Intensity != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 28)
		field.Value = m.Intensity
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.DurationMin != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 29)
		field.Value = m.DurationMin
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Duration != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 30)
		field.Value = m.Duration
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Ascent != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 31)
		field.Value = m.Ascent
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Descent != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 32)
		field.Value = m.Descent
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.ModerateActivityMinutes != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 33)
		field.Value = m.ModerateActivityMinutes
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.VigorousActivityMinutes != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 34)
		field.Value = m.VigorousActivityMinutes
		mesg.Fields = append(mesg.Fields, field)
	}

	mesg.DeveloperFields = m.DeveloperFields

	return mesg
}

// size returns size of Monitoring's valid fields.
func (m *Monitoring) size() byte {
	var size byte
	if typeconv.ToUint32[uint32](m.Timestamp) != basetype.Uint32Invalid {
		size++
	}
	if typeconv.ToUint8[uint8](m.DeviceIndex) != basetype.Uint8Invalid {
		size++
	}
	if m.Calories != basetype.Uint16Invalid {
		size++
	}
	if m.Distance != basetype.Uint32Invalid {
		size++
	}
	if m.Cycles != basetype.Uint32Invalid {
		size++
	}
	if m.ActiveTime != basetype.Uint32Invalid {
		size++
	}
	if typeconv.ToEnum[byte](m.ActivityType) != basetype.EnumInvalid {
		size++
	}
	if typeconv.ToEnum[byte](m.ActivitySubtype) != basetype.EnumInvalid {
		size++
	}
	if typeconv.ToEnum[byte](m.ActivityLevel) != basetype.EnumInvalid {
		size++
	}
	if m.Distance16 != basetype.Uint16Invalid {
		size++
	}
	if m.Cycles16 != basetype.Uint16Invalid {
		size++
	}
	if m.ActiveTime16 != basetype.Uint16Invalid {
		size++
	}
	if typeconv.ToUint32[uint32](m.LocalTimestamp) != basetype.Uint32Invalid {
		size++
	}
	if m.Temperature != basetype.Sint16Invalid {
		size++
	}
	if m.TemperatureMin != basetype.Sint16Invalid {
		size++
	}
	if m.TemperatureMax != basetype.Sint16Invalid {
		size++
	}
	if m.ActivityTime != nil {
		size++
	}
	if m.ActiveCalories != basetype.Uint16Invalid {
		size++
	}
	if m.CurrentActivityTypeIntensity != basetype.ByteInvalid {
		size++
	}
	if m.TimestampMin8 != basetype.Uint8Invalid {
		size++
	}
	if m.Timestamp16 != basetype.Uint16Invalid {
		size++
	}
	if m.HeartRate != basetype.Uint8Invalid {
		size++
	}
	if m.Intensity != basetype.Uint8Invalid {
		size++
	}
	if m.DurationMin != basetype.Uint16Invalid {
		size++
	}
	if m.Duration != basetype.Uint32Invalid {
		size++
	}
	if m.Ascent != basetype.Uint32Invalid {
		size++
	}
	if m.Descent != basetype.Uint32Invalid {
		size++
	}
	if m.ModerateActivityMinutes != basetype.Uint16Invalid {
		size++
	}
	if m.VigorousActivityMinutes != basetype.Uint16Invalid {
		size++
	}
	return size
}
