// Code generated by internal/cmd/fitgen/main.go. DO NOT EDIT.
// SDK Version: 21.126

// Copyright 2023 The Fit SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package mesgdef

import (
	"github.com/muktihari/fit/kit/datetime"
	"github.com/muktihari/fit/kit/typeconv"
	"github.com/muktihari/fit/profile/basetype"
	"github.com/muktihari/fit/profile/typedef"
	"github.com/muktihari/fit/proto"
	"time"
)

// MagnetometerData is a MagnetometerData message.
type MagnetometerData struct {
	Timestamp        time.Time // Units: s; Whole second part of the timestamp
	TimestampMs      uint16    // Units: ms; Millisecond part of the timestamp.
	SampleTimeOffset []uint16  // Array: [N]; Units: ms; Each time in the array describes the time at which the compass sample with the corrosponding index was taken. Limited to 30 samples in each message. The samples may span across seconds. Array size must match the number of samples in cmps_x and cmps_y and cmps_z
	MagX             []uint16  // Array: [N]; Units: counts; These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
	MagY             []uint16  // Array: [N]; Units: counts; These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
	MagZ             []uint16  // Array: [N]; Units: counts; These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
	CalibratedMagX   []float32 // Array: [N]; Units: G; Calibrated Magnetometer reading
	CalibratedMagY   []float32 // Array: [N]; Units: G; Calibrated Magnetometer reading
	CalibratedMagZ   []float32 // Array: [N]; Units: G; Calibrated Magnetometer reading

	// Developer Fields are dynamic, can't be mapped as struct's fields.
	// [Added since protocol version 2.0]
	DeveloperFields []proto.DeveloperField
}

// NewMagnetometerData creates new MagnetometerData struct based on given mesg.
// If mesg is nil, it will return MagnetometerData with all fields being set to its corresponding invalid value.
func NewMagnetometerData(mesg *proto.Message) *MagnetometerData {
	vals := [254]any{}

	var developerFields []proto.DeveloperField
	if mesg != nil {
		for i := range mesg.Fields {
			if mesg.Fields[i].Num >= byte(len(vals)) {
				continue
			}
			vals[mesg.Fields[i].Num] = mesg.Fields[i].Value
		}
		developerFields = mesg.DeveloperFields
	}

	return &MagnetometerData{
		Timestamp:        datetime.ToTime(vals[253]),
		TimestampMs:      typeconv.ToUint16[uint16](vals[0]),
		SampleTimeOffset: typeconv.ToSliceUint16[uint16](vals[1]),
		MagX:             typeconv.ToSliceUint16[uint16](vals[2]),
		MagY:             typeconv.ToSliceUint16[uint16](vals[3]),
		MagZ:             typeconv.ToSliceUint16[uint16](vals[4]),
		CalibratedMagX:   typeconv.ToSliceFloat32[float32](vals[5]),
		CalibratedMagY:   typeconv.ToSliceFloat32[float32](vals[6]),
		CalibratedMagZ:   typeconv.ToSliceFloat32[float32](vals[7]),

		DeveloperFields: developerFields,
	}
}

// ToMesg converts MagnetometerData into proto.Message.
func (m *MagnetometerData) ToMesg(fac Factory) proto.Message {
	mesg := fac.CreateMesgOnly(typedef.MesgNumMagnetometerData)
	mesg.Fields = make([]proto.Field, 0, m.size())

	if datetime.ToUint32(m.Timestamp) != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 253)
		field.Value = datetime.ToUint32(m.Timestamp)
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TimestampMs != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 0)
		field.Value = m.TimestampMs
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.SampleTimeOffset != nil {
		field := fac.CreateField(mesg.Num, 1)
		field.Value = m.SampleTimeOffset
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MagX != nil {
		field := fac.CreateField(mesg.Num, 2)
		field.Value = m.MagX
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MagY != nil {
		field := fac.CreateField(mesg.Num, 3)
		field.Value = m.MagY
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MagZ != nil {
		field := fac.CreateField(mesg.Num, 4)
		field.Value = m.MagZ
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.CalibratedMagX != nil {
		field := fac.CreateField(mesg.Num, 5)
		field.Value = m.CalibratedMagX
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.CalibratedMagY != nil {
		field := fac.CreateField(mesg.Num, 6)
		field.Value = m.CalibratedMagY
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.CalibratedMagZ != nil {
		field := fac.CreateField(mesg.Num, 7)
		field.Value = m.CalibratedMagZ
		mesg.Fields = append(mesg.Fields, field)
	}

	mesg.DeveloperFields = m.DeveloperFields

	return mesg
}

// size returns size of MagnetometerData's valid fields.
func (m *MagnetometerData) size() byte {
	var size byte
	if datetime.ToUint32(m.Timestamp) != basetype.Uint32Invalid {
		size++
	}
	if m.TimestampMs != basetype.Uint16Invalid {
		size++
	}
	if m.SampleTimeOffset != nil {
		size++
	}
	if m.MagX != nil {
		size++
	}
	if m.MagY != nil {
		size++
	}
	if m.MagZ != nil {
		size++
	}
	if m.CalibratedMagX != nil {
		size++
	}
	if m.CalibratedMagY != nil {
		size++
	}
	if m.CalibratedMagZ != nil {
		size++
	}
	return size
}

// SetTimestamp sets MagnetometerData value.
//
// Units: s; Whole second part of the timestamp
func (m *MagnetometerData) SetTimestamp(v time.Time) *MagnetometerData {
	m.Timestamp = v
	return m
}

// SetTimestampMs sets MagnetometerData value.
//
// Units: ms; Millisecond part of the timestamp.
func (m *MagnetometerData) SetTimestampMs(v uint16) *MagnetometerData {
	m.TimestampMs = v
	return m
}

// SetSampleTimeOffset sets MagnetometerData value.
//
// Array: [N]; Units: ms; Each time in the array describes the time at which the compass sample with the corrosponding index was taken. Limited to 30 samples in each message. The samples may span across seconds. Array size must match the number of samples in cmps_x and cmps_y and cmps_z
func (m *MagnetometerData) SetSampleTimeOffset(v []uint16) *MagnetometerData {
	m.SampleTimeOffset = v
	return m
}

// SetMagX sets MagnetometerData value.
//
// Array: [N]; Units: counts; These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
func (m *MagnetometerData) SetMagX(v []uint16) *MagnetometerData {
	m.MagX = v
	return m
}

// SetMagY sets MagnetometerData value.
//
// Array: [N]; Units: counts; These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
func (m *MagnetometerData) SetMagY(v []uint16) *MagnetometerData {
	m.MagY = v
	return m
}

// SetMagZ sets MagnetometerData value.
//
// Array: [N]; Units: counts; These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
func (m *MagnetometerData) SetMagZ(v []uint16) *MagnetometerData {
	m.MagZ = v
	return m
}

// SetCalibratedMagX sets MagnetometerData value.
//
// Array: [N]; Units: G; Calibrated Magnetometer reading
func (m *MagnetometerData) SetCalibratedMagX(v []float32) *MagnetometerData {
	m.CalibratedMagX = v
	return m
}

// SetCalibratedMagY sets MagnetometerData value.
//
// Array: [N]; Units: G; Calibrated Magnetometer reading
func (m *MagnetometerData) SetCalibratedMagY(v []float32) *MagnetometerData {
	m.CalibratedMagY = v
	return m
}

// SetCalibratedMagZ sets MagnetometerData value.
//
// Array: [N]; Units: G; Calibrated Magnetometer reading
func (m *MagnetometerData) SetCalibratedMagZ(v []float32) *MagnetometerData {
	m.CalibratedMagZ = v
	return m
}

// SetDeveloperFields MagnetometerData's DeveloperFields.
func (m *MagnetometerData) SetDeveloperFields(developerFields ...proto.DeveloperField) *MagnetometerData {
	m.DeveloperFields = developerFields
	return m
}
