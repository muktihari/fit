// Code generated by internal/cmd/fitgen/main.go. DO NOT EDIT.
// SDK Version: 21.126

// Copyright 2023 The Fit SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package mesgdef

import (
	"github.com/muktihari/fit/kit/typeconv"
	"github.com/muktihari/fit/profile/basetype"
	"github.com/muktihari/fit/profile/typedef"
	"github.com/muktihari/fit/proto"
)

// SegmentLap is a SegmentLap message.
type SegmentLap struct {
	MessageIndex                typedef.MessageIndex
	Timestamp                   typedef.DateTime // Units: s; Lap end time.
	Event                       typedef.Event
	EventType                   typedef.EventType
	StartTime                   typedef.DateTime
	StartPositionLat            int32  // Units: semicircles;
	StartPositionLong           int32  // Units: semicircles;
	EndPositionLat              int32  // Units: semicircles;
	EndPositionLong             int32  // Units: semicircles;
	TotalElapsedTime            uint32 // Scale: 1000; Units: s; Time (includes pauses)
	TotalTimerTime              uint32 // Scale: 1000; Units: s; Timer Time (excludes pauses)
	TotalDistance               uint32 // Scale: 100; Units: m;
	TotalCycles                 uint32 // Units: cycles;
	TotalCalories               uint16 // Units: kcal;
	TotalFatCalories            uint16 // Units: kcal; If New Leaf
	AvgSpeed                    uint16 // Scale: 1000; Units: m/s;
	MaxSpeed                    uint16 // Scale: 1000; Units: m/s;
	AvgHeartRate                uint8  // Units: bpm;
	MaxHeartRate                uint8  // Units: bpm;
	AvgCadence                  uint8  // Units: rpm; total_cycles / total_timer_time if non_zero_avg_cadence otherwise total_cycles / total_elapsed_time
	MaxCadence                  uint8  // Units: rpm;
	AvgPower                    uint16 // Units: watts; total_power / total_timer_time if non_zero_avg_power otherwise total_power / total_elapsed_time
	MaxPower                    uint16 // Units: watts;
	TotalAscent                 uint16 // Units: m;
	TotalDescent                uint16 // Units: m;
	Sport                       typedef.Sport
	EventGroup                  uint8
	NecLat                      int32 // Units: semicircles; North east corner latitude.
	NecLong                     int32 // Units: semicircles; North east corner longitude.
	SwcLat                      int32 // Units: semicircles; South west corner latitude.
	SwcLong                     int32 // Units: semicircles; South west corner latitude.
	Name                        string
	NormalizedPower             uint16 // Units: watts;
	LeftRightBalance            typedef.LeftRightBalance100
	SubSport                    typedef.SubSport
	TotalWork                   uint32   // Units: J;
	AvgAltitude                 uint16   // Scale: 5; Offset: 500; Units: m;
	MaxAltitude                 uint16   // Scale: 5; Offset: 500; Units: m;
	GpsAccuracy                 uint8    // Units: m;
	AvgGrade                    int16    // Scale: 100; Units: %;
	AvgPosGrade                 int16    // Scale: 100; Units: %;
	AvgNegGrade                 int16    // Scale: 100; Units: %;
	MaxPosGrade                 int16    // Scale: 100; Units: %;
	MaxNegGrade                 int16    // Scale: 100; Units: %;
	AvgTemperature              int8     // Units: C;
	MaxTemperature              int8     // Units: C;
	TotalMovingTime             uint32   // Scale: 1000; Units: s;
	AvgPosVerticalSpeed         int16    // Scale: 1000; Units: m/s;
	AvgNegVerticalSpeed         int16    // Scale: 1000; Units: m/s;
	MaxPosVerticalSpeed         int16    // Scale: 1000; Units: m/s;
	MaxNegVerticalSpeed         int16    // Scale: 1000; Units: m/s;
	TimeInHrZone                []uint32 // Scale: 1000; Array: [N]; Units: s;
	TimeInSpeedZone             []uint32 // Scale: 1000; Array: [N]; Units: s;
	TimeInCadenceZone           []uint32 // Scale: 1000; Array: [N]; Units: s;
	TimeInPowerZone             []uint32 // Scale: 1000; Array: [N]; Units: s;
	RepetitionNum               uint16
	MinAltitude                 uint16 // Scale: 5; Offset: 500; Units: m;
	MinHeartRate                uint8  // Units: bpm;
	ActiveTime                  uint32 // Scale: 1000; Units: s;
	WktStepIndex                typedef.MessageIndex
	SportEvent                  typedef.SportEvent
	AvgLeftTorqueEffectiveness  uint8 // Scale: 2; Units: percent;
	AvgRightTorqueEffectiveness uint8 // Scale: 2; Units: percent;
	AvgLeftPedalSmoothness      uint8 // Scale: 2; Units: percent;
	AvgRightPedalSmoothness     uint8 // Scale: 2; Units: percent;
	AvgCombinedPedalSmoothness  uint8 // Scale: 2; Units: percent;
	Status                      typedef.SegmentLapStatus
	Uuid                        string
	AvgFractionalCadence        uint8 // Scale: 128; Units: rpm; fractional part of the avg_cadence
	MaxFractionalCadence        uint8 // Scale: 128; Units: rpm; fractional part of the max_cadence
	TotalFractionalCycles       uint8 // Scale: 128; Units: cycles; fractional part of the total_cycles
	FrontGearShiftCount         uint16
	RearGearShiftCount          uint16
	TimeStanding                uint32               // Scale: 1000; Units: s; Total time spent in the standing position
	StandCount                  uint16               // Number of transitions to the standing state
	AvgLeftPco                  int8                 // Units: mm; Average left platform center offset
	AvgRightPco                 int8                 // Units: mm; Average right platform center offset
	AvgLeftPowerPhase           []uint8              // Scale: 0.7111111; Array: [N]; Units: degrees; Average left power phase angles. Data value indexes defined by power_phase_type.
	AvgLeftPowerPhasePeak       []uint8              // Scale: 0.7111111; Array: [N]; Units: degrees; Average left power phase peak angles. Data value indexes defined by power_phase_type.
	AvgRightPowerPhase          []uint8              // Scale: 0.7111111; Array: [N]; Units: degrees; Average right power phase angles. Data value indexes defined by power_phase_type.
	AvgRightPowerPhasePeak      []uint8              // Scale: 0.7111111; Array: [N]; Units: degrees; Average right power phase peak angles. Data value indexes defined by power_phase_type.
	AvgPowerPosition            []uint16             // Array: [N]; Units: watts; Average power by position. Data value indexes defined by rider_position_type.
	MaxPowerPosition            []uint16             // Array: [N]; Units: watts; Maximum power by position. Data value indexes defined by rider_position_type.
	AvgCadencePosition          []uint8              // Array: [N]; Units: rpm; Average cadence by position. Data value indexes defined by rider_position_type.
	MaxCadencePosition          []uint8              // Array: [N]; Units: rpm; Maximum cadence by position. Data value indexes defined by rider_position_type.
	Manufacturer                typedef.Manufacturer // Manufacturer that produced the segment
	TotalGrit                   float32              // Units: kGrit; The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes.
	TotalFlow                   float32              // Units: Flow; The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals.
	AvgGrit                     float32              // Units: kGrit; The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes.
	AvgFlow                     float32              // Units: Flow; The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals.
	TotalFractionalAscent       uint8                // Scale: 100; Units: m; fractional part of total_ascent
	TotalFractionalDescent      uint8                // Scale: 100; Units: m; fractional part of total_descent
	EnhancedAvgAltitude         uint32               // Scale: 5; Offset: 500; Units: m;
	EnhancedMaxAltitude         uint32               // Scale: 5; Offset: 500; Units: m;
	EnhancedMinAltitude         uint32               // Scale: 5; Offset: 500; Units: m;

	// Developer Fields are dynamic, can't be mapped as struct's fields.
	// [Added since protocol version 2.0]
	DeveloperFields []proto.DeveloperField
}

// NewSegmentLap creates new SegmentLap struct based on given mesg. If mesg is nil or mesg.Num is not equal to SegmentLap mesg number, it will return nil.
func NewSegmentLap(mesg proto.Message) *SegmentLap {
	if mesg.Num != typedef.MesgNumSegmentLap {
		return nil
	}

	vals := [255]any{}
	for i := range mesg.Fields {
		field := &mesg.Fields[i]
		if field.Num >= byte(len(vals)) {
			continue
		}
		vals[field.Num] = field.Value
	}

	return &SegmentLap{
		MessageIndex:                typeconv.ToUint16[typedef.MessageIndex](vals[254]),
		Timestamp:                   typeconv.ToUint32[typedef.DateTime](vals[253]),
		Event:                       typeconv.ToEnum[typedef.Event](vals[0]),
		EventType:                   typeconv.ToEnum[typedef.EventType](vals[1]),
		StartTime:                   typeconv.ToUint32[typedef.DateTime](vals[2]),
		StartPositionLat:            typeconv.ToSint32[int32](vals[3]),
		StartPositionLong:           typeconv.ToSint32[int32](vals[4]),
		EndPositionLat:              typeconv.ToSint32[int32](vals[5]),
		EndPositionLong:             typeconv.ToSint32[int32](vals[6]),
		TotalElapsedTime:            typeconv.ToUint32[uint32](vals[7]),
		TotalTimerTime:              typeconv.ToUint32[uint32](vals[8]),
		TotalDistance:               typeconv.ToUint32[uint32](vals[9]),
		TotalCycles:                 typeconv.ToUint32[uint32](vals[10]),
		TotalCalories:               typeconv.ToUint16[uint16](vals[11]),
		TotalFatCalories:            typeconv.ToUint16[uint16](vals[12]),
		AvgSpeed:                    typeconv.ToUint16[uint16](vals[13]),
		MaxSpeed:                    typeconv.ToUint16[uint16](vals[14]),
		AvgHeartRate:                typeconv.ToUint8[uint8](vals[15]),
		MaxHeartRate:                typeconv.ToUint8[uint8](vals[16]),
		AvgCadence:                  typeconv.ToUint8[uint8](vals[17]),
		MaxCadence:                  typeconv.ToUint8[uint8](vals[18]),
		AvgPower:                    typeconv.ToUint16[uint16](vals[19]),
		MaxPower:                    typeconv.ToUint16[uint16](vals[20]),
		TotalAscent:                 typeconv.ToUint16[uint16](vals[21]),
		TotalDescent:                typeconv.ToUint16[uint16](vals[22]),
		Sport:                       typeconv.ToEnum[typedef.Sport](vals[23]),
		EventGroup:                  typeconv.ToUint8[uint8](vals[24]),
		NecLat:                      typeconv.ToSint32[int32](vals[25]),
		NecLong:                     typeconv.ToSint32[int32](vals[26]),
		SwcLat:                      typeconv.ToSint32[int32](vals[27]),
		SwcLong:                     typeconv.ToSint32[int32](vals[28]),
		Name:                        typeconv.ToString[string](vals[29]),
		NormalizedPower:             typeconv.ToUint16[uint16](vals[30]),
		LeftRightBalance:            typeconv.ToUint16[typedef.LeftRightBalance100](vals[31]),
		SubSport:                    typeconv.ToEnum[typedef.SubSport](vals[32]),
		TotalWork:                   typeconv.ToUint32[uint32](vals[33]),
		AvgAltitude:                 typeconv.ToUint16[uint16](vals[34]),
		MaxAltitude:                 typeconv.ToUint16[uint16](vals[35]),
		GpsAccuracy:                 typeconv.ToUint8[uint8](vals[36]),
		AvgGrade:                    typeconv.ToSint16[int16](vals[37]),
		AvgPosGrade:                 typeconv.ToSint16[int16](vals[38]),
		AvgNegGrade:                 typeconv.ToSint16[int16](vals[39]),
		MaxPosGrade:                 typeconv.ToSint16[int16](vals[40]),
		MaxNegGrade:                 typeconv.ToSint16[int16](vals[41]),
		AvgTemperature:              typeconv.ToSint8[int8](vals[42]),
		MaxTemperature:              typeconv.ToSint8[int8](vals[43]),
		TotalMovingTime:             typeconv.ToUint32[uint32](vals[44]),
		AvgPosVerticalSpeed:         typeconv.ToSint16[int16](vals[45]),
		AvgNegVerticalSpeed:         typeconv.ToSint16[int16](vals[46]),
		MaxPosVerticalSpeed:         typeconv.ToSint16[int16](vals[47]),
		MaxNegVerticalSpeed:         typeconv.ToSint16[int16](vals[48]),
		TimeInHrZone:                typeconv.ToSliceUint32[uint32](vals[49]),
		TimeInSpeedZone:             typeconv.ToSliceUint32[uint32](vals[50]),
		TimeInCadenceZone:           typeconv.ToSliceUint32[uint32](vals[51]),
		TimeInPowerZone:             typeconv.ToSliceUint32[uint32](vals[52]),
		RepetitionNum:               typeconv.ToUint16[uint16](vals[53]),
		MinAltitude:                 typeconv.ToUint16[uint16](vals[54]),
		MinHeartRate:                typeconv.ToUint8[uint8](vals[55]),
		ActiveTime:                  typeconv.ToUint32[uint32](vals[56]),
		WktStepIndex:                typeconv.ToUint16[typedef.MessageIndex](vals[57]),
		SportEvent:                  typeconv.ToEnum[typedef.SportEvent](vals[58]),
		AvgLeftTorqueEffectiveness:  typeconv.ToUint8[uint8](vals[59]),
		AvgRightTorqueEffectiveness: typeconv.ToUint8[uint8](vals[60]),
		AvgLeftPedalSmoothness:      typeconv.ToUint8[uint8](vals[61]),
		AvgRightPedalSmoothness:     typeconv.ToUint8[uint8](vals[62]),
		AvgCombinedPedalSmoothness:  typeconv.ToUint8[uint8](vals[63]),
		Status:                      typeconv.ToEnum[typedef.SegmentLapStatus](vals[64]),
		Uuid:                        typeconv.ToString[string](vals[65]),
		AvgFractionalCadence:        typeconv.ToUint8[uint8](vals[66]),
		MaxFractionalCadence:        typeconv.ToUint8[uint8](vals[67]),
		TotalFractionalCycles:       typeconv.ToUint8[uint8](vals[68]),
		FrontGearShiftCount:         typeconv.ToUint16[uint16](vals[69]),
		RearGearShiftCount:          typeconv.ToUint16[uint16](vals[70]),
		TimeStanding:                typeconv.ToUint32[uint32](vals[71]),
		StandCount:                  typeconv.ToUint16[uint16](vals[72]),
		AvgLeftPco:                  typeconv.ToSint8[int8](vals[73]),
		AvgRightPco:                 typeconv.ToSint8[int8](vals[74]),
		AvgLeftPowerPhase:           typeconv.ToSliceUint8[uint8](vals[75]),
		AvgLeftPowerPhasePeak:       typeconv.ToSliceUint8[uint8](vals[76]),
		AvgRightPowerPhase:          typeconv.ToSliceUint8[uint8](vals[77]),
		AvgRightPowerPhasePeak:      typeconv.ToSliceUint8[uint8](vals[78]),
		AvgPowerPosition:            typeconv.ToSliceUint16[uint16](vals[79]),
		MaxPowerPosition:            typeconv.ToSliceUint16[uint16](vals[80]),
		AvgCadencePosition:          typeconv.ToSliceUint8[uint8](vals[81]),
		MaxCadencePosition:          typeconv.ToSliceUint8[uint8](vals[82]),
		Manufacturer:                typeconv.ToUint16[typedef.Manufacturer](vals[83]),
		TotalGrit:                   typeconv.ToFloat32[float32](vals[84]),
		TotalFlow:                   typeconv.ToFloat32[float32](vals[85]),
		AvgGrit:                     typeconv.ToFloat32[float32](vals[86]),
		AvgFlow:                     typeconv.ToFloat32[float32](vals[87]),
		TotalFractionalAscent:       typeconv.ToUint8[uint8](vals[89]),
		TotalFractionalDescent:      typeconv.ToUint8[uint8](vals[90]),
		EnhancedAvgAltitude:         typeconv.ToUint32[uint32](vals[91]),
		EnhancedMaxAltitude:         typeconv.ToUint32[uint32](vals[92]),
		EnhancedMinAltitude:         typeconv.ToUint32[uint32](vals[93]),

		DeveloperFields: mesg.DeveloperFields,
	}
}

// ToMesg converts SegmentLap into proto.Message.
func (m *SegmentLap) ToMesg(fac Factory) proto.Message {
	mesg := fac.CreateMesgOnly(typedef.MesgNumSegmentLap)
	mesg.Fields = make([]proto.Field, 0, m.size())

	if typeconv.ToUint16[uint16](m.MessageIndex) != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 254)
		field.Value = typeconv.ToUint16[uint16](m.MessageIndex)
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToUint32[uint32](m.Timestamp) != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 253)
		field.Value = typeconv.ToUint32[uint32](m.Timestamp)
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToEnum[byte](m.Event) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 0)
		field.Value = typeconv.ToEnum[byte](m.Event)
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToEnum[byte](m.EventType) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 1)
		field.Value = typeconv.ToEnum[byte](m.EventType)
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToUint32[uint32](m.StartTime) != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 2)
		field.Value = typeconv.ToUint32[uint32](m.StartTime)
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.StartPositionLat != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 3)
		field.Value = m.StartPositionLat
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.StartPositionLong != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 4)
		field.Value = m.StartPositionLong
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.EndPositionLat != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 5)
		field.Value = m.EndPositionLat
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.EndPositionLong != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 6)
		field.Value = m.EndPositionLong
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalElapsedTime != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 7)
		field.Value = m.TotalElapsedTime
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalTimerTime != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 8)
		field.Value = m.TotalTimerTime
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalDistance != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 9)
		field.Value = m.TotalDistance
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalCycles != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 10)
		field.Value = m.TotalCycles
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalCalories != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 11)
		field.Value = m.TotalCalories
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalFatCalories != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 12)
		field.Value = m.TotalFatCalories
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgSpeed != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 13)
		field.Value = m.AvgSpeed
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxSpeed != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 14)
		field.Value = m.MaxSpeed
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgHeartRate != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 15)
		field.Value = m.AvgHeartRate
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxHeartRate != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 16)
		field.Value = m.MaxHeartRate
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgCadence != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 17)
		field.Value = m.AvgCadence
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxCadence != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 18)
		field.Value = m.MaxCadence
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgPower != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 19)
		field.Value = m.AvgPower
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxPower != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 20)
		field.Value = m.MaxPower
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalAscent != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 21)
		field.Value = m.TotalAscent
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalDescent != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 22)
		field.Value = m.TotalDescent
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToEnum[byte](m.Sport) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 23)
		field.Value = typeconv.ToEnum[byte](m.Sport)
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.EventGroup != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 24)
		field.Value = m.EventGroup
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.NecLat != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 25)
		field.Value = m.NecLat
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.NecLong != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 26)
		field.Value = m.NecLong
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.SwcLat != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 27)
		field.Value = m.SwcLat
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.SwcLong != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 28)
		field.Value = m.SwcLong
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Name != basetype.StringInvalid && m.Name != "" {
		field := fac.CreateField(mesg.Num, 29)
		field.Value = m.Name
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.NormalizedPower != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 30)
		field.Value = m.NormalizedPower
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToUint16[uint16](m.LeftRightBalance) != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 31)
		field.Value = typeconv.ToUint16[uint16](m.LeftRightBalance)
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToEnum[byte](m.SubSport) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 32)
		field.Value = typeconv.ToEnum[byte](m.SubSport)
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalWork != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 33)
		field.Value = m.TotalWork
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgAltitude != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 34)
		field.Value = m.AvgAltitude
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxAltitude != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 35)
		field.Value = m.MaxAltitude
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.GpsAccuracy != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 36)
		field.Value = m.GpsAccuracy
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgGrade != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 37)
		field.Value = m.AvgGrade
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgPosGrade != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 38)
		field.Value = m.AvgPosGrade
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgNegGrade != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 39)
		field.Value = m.AvgNegGrade
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxPosGrade != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 40)
		field.Value = m.MaxPosGrade
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxNegGrade != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 41)
		field.Value = m.MaxNegGrade
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgTemperature != basetype.Sint8Invalid {
		field := fac.CreateField(mesg.Num, 42)
		field.Value = m.AvgTemperature
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxTemperature != basetype.Sint8Invalid {
		field := fac.CreateField(mesg.Num, 43)
		field.Value = m.MaxTemperature
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalMovingTime != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 44)
		field.Value = m.TotalMovingTime
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgPosVerticalSpeed != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 45)
		field.Value = m.AvgPosVerticalSpeed
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgNegVerticalSpeed != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 46)
		field.Value = m.AvgNegVerticalSpeed
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxPosVerticalSpeed != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 47)
		field.Value = m.MaxPosVerticalSpeed
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxNegVerticalSpeed != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 48)
		field.Value = m.MaxNegVerticalSpeed
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TimeInHrZone != nil {
		field := fac.CreateField(mesg.Num, 49)
		field.Value = m.TimeInHrZone
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TimeInSpeedZone != nil {
		field := fac.CreateField(mesg.Num, 50)
		field.Value = m.TimeInSpeedZone
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TimeInCadenceZone != nil {
		field := fac.CreateField(mesg.Num, 51)
		field.Value = m.TimeInCadenceZone
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TimeInPowerZone != nil {
		field := fac.CreateField(mesg.Num, 52)
		field.Value = m.TimeInPowerZone
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.RepetitionNum != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 53)
		field.Value = m.RepetitionNum
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MinAltitude != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 54)
		field.Value = m.MinAltitude
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MinHeartRate != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 55)
		field.Value = m.MinHeartRate
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.ActiveTime != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 56)
		field.Value = m.ActiveTime
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToUint16[uint16](m.WktStepIndex) != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 57)
		field.Value = typeconv.ToUint16[uint16](m.WktStepIndex)
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToEnum[byte](m.SportEvent) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 58)
		field.Value = typeconv.ToEnum[byte](m.SportEvent)
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgLeftTorqueEffectiveness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 59)
		field.Value = m.AvgLeftTorqueEffectiveness
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgRightTorqueEffectiveness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 60)
		field.Value = m.AvgRightTorqueEffectiveness
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgLeftPedalSmoothness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 61)
		field.Value = m.AvgLeftPedalSmoothness
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgRightPedalSmoothness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 62)
		field.Value = m.AvgRightPedalSmoothness
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgCombinedPedalSmoothness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 63)
		field.Value = m.AvgCombinedPedalSmoothness
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToEnum[byte](m.Status) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 64)
		field.Value = typeconv.ToEnum[byte](m.Status)
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.Uuid != basetype.StringInvalid && m.Uuid != "" {
		field := fac.CreateField(mesg.Num, 65)
		field.Value = m.Uuid
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgFractionalCadence != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 66)
		field.Value = m.AvgFractionalCadence
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxFractionalCadence != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 67)
		field.Value = m.MaxFractionalCadence
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalFractionalCycles != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 68)
		field.Value = m.TotalFractionalCycles
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.FrontGearShiftCount != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 69)
		field.Value = m.FrontGearShiftCount
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.RearGearShiftCount != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 70)
		field.Value = m.RearGearShiftCount
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TimeStanding != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 71)
		field.Value = m.TimeStanding
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.StandCount != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 72)
		field.Value = m.StandCount
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgLeftPco != basetype.Sint8Invalid {
		field := fac.CreateField(mesg.Num, 73)
		field.Value = m.AvgLeftPco
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgRightPco != basetype.Sint8Invalid {
		field := fac.CreateField(mesg.Num, 74)
		field.Value = m.AvgRightPco
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgLeftPowerPhase != nil {
		field := fac.CreateField(mesg.Num, 75)
		field.Value = m.AvgLeftPowerPhase
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgLeftPowerPhasePeak != nil {
		field := fac.CreateField(mesg.Num, 76)
		field.Value = m.AvgLeftPowerPhasePeak
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgRightPowerPhase != nil {
		field := fac.CreateField(mesg.Num, 77)
		field.Value = m.AvgRightPowerPhase
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgRightPowerPhasePeak != nil {
		field := fac.CreateField(mesg.Num, 78)
		field.Value = m.AvgRightPowerPhasePeak
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgPowerPosition != nil {
		field := fac.CreateField(mesg.Num, 79)
		field.Value = m.AvgPowerPosition
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxPowerPosition != nil {
		field := fac.CreateField(mesg.Num, 80)
		field.Value = m.MaxPowerPosition
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.AvgCadencePosition != nil {
		field := fac.CreateField(mesg.Num, 81)
		field.Value = m.AvgCadencePosition
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.MaxCadencePosition != nil {
		field := fac.CreateField(mesg.Num, 82)
		field.Value = m.MaxCadencePosition
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToUint16[uint16](m.Manufacturer) != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 83)
		field.Value = typeconv.ToUint16[uint16](m.Manufacturer)
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToUint32[uint32](m.TotalGrit) != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 84)
		field.Value = m.TotalGrit
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToUint32[uint32](m.TotalFlow) != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 85)
		field.Value = m.TotalFlow
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToUint32[uint32](m.AvgGrit) != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 86)
		field.Value = m.AvgGrit
		mesg.Fields = append(mesg.Fields, field)
	}
	if typeconv.ToUint32[uint32](m.AvgFlow) != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 87)
		field.Value = m.AvgFlow
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalFractionalAscent != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 89)
		field.Value = m.TotalFractionalAscent
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.TotalFractionalDescent != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 90)
		field.Value = m.TotalFractionalDescent
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.EnhancedAvgAltitude != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 91)
		field.Value = m.EnhancedAvgAltitude
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.EnhancedMaxAltitude != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 92)
		field.Value = m.EnhancedMaxAltitude
		mesg.Fields = append(mesg.Fields, field)
	}
	if m.EnhancedMinAltitude != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 93)
		field.Value = m.EnhancedMinAltitude
		mesg.Fields = append(mesg.Fields, field)
	}

	mesg.DeveloperFields = m.DeveloperFields

	return mesg
}

// size returns size of SegmentLap's valid fields.
func (m *SegmentLap) size() byte {
	var size byte
	if typeconv.ToUint16[uint16](m.MessageIndex) != basetype.Uint16Invalid {
		size++
	}
	if typeconv.ToUint32[uint32](m.Timestamp) != basetype.Uint32Invalid {
		size++
	}
	if typeconv.ToEnum[byte](m.Event) != basetype.EnumInvalid {
		size++
	}
	if typeconv.ToEnum[byte](m.EventType) != basetype.EnumInvalid {
		size++
	}
	if typeconv.ToUint32[uint32](m.StartTime) != basetype.Uint32Invalid {
		size++
	}
	if m.StartPositionLat != basetype.Sint32Invalid {
		size++
	}
	if m.StartPositionLong != basetype.Sint32Invalid {
		size++
	}
	if m.EndPositionLat != basetype.Sint32Invalid {
		size++
	}
	if m.EndPositionLong != basetype.Sint32Invalid {
		size++
	}
	if m.TotalElapsedTime != basetype.Uint32Invalid {
		size++
	}
	if m.TotalTimerTime != basetype.Uint32Invalid {
		size++
	}
	if m.TotalDistance != basetype.Uint32Invalid {
		size++
	}
	if m.TotalCycles != basetype.Uint32Invalid {
		size++
	}
	if m.TotalCalories != basetype.Uint16Invalid {
		size++
	}
	if m.TotalFatCalories != basetype.Uint16Invalid {
		size++
	}
	if m.AvgSpeed != basetype.Uint16Invalid {
		size++
	}
	if m.MaxSpeed != basetype.Uint16Invalid {
		size++
	}
	if m.AvgHeartRate != basetype.Uint8Invalid {
		size++
	}
	if m.MaxHeartRate != basetype.Uint8Invalid {
		size++
	}
	if m.AvgCadence != basetype.Uint8Invalid {
		size++
	}
	if m.MaxCadence != basetype.Uint8Invalid {
		size++
	}
	if m.AvgPower != basetype.Uint16Invalid {
		size++
	}
	if m.MaxPower != basetype.Uint16Invalid {
		size++
	}
	if m.TotalAscent != basetype.Uint16Invalid {
		size++
	}
	if m.TotalDescent != basetype.Uint16Invalid {
		size++
	}
	if typeconv.ToEnum[byte](m.Sport) != basetype.EnumInvalid {
		size++
	}
	if m.EventGroup != basetype.Uint8Invalid {
		size++
	}
	if m.NecLat != basetype.Sint32Invalid {
		size++
	}
	if m.NecLong != basetype.Sint32Invalid {
		size++
	}
	if m.SwcLat != basetype.Sint32Invalid {
		size++
	}
	if m.SwcLong != basetype.Sint32Invalid {
		size++
	}
	if m.Name != basetype.StringInvalid && m.Name != "" {
		size++
	}
	if m.NormalizedPower != basetype.Uint16Invalid {
		size++
	}
	if typeconv.ToUint16[uint16](m.LeftRightBalance) != basetype.Uint16Invalid {
		size++
	}
	if typeconv.ToEnum[byte](m.SubSport) != basetype.EnumInvalid {
		size++
	}
	if m.TotalWork != basetype.Uint32Invalid {
		size++
	}
	if m.AvgAltitude != basetype.Uint16Invalid {
		size++
	}
	if m.MaxAltitude != basetype.Uint16Invalid {
		size++
	}
	if m.GpsAccuracy != basetype.Uint8Invalid {
		size++
	}
	if m.AvgGrade != basetype.Sint16Invalid {
		size++
	}
	if m.AvgPosGrade != basetype.Sint16Invalid {
		size++
	}
	if m.AvgNegGrade != basetype.Sint16Invalid {
		size++
	}
	if m.MaxPosGrade != basetype.Sint16Invalid {
		size++
	}
	if m.MaxNegGrade != basetype.Sint16Invalid {
		size++
	}
	if m.AvgTemperature != basetype.Sint8Invalid {
		size++
	}
	if m.MaxTemperature != basetype.Sint8Invalid {
		size++
	}
	if m.TotalMovingTime != basetype.Uint32Invalid {
		size++
	}
	if m.AvgPosVerticalSpeed != basetype.Sint16Invalid {
		size++
	}
	if m.AvgNegVerticalSpeed != basetype.Sint16Invalid {
		size++
	}
	if m.MaxPosVerticalSpeed != basetype.Sint16Invalid {
		size++
	}
	if m.MaxNegVerticalSpeed != basetype.Sint16Invalid {
		size++
	}
	if m.TimeInHrZone != nil {
		size++
	}
	if m.TimeInSpeedZone != nil {
		size++
	}
	if m.TimeInCadenceZone != nil {
		size++
	}
	if m.TimeInPowerZone != nil {
		size++
	}
	if m.RepetitionNum != basetype.Uint16Invalid {
		size++
	}
	if m.MinAltitude != basetype.Uint16Invalid {
		size++
	}
	if m.MinHeartRate != basetype.Uint8Invalid {
		size++
	}
	if m.ActiveTime != basetype.Uint32Invalid {
		size++
	}
	if typeconv.ToUint16[uint16](m.WktStepIndex) != basetype.Uint16Invalid {
		size++
	}
	if typeconv.ToEnum[byte](m.SportEvent) != basetype.EnumInvalid {
		size++
	}
	if m.AvgLeftTorqueEffectiveness != basetype.Uint8Invalid {
		size++
	}
	if m.AvgRightTorqueEffectiveness != basetype.Uint8Invalid {
		size++
	}
	if m.AvgLeftPedalSmoothness != basetype.Uint8Invalid {
		size++
	}
	if m.AvgRightPedalSmoothness != basetype.Uint8Invalid {
		size++
	}
	if m.AvgCombinedPedalSmoothness != basetype.Uint8Invalid {
		size++
	}
	if typeconv.ToEnum[byte](m.Status) != basetype.EnumInvalid {
		size++
	}
	if m.Uuid != basetype.StringInvalid && m.Uuid != "" {
		size++
	}
	if m.AvgFractionalCadence != basetype.Uint8Invalid {
		size++
	}
	if m.MaxFractionalCadence != basetype.Uint8Invalid {
		size++
	}
	if m.TotalFractionalCycles != basetype.Uint8Invalid {
		size++
	}
	if m.FrontGearShiftCount != basetype.Uint16Invalid {
		size++
	}
	if m.RearGearShiftCount != basetype.Uint16Invalid {
		size++
	}
	if m.TimeStanding != basetype.Uint32Invalid {
		size++
	}
	if m.StandCount != basetype.Uint16Invalid {
		size++
	}
	if m.AvgLeftPco != basetype.Sint8Invalid {
		size++
	}
	if m.AvgRightPco != basetype.Sint8Invalid {
		size++
	}
	if m.AvgLeftPowerPhase != nil {
		size++
	}
	if m.AvgLeftPowerPhasePeak != nil {
		size++
	}
	if m.AvgRightPowerPhase != nil {
		size++
	}
	if m.AvgRightPowerPhasePeak != nil {
		size++
	}
	if m.AvgPowerPosition != nil {
		size++
	}
	if m.MaxPowerPosition != nil {
		size++
	}
	if m.AvgCadencePosition != nil {
		size++
	}
	if m.MaxCadencePosition != nil {
		size++
	}
	if typeconv.ToUint16[uint16](m.Manufacturer) != basetype.Uint16Invalid {
		size++
	}
	if typeconv.ToUint32[uint32](m.TotalGrit) != basetype.Uint32Invalid {
		size++
	}
	if typeconv.ToUint32[uint32](m.TotalFlow) != basetype.Uint32Invalid {
		size++
	}
	if typeconv.ToUint32[uint32](m.AvgGrit) != basetype.Uint32Invalid {
		size++
	}
	if typeconv.ToUint32[uint32](m.AvgFlow) != basetype.Uint32Invalid {
		size++
	}
	if m.TotalFractionalAscent != basetype.Uint8Invalid {
		size++
	}
	if m.TotalFractionalDescent != basetype.Uint8Invalid {
		size++
	}
	if m.EnhancedAvgAltitude != basetype.Uint32Invalid {
		size++
	}
	if m.EnhancedMaxAltitude != basetype.Uint32Invalid {
		size++
	}
	if m.EnhancedMinAltitude != basetype.Uint32Invalid {
		size++
	}
	return size
}
