// Code generated by internal/cmd/fitgen/main.go. DO NOT EDIT.

// Copyright 2023 The FIT SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package mesgdef

import (
	"github.com/muktihari/fit/factory"
	"github.com/muktihari/fit/kit/datetime"
	"github.com/muktihari/fit/kit/semicircles"
	"github.com/muktihari/fit/profile/basetype"
	"github.com/muktihari/fit/profile/typedef"
	"github.com/muktihari/fit/proto"
	"math"
	"time"
)

// SegmentLap is a SegmentLap message.
//
// Note: The order of the fields is optimized using a memory alignment algorithm.
// Do not rely on field indices, such as when using reflection.
type SegmentLap struct {
	Timestamp                   time.Time // Units: s; Lap end time.
	StartTime                   time.Time
	Name                        string
	TimeInHrZone                []uint32 // Array: [N]; Scale: 1000; Units: s
	TimeInSpeedZone             []uint32 // Array: [N]; Scale: 1000; Units: s
	TimeInCadenceZone           []uint32 // Array: [N]; Scale: 1000; Units: s
	TimeInPowerZone             []uint32 // Array: [N]; Scale: 1000; Units: s
	Uuid                        string
	AvgLeftPowerPhase           []uint8  // Array: [N]; Scale: 0.7111111; Units: degrees; Average left power phase angles. Data value indexes defined by power_phase_type.
	AvgLeftPowerPhasePeak       []uint8  // Array: [N]; Scale: 0.7111111; Units: degrees; Average left power phase peak angles. Data value indexes defined by power_phase_type.
	AvgRightPowerPhase          []uint8  // Array: [N]; Scale: 0.7111111; Units: degrees; Average right power phase angles. Data value indexes defined by power_phase_type.
	AvgRightPowerPhasePeak      []uint8  // Array: [N]; Scale: 0.7111111; Units: degrees; Average right power phase peak angles. Data value indexes defined by power_phase_type.
	AvgPowerPosition            []uint16 // Array: [N]; Units: watts; Average power by position. Data value indexes defined by rider_position_type.
	MaxPowerPosition            []uint16 // Array: [N]; Units: watts; Maximum power by position. Data value indexes defined by rider_position_type.
	AvgCadencePosition          []uint8  // Array: [N]; Units: rpm; Average cadence by position. Data value indexes defined by rider_position_type.
	MaxCadencePosition          []uint8  // Array: [N]; Units: rpm; Maximum cadence by position. Data value indexes defined by rider_position_type.
	StartPositionLat            int32    // Units: semicircles
	StartPositionLong           int32    // Units: semicircles
	EndPositionLat              int32    // Units: semicircles
	EndPositionLong             int32    // Units: semicircles
	TotalElapsedTime            uint32   // Scale: 1000; Units: s; Time (includes pauses)
	TotalTimerTime              uint32   // Scale: 1000; Units: s; Timer Time (excludes pauses)
	TotalDistance               uint32   // Scale: 100; Units: m
	TotalCycles                 uint32   // Units: cycles
	NecLat                      int32    // Units: semicircles; North east corner latitude.
	NecLong                     int32    // Units: semicircles; North east corner longitude.
	SwcLat                      int32    // Units: semicircles; South west corner latitude.
	SwcLong                     int32    // Units: semicircles; South west corner latitude.
	TotalWork                   uint32   // Units: J
	TotalMovingTime             uint32   // Scale: 1000; Units: s
	ActiveTime                  uint32   // Scale: 1000; Units: s
	TimeStanding                uint32   // Scale: 1000; Units: s; Total time spent in the standing position
	TotalGrit                   float32  // Units: kGrit; The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes.
	TotalFlow                   float32  // Units: Flow; The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals.
	AvgGrit                     float32  // Units: kGrit; The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes.
	AvgFlow                     float32  // Units: Flow; The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals.
	EnhancedAvgAltitude         uint32   // Scale: 5; Offset: 500; Units: m
	EnhancedMaxAltitude         uint32   // Scale: 5; Offset: 500; Units: m
	EnhancedMinAltitude         uint32   // Scale: 5; Offset: 500; Units: m
	MessageIndex                typedef.MessageIndex
	TotalCalories               uint16 // Units: kcal
	TotalFatCalories            uint16 // Units: kcal; If New Leaf
	AvgSpeed                    uint16 // Scale: 1000; Units: m/s
	MaxSpeed                    uint16 // Scale: 1000; Units: m/s
	AvgPower                    uint16 // Units: watts; total_power / total_timer_time if non_zero_avg_power otherwise total_power / total_elapsed_time
	MaxPower                    uint16 // Units: watts
	TotalAscent                 uint16 // Units: m
	TotalDescent                uint16 // Units: m
	NormalizedPower             uint16 // Units: watts
	LeftRightBalance            typedef.LeftRightBalance100
	AvgAltitude                 uint16 // Scale: 5; Offset: 500; Units: m
	MaxAltitude                 uint16 // Scale: 5; Offset: 500; Units: m
	AvgGrade                    int16  // Scale: 100; Units: %
	AvgPosGrade                 int16  // Scale: 100; Units: %
	AvgNegGrade                 int16  // Scale: 100; Units: %
	MaxPosGrade                 int16  // Scale: 100; Units: %
	MaxNegGrade                 int16  // Scale: 100; Units: %
	AvgPosVerticalSpeed         int16  // Scale: 1000; Units: m/s
	AvgNegVerticalSpeed         int16  // Scale: 1000; Units: m/s
	MaxPosVerticalSpeed         int16  // Scale: 1000; Units: m/s
	MaxNegVerticalSpeed         int16  // Scale: 1000; Units: m/s
	RepetitionNum               uint16
	MinAltitude                 uint16 // Scale: 5; Offset: 500; Units: m
	WktStepIndex                typedef.MessageIndex
	FrontGearShiftCount         uint16
	RearGearShiftCount          uint16
	StandCount                  uint16               // Number of transitions to the standing state
	Manufacturer                typedef.Manufacturer // Manufacturer that produced the segment
	Event                       typedef.Event
	EventType                   typedef.EventType
	AvgHeartRate                uint8 // Units: bpm
	MaxHeartRate                uint8 // Units: bpm
	AvgCadence                  uint8 // Units: rpm; total_cycles / total_timer_time if non_zero_avg_cadence otherwise total_cycles / total_elapsed_time
	MaxCadence                  uint8 // Units: rpm
	Sport                       typedef.Sport
	EventGroup                  uint8
	SubSport                    typedef.SubSport
	GpsAccuracy                 uint8 // Units: m
	AvgTemperature              int8  // Units: C
	MaxTemperature              int8  // Units: C
	MinHeartRate                uint8 // Units: bpm
	SportEvent                  typedef.SportEvent
	AvgLeftTorqueEffectiveness  uint8 // Scale: 2; Units: percent
	AvgRightTorqueEffectiveness uint8 // Scale: 2; Units: percent
	AvgLeftPedalSmoothness      uint8 // Scale: 2; Units: percent
	AvgRightPedalSmoothness     uint8 // Scale: 2; Units: percent
	AvgCombinedPedalSmoothness  uint8 // Scale: 2; Units: percent
	Status                      typedef.SegmentLapStatus
	AvgFractionalCadence        uint8 // Scale: 128; Units: rpm; fractional part of the avg_cadence
	MaxFractionalCadence        uint8 // Scale: 128; Units: rpm; fractional part of the max_cadence
	TotalFractionalCycles       uint8 // Scale: 128; Units: cycles; fractional part of the total_cycles
	AvgLeftPco                  int8  // Units: mm; Average left platform center offset
	AvgRightPco                 int8  // Units: mm; Average right platform center offset
	TotalFractionalAscent       uint8 // Scale: 100; Units: m; fractional part of total_ascent
	TotalFractionalDescent      uint8 // Scale: 100; Units: m; fractional part of total_descent

	state [12]uint8 // Used for tracking expanded fields.

	// Developer Fields are dynamic, can't be mapped as struct's fields.
	// [Added since protocol version 2.0]
	DeveloperFields []proto.DeveloperField
}

// NewSegmentLap creates new SegmentLap struct based on given mesg.
// If mesg is nil, it will return SegmentLap with all fields being set to its corresponding invalid value.
func NewSegmentLap(mesg *proto.Message) *SegmentLap {
	vals := [255]proto.Value{}

	var state [12]uint8
	var developerFields []proto.DeveloperField
	if mesg != nil {
		for i := range mesg.Fields {
			if mesg.Fields[i].Num >= byte(len(vals)) {
				continue
			}
			if mesg.Fields[i].Num < 94 && mesg.Fields[i].IsExpandedField {
				pos := mesg.Fields[i].Num / 8
				state[pos] |= 1 << (mesg.Fields[i].Num - (8 * pos))
			}
			vals[mesg.Fields[i].Num] = mesg.Fields[i].Value
		}
		developerFields = mesg.DeveloperFields
	}

	return &SegmentLap{
		MessageIndex:                typedef.MessageIndex(vals[254].Uint16()),
		Timestamp:                   datetime.ToTime(vals[253].Uint32()),
		Event:                       typedef.Event(vals[0].Uint8()),
		EventType:                   typedef.EventType(vals[1].Uint8()),
		StartTime:                   datetime.ToTime(vals[2].Uint32()),
		StartPositionLat:            vals[3].Int32(),
		StartPositionLong:           vals[4].Int32(),
		EndPositionLat:              vals[5].Int32(),
		EndPositionLong:             vals[6].Int32(),
		TotalElapsedTime:            vals[7].Uint32(),
		TotalTimerTime:              vals[8].Uint32(),
		TotalDistance:               vals[9].Uint32(),
		TotalCycles:                 vals[10].Uint32(),
		TotalCalories:               vals[11].Uint16(),
		TotalFatCalories:            vals[12].Uint16(),
		AvgSpeed:                    vals[13].Uint16(),
		MaxSpeed:                    vals[14].Uint16(),
		AvgHeartRate:                vals[15].Uint8(),
		MaxHeartRate:                vals[16].Uint8(),
		AvgCadence:                  vals[17].Uint8(),
		MaxCadence:                  vals[18].Uint8(),
		AvgPower:                    vals[19].Uint16(),
		MaxPower:                    vals[20].Uint16(),
		TotalAscent:                 vals[21].Uint16(),
		TotalDescent:                vals[22].Uint16(),
		Sport:                       typedef.Sport(vals[23].Uint8()),
		EventGroup:                  vals[24].Uint8(),
		NecLat:                      vals[25].Int32(),
		NecLong:                     vals[26].Int32(),
		SwcLat:                      vals[27].Int32(),
		SwcLong:                     vals[28].Int32(),
		Name:                        vals[29].String(),
		NormalizedPower:             vals[30].Uint16(),
		LeftRightBalance:            typedef.LeftRightBalance100(vals[31].Uint16()),
		SubSport:                    typedef.SubSport(vals[32].Uint8()),
		TotalWork:                   vals[33].Uint32(),
		AvgAltitude:                 vals[34].Uint16(),
		MaxAltitude:                 vals[35].Uint16(),
		GpsAccuracy:                 vals[36].Uint8(),
		AvgGrade:                    vals[37].Int16(),
		AvgPosGrade:                 vals[38].Int16(),
		AvgNegGrade:                 vals[39].Int16(),
		MaxPosGrade:                 vals[40].Int16(),
		MaxNegGrade:                 vals[41].Int16(),
		AvgTemperature:              vals[42].Int8(),
		MaxTemperature:              vals[43].Int8(),
		TotalMovingTime:             vals[44].Uint32(),
		AvgPosVerticalSpeed:         vals[45].Int16(),
		AvgNegVerticalSpeed:         vals[46].Int16(),
		MaxPosVerticalSpeed:         vals[47].Int16(),
		MaxNegVerticalSpeed:         vals[48].Int16(),
		TimeInHrZone:                vals[49].SliceUint32(),
		TimeInSpeedZone:             vals[50].SliceUint32(),
		TimeInCadenceZone:           vals[51].SliceUint32(),
		TimeInPowerZone:             vals[52].SliceUint32(),
		RepetitionNum:               vals[53].Uint16(),
		MinAltitude:                 vals[54].Uint16(),
		MinHeartRate:                vals[55].Uint8(),
		ActiveTime:                  vals[56].Uint32(),
		WktStepIndex:                typedef.MessageIndex(vals[57].Uint16()),
		SportEvent:                  typedef.SportEvent(vals[58].Uint8()),
		AvgLeftTorqueEffectiveness:  vals[59].Uint8(),
		AvgRightTorqueEffectiveness: vals[60].Uint8(),
		AvgLeftPedalSmoothness:      vals[61].Uint8(),
		AvgRightPedalSmoothness:     vals[62].Uint8(),
		AvgCombinedPedalSmoothness:  vals[63].Uint8(),
		Status:                      typedef.SegmentLapStatus(vals[64].Uint8()),
		Uuid:                        vals[65].String(),
		AvgFractionalCadence:        vals[66].Uint8(),
		MaxFractionalCadence:        vals[67].Uint8(),
		TotalFractionalCycles:       vals[68].Uint8(),
		FrontGearShiftCount:         vals[69].Uint16(),
		RearGearShiftCount:          vals[70].Uint16(),
		TimeStanding:                vals[71].Uint32(),
		StandCount:                  vals[72].Uint16(),
		AvgLeftPco:                  vals[73].Int8(),
		AvgRightPco:                 vals[74].Int8(),
		AvgLeftPowerPhase:           vals[75].SliceUint8(),
		AvgLeftPowerPhasePeak:       vals[76].SliceUint8(),
		AvgRightPowerPhase:          vals[77].SliceUint8(),
		AvgRightPowerPhasePeak:      vals[78].SliceUint8(),
		AvgPowerPosition:            vals[79].SliceUint16(),
		MaxPowerPosition:            vals[80].SliceUint16(),
		AvgCadencePosition:          vals[81].SliceUint8(),
		MaxCadencePosition:          vals[82].SliceUint8(),
		Manufacturer:                typedef.Manufacturer(vals[83].Uint16()),
		TotalGrit:                   vals[84].Float32(),
		TotalFlow:                   vals[85].Float32(),
		AvgGrit:                     vals[86].Float32(),
		AvgFlow:                     vals[87].Float32(),
		TotalFractionalAscent:       vals[89].Uint8(),
		TotalFractionalDescent:      vals[90].Uint8(),
		EnhancedAvgAltitude:         vals[91].Uint32(),
		EnhancedMaxAltitude:         vals[92].Uint32(),
		EnhancedMinAltitude:         vals[93].Uint32(),

		state: state,

		DeveloperFields: developerFields,
	}
}

// ToMesg converts SegmentLap into proto.Message. If options is nil, default options will be used.
func (m *SegmentLap) ToMesg(options *Options) proto.Message {
	if options == nil {
		options = defaultOptions
	} else if options.Factory == nil {
		options.Factory = factory.StandardFactory()
	}

	fac := options.Factory

	arr := pool.Get().(*[255]proto.Field)
	defer pool.Put(arr)

	fields := arr[:0] // Create slice from array with zero len.
	mesg := proto.Message{Num: typedef.MesgNumSegmentLap}

	if uint16(m.MessageIndex) != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 254)
		field.Value = proto.Uint16(uint16(m.MessageIndex))
		fields = append(fields, field)
	}
	if datetime.ToUint32(m.Timestamp) != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 253)
		field.Value = proto.Uint32(datetime.ToUint32(m.Timestamp))
		fields = append(fields, field)
	}
	if byte(m.Event) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 0)
		field.Value = proto.Uint8(byte(m.Event))
		fields = append(fields, field)
	}
	if byte(m.EventType) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 1)
		field.Value = proto.Uint8(byte(m.EventType))
		fields = append(fields, field)
	}
	if datetime.ToUint32(m.StartTime) != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 2)
		field.Value = proto.Uint32(datetime.ToUint32(m.StartTime))
		fields = append(fields, field)
	}
	if m.StartPositionLat != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 3)
		field.Value = proto.Int32(m.StartPositionLat)
		fields = append(fields, field)
	}
	if m.StartPositionLong != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 4)
		field.Value = proto.Int32(m.StartPositionLong)
		fields = append(fields, field)
	}
	if m.EndPositionLat != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 5)
		field.Value = proto.Int32(m.EndPositionLat)
		fields = append(fields, field)
	}
	if m.EndPositionLong != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 6)
		field.Value = proto.Int32(m.EndPositionLong)
		fields = append(fields, field)
	}
	if m.TotalElapsedTime != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 7)
		field.Value = proto.Uint32(m.TotalElapsedTime)
		fields = append(fields, field)
	}
	if m.TotalTimerTime != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 8)
		field.Value = proto.Uint32(m.TotalTimerTime)
		fields = append(fields, field)
	}
	if m.TotalDistance != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 9)
		field.Value = proto.Uint32(m.TotalDistance)
		fields = append(fields, field)
	}
	if m.TotalCycles != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 10)
		field.Value = proto.Uint32(m.TotalCycles)
		fields = append(fields, field)
	}
	if m.TotalCalories != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 11)
		field.Value = proto.Uint16(m.TotalCalories)
		fields = append(fields, field)
	}
	if m.TotalFatCalories != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 12)
		field.Value = proto.Uint16(m.TotalFatCalories)
		fields = append(fields, field)
	}
	if m.AvgSpeed != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 13)
		field.Value = proto.Uint16(m.AvgSpeed)
		fields = append(fields, field)
	}
	if m.MaxSpeed != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 14)
		field.Value = proto.Uint16(m.MaxSpeed)
		fields = append(fields, field)
	}
	if m.AvgHeartRate != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 15)
		field.Value = proto.Uint8(m.AvgHeartRate)
		fields = append(fields, field)
	}
	if m.MaxHeartRate != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 16)
		field.Value = proto.Uint8(m.MaxHeartRate)
		fields = append(fields, field)
	}
	if m.AvgCadence != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 17)
		field.Value = proto.Uint8(m.AvgCadence)
		fields = append(fields, field)
	}
	if m.MaxCadence != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 18)
		field.Value = proto.Uint8(m.MaxCadence)
		fields = append(fields, field)
	}
	if m.AvgPower != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 19)
		field.Value = proto.Uint16(m.AvgPower)
		fields = append(fields, field)
	}
	if m.MaxPower != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 20)
		field.Value = proto.Uint16(m.MaxPower)
		fields = append(fields, field)
	}
	if m.TotalAscent != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 21)
		field.Value = proto.Uint16(m.TotalAscent)
		fields = append(fields, field)
	}
	if m.TotalDescent != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 22)
		field.Value = proto.Uint16(m.TotalDescent)
		fields = append(fields, field)
	}
	if byte(m.Sport) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 23)
		field.Value = proto.Uint8(byte(m.Sport))
		fields = append(fields, field)
	}
	if m.EventGroup != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 24)
		field.Value = proto.Uint8(m.EventGroup)
		fields = append(fields, field)
	}
	if m.NecLat != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 25)
		field.Value = proto.Int32(m.NecLat)
		fields = append(fields, field)
	}
	if m.NecLong != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 26)
		field.Value = proto.Int32(m.NecLong)
		fields = append(fields, field)
	}
	if m.SwcLat != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 27)
		field.Value = proto.Int32(m.SwcLat)
		fields = append(fields, field)
	}
	if m.SwcLong != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 28)
		field.Value = proto.Int32(m.SwcLong)
		fields = append(fields, field)
	}
	if m.Name != basetype.StringInvalid && m.Name != "" {
		field := fac.CreateField(mesg.Num, 29)
		field.Value = proto.String(m.Name)
		fields = append(fields, field)
	}
	if m.NormalizedPower != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 30)
		field.Value = proto.Uint16(m.NormalizedPower)
		fields = append(fields, field)
	}
	if uint16(m.LeftRightBalance) != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 31)
		field.Value = proto.Uint16(uint16(m.LeftRightBalance))
		fields = append(fields, field)
	}
	if byte(m.SubSport) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 32)
		field.Value = proto.Uint8(byte(m.SubSport))
		fields = append(fields, field)
	}
	if m.TotalWork != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 33)
		field.Value = proto.Uint32(m.TotalWork)
		fields = append(fields, field)
	}
	if m.AvgAltitude != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 34)
		field.Value = proto.Uint16(m.AvgAltitude)
		fields = append(fields, field)
	}
	if m.MaxAltitude != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 35)
		field.Value = proto.Uint16(m.MaxAltitude)
		fields = append(fields, field)
	}
	if m.GpsAccuracy != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 36)
		field.Value = proto.Uint8(m.GpsAccuracy)
		fields = append(fields, field)
	}
	if m.AvgGrade != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 37)
		field.Value = proto.Int16(m.AvgGrade)
		fields = append(fields, field)
	}
	if m.AvgPosGrade != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 38)
		field.Value = proto.Int16(m.AvgPosGrade)
		fields = append(fields, field)
	}
	if m.AvgNegGrade != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 39)
		field.Value = proto.Int16(m.AvgNegGrade)
		fields = append(fields, field)
	}
	if m.MaxPosGrade != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 40)
		field.Value = proto.Int16(m.MaxPosGrade)
		fields = append(fields, field)
	}
	if m.MaxNegGrade != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 41)
		field.Value = proto.Int16(m.MaxNegGrade)
		fields = append(fields, field)
	}
	if m.AvgTemperature != basetype.Sint8Invalid {
		field := fac.CreateField(mesg.Num, 42)
		field.Value = proto.Int8(m.AvgTemperature)
		fields = append(fields, field)
	}
	if m.MaxTemperature != basetype.Sint8Invalid {
		field := fac.CreateField(mesg.Num, 43)
		field.Value = proto.Int8(m.MaxTemperature)
		fields = append(fields, field)
	}
	if m.TotalMovingTime != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 44)
		field.Value = proto.Uint32(m.TotalMovingTime)
		fields = append(fields, field)
	}
	if m.AvgPosVerticalSpeed != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 45)
		field.Value = proto.Int16(m.AvgPosVerticalSpeed)
		fields = append(fields, field)
	}
	if m.AvgNegVerticalSpeed != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 46)
		field.Value = proto.Int16(m.AvgNegVerticalSpeed)
		fields = append(fields, field)
	}
	if m.MaxPosVerticalSpeed != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 47)
		field.Value = proto.Int16(m.MaxPosVerticalSpeed)
		fields = append(fields, field)
	}
	if m.MaxNegVerticalSpeed != basetype.Sint16Invalid {
		field := fac.CreateField(mesg.Num, 48)
		field.Value = proto.Int16(m.MaxNegVerticalSpeed)
		fields = append(fields, field)
	}
	if m.TimeInHrZone != nil {
		field := fac.CreateField(mesg.Num, 49)
		field.Value = proto.SliceUint32(m.TimeInHrZone)
		fields = append(fields, field)
	}
	if m.TimeInSpeedZone != nil {
		field := fac.CreateField(mesg.Num, 50)
		field.Value = proto.SliceUint32(m.TimeInSpeedZone)
		fields = append(fields, field)
	}
	if m.TimeInCadenceZone != nil {
		field := fac.CreateField(mesg.Num, 51)
		field.Value = proto.SliceUint32(m.TimeInCadenceZone)
		fields = append(fields, field)
	}
	if m.TimeInPowerZone != nil {
		field := fac.CreateField(mesg.Num, 52)
		field.Value = proto.SliceUint32(m.TimeInPowerZone)
		fields = append(fields, field)
	}
	if m.RepetitionNum != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 53)
		field.Value = proto.Uint16(m.RepetitionNum)
		fields = append(fields, field)
	}
	if m.MinAltitude != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 54)
		field.Value = proto.Uint16(m.MinAltitude)
		fields = append(fields, field)
	}
	if m.MinHeartRate != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 55)
		field.Value = proto.Uint8(m.MinHeartRate)
		fields = append(fields, field)
	}
	if m.ActiveTime != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 56)
		field.Value = proto.Uint32(m.ActiveTime)
		fields = append(fields, field)
	}
	if uint16(m.WktStepIndex) != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 57)
		field.Value = proto.Uint16(uint16(m.WktStepIndex))
		fields = append(fields, field)
	}
	if byte(m.SportEvent) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 58)
		field.Value = proto.Uint8(byte(m.SportEvent))
		fields = append(fields, field)
	}
	if m.AvgLeftTorqueEffectiveness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 59)
		field.Value = proto.Uint8(m.AvgLeftTorqueEffectiveness)
		fields = append(fields, field)
	}
	if m.AvgRightTorqueEffectiveness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 60)
		field.Value = proto.Uint8(m.AvgRightTorqueEffectiveness)
		fields = append(fields, field)
	}
	if m.AvgLeftPedalSmoothness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 61)
		field.Value = proto.Uint8(m.AvgLeftPedalSmoothness)
		fields = append(fields, field)
	}
	if m.AvgRightPedalSmoothness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 62)
		field.Value = proto.Uint8(m.AvgRightPedalSmoothness)
		fields = append(fields, field)
	}
	if m.AvgCombinedPedalSmoothness != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 63)
		field.Value = proto.Uint8(m.AvgCombinedPedalSmoothness)
		fields = append(fields, field)
	}
	if byte(m.Status) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 64)
		field.Value = proto.Uint8(byte(m.Status))
		fields = append(fields, field)
	}
	if m.Uuid != basetype.StringInvalid && m.Uuid != "" {
		field := fac.CreateField(mesg.Num, 65)
		field.Value = proto.String(m.Uuid)
		fields = append(fields, field)
	}
	if m.AvgFractionalCadence != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 66)
		field.Value = proto.Uint8(m.AvgFractionalCadence)
		fields = append(fields, field)
	}
	if m.MaxFractionalCadence != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 67)
		field.Value = proto.Uint8(m.MaxFractionalCadence)
		fields = append(fields, field)
	}
	if m.TotalFractionalCycles != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 68)
		field.Value = proto.Uint8(m.TotalFractionalCycles)
		fields = append(fields, field)
	}
	if m.FrontGearShiftCount != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 69)
		field.Value = proto.Uint16(m.FrontGearShiftCount)
		fields = append(fields, field)
	}
	if m.RearGearShiftCount != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 70)
		field.Value = proto.Uint16(m.RearGearShiftCount)
		fields = append(fields, field)
	}
	if m.TimeStanding != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 71)
		field.Value = proto.Uint32(m.TimeStanding)
		fields = append(fields, field)
	}
	if m.StandCount != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 72)
		field.Value = proto.Uint16(m.StandCount)
		fields = append(fields, field)
	}
	if m.AvgLeftPco != basetype.Sint8Invalid {
		field := fac.CreateField(mesg.Num, 73)
		field.Value = proto.Int8(m.AvgLeftPco)
		fields = append(fields, field)
	}
	if m.AvgRightPco != basetype.Sint8Invalid {
		field := fac.CreateField(mesg.Num, 74)
		field.Value = proto.Int8(m.AvgRightPco)
		fields = append(fields, field)
	}
	if m.AvgLeftPowerPhase != nil {
		field := fac.CreateField(mesg.Num, 75)
		field.Value = proto.SliceUint8(m.AvgLeftPowerPhase)
		fields = append(fields, field)
	}
	if m.AvgLeftPowerPhasePeak != nil {
		field := fac.CreateField(mesg.Num, 76)
		field.Value = proto.SliceUint8(m.AvgLeftPowerPhasePeak)
		fields = append(fields, field)
	}
	if m.AvgRightPowerPhase != nil {
		field := fac.CreateField(mesg.Num, 77)
		field.Value = proto.SliceUint8(m.AvgRightPowerPhase)
		fields = append(fields, field)
	}
	if m.AvgRightPowerPhasePeak != nil {
		field := fac.CreateField(mesg.Num, 78)
		field.Value = proto.SliceUint8(m.AvgRightPowerPhasePeak)
		fields = append(fields, field)
	}
	if m.AvgPowerPosition != nil {
		field := fac.CreateField(mesg.Num, 79)
		field.Value = proto.SliceUint16(m.AvgPowerPosition)
		fields = append(fields, field)
	}
	if m.MaxPowerPosition != nil {
		field := fac.CreateField(mesg.Num, 80)
		field.Value = proto.SliceUint16(m.MaxPowerPosition)
		fields = append(fields, field)
	}
	if m.AvgCadencePosition != nil {
		field := fac.CreateField(mesg.Num, 81)
		field.Value = proto.SliceUint8(m.AvgCadencePosition)
		fields = append(fields, field)
	}
	if m.MaxCadencePosition != nil {
		field := fac.CreateField(mesg.Num, 82)
		field.Value = proto.SliceUint8(m.MaxCadencePosition)
		fields = append(fields, field)
	}
	if uint16(m.Manufacturer) != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 83)
		field.Value = proto.Uint16(uint16(m.Manufacturer))
		fields = append(fields, field)
	}
	if math.Float32bits(m.TotalGrit) != basetype.Float32Invalid {
		field := fac.CreateField(mesg.Num, 84)
		field.Value = proto.Float32(m.TotalGrit)
		fields = append(fields, field)
	}
	if math.Float32bits(m.TotalFlow) != basetype.Float32Invalid {
		field := fac.CreateField(mesg.Num, 85)
		field.Value = proto.Float32(m.TotalFlow)
		fields = append(fields, field)
	}
	if math.Float32bits(m.AvgGrit) != basetype.Float32Invalid {
		field := fac.CreateField(mesg.Num, 86)
		field.Value = proto.Float32(m.AvgGrit)
		fields = append(fields, field)
	}
	if math.Float32bits(m.AvgFlow) != basetype.Float32Invalid {
		field := fac.CreateField(mesg.Num, 87)
		field.Value = proto.Float32(m.AvgFlow)
		fields = append(fields, field)
	}
	if m.TotalFractionalAscent != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 89)
		field.Value = proto.Uint8(m.TotalFractionalAscent)
		fields = append(fields, field)
	}
	if m.TotalFractionalDescent != basetype.Uint8Invalid {
		field := fac.CreateField(mesg.Num, 90)
		field.Value = proto.Uint8(m.TotalFractionalDescent)
		fields = append(fields, field)
	}
	if m.EnhancedAvgAltitude != basetype.Uint32Invalid {
		if expanded := m.IsExpandedField(91); !expanded || (expanded && options.IncludeExpandedFields) {
			field := fac.CreateField(mesg.Num, 91)
			field.Value = proto.Uint32(m.EnhancedAvgAltitude)
			field.IsExpandedField = m.IsExpandedField(91)
			fields = append(fields, field)
		}
	}
	if m.EnhancedMaxAltitude != basetype.Uint32Invalid {
		if expanded := m.IsExpandedField(92); !expanded || (expanded && options.IncludeExpandedFields) {
			field := fac.CreateField(mesg.Num, 92)
			field.Value = proto.Uint32(m.EnhancedMaxAltitude)
			field.IsExpandedField = m.IsExpandedField(92)
			fields = append(fields, field)
		}
	}
	if m.EnhancedMinAltitude != basetype.Uint32Invalid {
		if expanded := m.IsExpandedField(93); !expanded || (expanded && options.IncludeExpandedFields) {
			field := fac.CreateField(mesg.Num, 93)
			field.Value = proto.Uint32(m.EnhancedMinAltitude)
			field.IsExpandedField = m.IsExpandedField(93)
			fields = append(fields, field)
		}
	}

	mesg.Fields = make([]proto.Field, len(fields))
	copy(mesg.Fields, fields)

	mesg.DeveloperFields = m.DeveloperFields

	return mesg
}

// GetTotalCycles returns Dynamic Field interpretation of TotalCycles. Otherwise, returns the original value of TotalCycles.
//
// Based on m.Sport:
//   - name: "total_strokes", units: "strokes" , value: uint32(m.TotalCycles)
//
// Otherwise:
//   - name: "total_cycles", units: "cycles" , value: m.TotalCycles
func (m *SegmentLap) GetTotalCycles() (name string, value any) {
	switch m.Sport {
	case typedef.SportCycling:
		return "total_strokes", uint32(m.TotalCycles)
	}
	return "total_cycles", m.TotalCycles
}

// TimestampUint32 returns Timestamp in uint32 (seconds since FIT's epoch) instead of time.Time.
func (m *SegmentLap) TimestampUint32() uint32 { return datetime.ToUint32(m.Timestamp) }

// StartTimeUint32 returns StartTime in uint32 (seconds since FIT's epoch) instead of time.Time.
func (m *SegmentLap) StartTimeUint32() uint32 { return datetime.ToUint32(m.StartTime) }

// TotalElapsedTimeScaled return TotalElapsedTime in its scaled value.
// If TotalElapsedTime value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: s; Time (includes pauses)
func (m *SegmentLap) TotalElapsedTimeScaled() float64 {
	if m.TotalElapsedTime == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.TotalElapsedTime)/1000 - 0
}

// TotalTimerTimeScaled return TotalTimerTime in its scaled value.
// If TotalTimerTime value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: s; Timer Time (excludes pauses)
func (m *SegmentLap) TotalTimerTimeScaled() float64 {
	if m.TotalTimerTime == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.TotalTimerTime)/1000 - 0
}

// TotalDistanceScaled return TotalDistance in its scaled value.
// If TotalDistance value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: m
func (m *SegmentLap) TotalDistanceScaled() float64 {
	if m.TotalDistance == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.TotalDistance)/100 - 0
}

// AvgSpeedScaled return AvgSpeed in its scaled value.
// If AvgSpeed value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: m/s
func (m *SegmentLap) AvgSpeedScaled() float64 {
	if m.AvgSpeed == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgSpeed)/1000 - 0
}

// MaxSpeedScaled return MaxSpeed in its scaled value.
// If MaxSpeed value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: m/s
func (m *SegmentLap) MaxSpeedScaled() float64 {
	if m.MaxSpeed == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.MaxSpeed)/1000 - 0
}

// AvgAltitudeScaled return AvgAltitude in its scaled value.
// If AvgAltitude value is invalid, float64 invalid value will be returned.
//
// Scale: 5; Offset: 500; Units: m
func (m *SegmentLap) AvgAltitudeScaled() float64 {
	if m.AvgAltitude == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgAltitude)/5 - 500
}

// MaxAltitudeScaled return MaxAltitude in its scaled value.
// If MaxAltitude value is invalid, float64 invalid value will be returned.
//
// Scale: 5; Offset: 500; Units: m
func (m *SegmentLap) MaxAltitudeScaled() float64 {
	if m.MaxAltitude == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.MaxAltitude)/5 - 500
}

// AvgGradeScaled return AvgGrade in its scaled value.
// If AvgGrade value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: %
func (m *SegmentLap) AvgGradeScaled() float64 {
	if m.AvgGrade == basetype.Sint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgGrade)/100 - 0
}

// AvgPosGradeScaled return AvgPosGrade in its scaled value.
// If AvgPosGrade value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: %
func (m *SegmentLap) AvgPosGradeScaled() float64 {
	if m.AvgPosGrade == basetype.Sint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgPosGrade)/100 - 0
}

// AvgNegGradeScaled return AvgNegGrade in its scaled value.
// If AvgNegGrade value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: %
func (m *SegmentLap) AvgNegGradeScaled() float64 {
	if m.AvgNegGrade == basetype.Sint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgNegGrade)/100 - 0
}

// MaxPosGradeScaled return MaxPosGrade in its scaled value.
// If MaxPosGrade value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: %
func (m *SegmentLap) MaxPosGradeScaled() float64 {
	if m.MaxPosGrade == basetype.Sint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.MaxPosGrade)/100 - 0
}

// MaxNegGradeScaled return MaxNegGrade in its scaled value.
// If MaxNegGrade value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: %
func (m *SegmentLap) MaxNegGradeScaled() float64 {
	if m.MaxNegGrade == basetype.Sint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.MaxNegGrade)/100 - 0
}

// TotalMovingTimeScaled return TotalMovingTime in its scaled value.
// If TotalMovingTime value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: s
func (m *SegmentLap) TotalMovingTimeScaled() float64 {
	if m.TotalMovingTime == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.TotalMovingTime)/1000 - 0
}

// AvgPosVerticalSpeedScaled return AvgPosVerticalSpeed in its scaled value.
// If AvgPosVerticalSpeed value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: m/s
func (m *SegmentLap) AvgPosVerticalSpeedScaled() float64 {
	if m.AvgPosVerticalSpeed == basetype.Sint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgPosVerticalSpeed)/1000 - 0
}

// AvgNegVerticalSpeedScaled return AvgNegVerticalSpeed in its scaled value.
// If AvgNegVerticalSpeed value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: m/s
func (m *SegmentLap) AvgNegVerticalSpeedScaled() float64 {
	if m.AvgNegVerticalSpeed == basetype.Sint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgNegVerticalSpeed)/1000 - 0
}

// MaxPosVerticalSpeedScaled return MaxPosVerticalSpeed in its scaled value.
// If MaxPosVerticalSpeed value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: m/s
func (m *SegmentLap) MaxPosVerticalSpeedScaled() float64 {
	if m.MaxPosVerticalSpeed == basetype.Sint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.MaxPosVerticalSpeed)/1000 - 0
}

// MaxNegVerticalSpeedScaled return MaxNegVerticalSpeed in its scaled value.
// If MaxNegVerticalSpeed value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: m/s
func (m *SegmentLap) MaxNegVerticalSpeedScaled() float64 {
	if m.MaxNegVerticalSpeed == basetype.Sint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.MaxNegVerticalSpeed)/1000 - 0
}

// TimeInHrZoneScaled return TimeInHrZone in its scaled value.
// If TimeInHrZone value is invalid, nil will be returned.
//
// Array: [N]; Scale: 1000; Units: s
func (m *SegmentLap) TimeInHrZoneScaled() []float64 {
	if m.TimeInHrZone == nil {
		return nil
	}
	var vals = make([]float64, len(m.TimeInHrZone))
	for i := range m.TimeInHrZone {
		if m.TimeInHrZone[i] == basetype.Uint32Invalid {
			vals[i] = math.Float64frombits(basetype.Float64Invalid)
			continue
		}
		vals[i] = float64(m.TimeInHrZone[i])/1000 - 0
	}
	return vals
}

// TimeInSpeedZoneScaled return TimeInSpeedZone in its scaled value.
// If TimeInSpeedZone value is invalid, nil will be returned.
//
// Array: [N]; Scale: 1000; Units: s
func (m *SegmentLap) TimeInSpeedZoneScaled() []float64 {
	if m.TimeInSpeedZone == nil {
		return nil
	}
	var vals = make([]float64, len(m.TimeInSpeedZone))
	for i := range m.TimeInSpeedZone {
		if m.TimeInSpeedZone[i] == basetype.Uint32Invalid {
			vals[i] = math.Float64frombits(basetype.Float64Invalid)
			continue
		}
		vals[i] = float64(m.TimeInSpeedZone[i])/1000 - 0
	}
	return vals
}

// TimeInCadenceZoneScaled return TimeInCadenceZone in its scaled value.
// If TimeInCadenceZone value is invalid, nil will be returned.
//
// Array: [N]; Scale: 1000; Units: s
func (m *SegmentLap) TimeInCadenceZoneScaled() []float64 {
	if m.TimeInCadenceZone == nil {
		return nil
	}
	var vals = make([]float64, len(m.TimeInCadenceZone))
	for i := range m.TimeInCadenceZone {
		if m.TimeInCadenceZone[i] == basetype.Uint32Invalid {
			vals[i] = math.Float64frombits(basetype.Float64Invalid)
			continue
		}
		vals[i] = float64(m.TimeInCadenceZone[i])/1000 - 0
	}
	return vals
}

// TimeInPowerZoneScaled return TimeInPowerZone in its scaled value.
// If TimeInPowerZone value is invalid, nil will be returned.
//
// Array: [N]; Scale: 1000; Units: s
func (m *SegmentLap) TimeInPowerZoneScaled() []float64 {
	if m.TimeInPowerZone == nil {
		return nil
	}
	var vals = make([]float64, len(m.TimeInPowerZone))
	for i := range m.TimeInPowerZone {
		if m.TimeInPowerZone[i] == basetype.Uint32Invalid {
			vals[i] = math.Float64frombits(basetype.Float64Invalid)
			continue
		}
		vals[i] = float64(m.TimeInPowerZone[i])/1000 - 0
	}
	return vals
}

// MinAltitudeScaled return MinAltitude in its scaled value.
// If MinAltitude value is invalid, float64 invalid value will be returned.
//
// Scale: 5; Offset: 500; Units: m
func (m *SegmentLap) MinAltitudeScaled() float64 {
	if m.MinAltitude == basetype.Uint16Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.MinAltitude)/5 - 500
}

// ActiveTimeScaled return ActiveTime in its scaled value.
// If ActiveTime value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: s
func (m *SegmentLap) ActiveTimeScaled() float64 {
	if m.ActiveTime == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.ActiveTime)/1000 - 0
}

// AvgLeftTorqueEffectivenessScaled return AvgLeftTorqueEffectiveness in its scaled value.
// If AvgLeftTorqueEffectiveness value is invalid, float64 invalid value will be returned.
//
// Scale: 2; Units: percent
func (m *SegmentLap) AvgLeftTorqueEffectivenessScaled() float64 {
	if m.AvgLeftTorqueEffectiveness == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgLeftTorqueEffectiveness)/2 - 0
}

// AvgRightTorqueEffectivenessScaled return AvgRightTorqueEffectiveness in its scaled value.
// If AvgRightTorqueEffectiveness value is invalid, float64 invalid value will be returned.
//
// Scale: 2; Units: percent
func (m *SegmentLap) AvgRightTorqueEffectivenessScaled() float64 {
	if m.AvgRightTorqueEffectiveness == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgRightTorqueEffectiveness)/2 - 0
}

// AvgLeftPedalSmoothnessScaled return AvgLeftPedalSmoothness in its scaled value.
// If AvgLeftPedalSmoothness value is invalid, float64 invalid value will be returned.
//
// Scale: 2; Units: percent
func (m *SegmentLap) AvgLeftPedalSmoothnessScaled() float64 {
	if m.AvgLeftPedalSmoothness == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgLeftPedalSmoothness)/2 - 0
}

// AvgRightPedalSmoothnessScaled return AvgRightPedalSmoothness in its scaled value.
// If AvgRightPedalSmoothness value is invalid, float64 invalid value will be returned.
//
// Scale: 2; Units: percent
func (m *SegmentLap) AvgRightPedalSmoothnessScaled() float64 {
	if m.AvgRightPedalSmoothness == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgRightPedalSmoothness)/2 - 0
}

// AvgCombinedPedalSmoothnessScaled return AvgCombinedPedalSmoothness in its scaled value.
// If AvgCombinedPedalSmoothness value is invalid, float64 invalid value will be returned.
//
// Scale: 2; Units: percent
func (m *SegmentLap) AvgCombinedPedalSmoothnessScaled() float64 {
	if m.AvgCombinedPedalSmoothness == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgCombinedPedalSmoothness)/2 - 0
}

// AvgFractionalCadenceScaled return AvgFractionalCadence in its scaled value.
// If AvgFractionalCadence value is invalid, float64 invalid value will be returned.
//
// Scale: 128; Units: rpm; fractional part of the avg_cadence
func (m *SegmentLap) AvgFractionalCadenceScaled() float64 {
	if m.AvgFractionalCadence == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.AvgFractionalCadence)/128 - 0
}

// MaxFractionalCadenceScaled return MaxFractionalCadence in its scaled value.
// If MaxFractionalCadence value is invalid, float64 invalid value will be returned.
//
// Scale: 128; Units: rpm; fractional part of the max_cadence
func (m *SegmentLap) MaxFractionalCadenceScaled() float64 {
	if m.MaxFractionalCadence == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.MaxFractionalCadence)/128 - 0
}

// TotalFractionalCyclesScaled return TotalFractionalCycles in its scaled value.
// If TotalFractionalCycles value is invalid, float64 invalid value will be returned.
//
// Scale: 128; Units: cycles; fractional part of the total_cycles
func (m *SegmentLap) TotalFractionalCyclesScaled() float64 {
	if m.TotalFractionalCycles == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.TotalFractionalCycles)/128 - 0
}

// TimeStandingScaled return TimeStanding in its scaled value.
// If TimeStanding value is invalid, float64 invalid value will be returned.
//
// Scale: 1000; Units: s; Total time spent in the standing position
func (m *SegmentLap) TimeStandingScaled() float64 {
	if m.TimeStanding == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.TimeStanding)/1000 - 0
}

// AvgLeftPowerPhaseScaled return AvgLeftPowerPhase in its scaled value.
// If AvgLeftPowerPhase value is invalid, nil will be returned.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average left power phase angles. Data value indexes defined by power_phase_type.
func (m *SegmentLap) AvgLeftPowerPhaseScaled() []float64 {
	if m.AvgLeftPowerPhase == nil {
		return nil
	}
	var vals = make([]float64, len(m.AvgLeftPowerPhase))
	for i := range m.AvgLeftPowerPhase {
		if m.AvgLeftPowerPhase[i] == basetype.Uint8Invalid {
			vals[i] = math.Float64frombits(basetype.Float64Invalid)
			continue
		}
		vals[i] = float64(m.AvgLeftPowerPhase[i])/0.7111111 - 0
	}
	return vals
}

// AvgLeftPowerPhasePeakScaled return AvgLeftPowerPhasePeak in its scaled value.
// If AvgLeftPowerPhasePeak value is invalid, nil will be returned.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average left power phase peak angles. Data value indexes defined by power_phase_type.
func (m *SegmentLap) AvgLeftPowerPhasePeakScaled() []float64 {
	if m.AvgLeftPowerPhasePeak == nil {
		return nil
	}
	var vals = make([]float64, len(m.AvgLeftPowerPhasePeak))
	for i := range m.AvgLeftPowerPhasePeak {
		if m.AvgLeftPowerPhasePeak[i] == basetype.Uint8Invalid {
			vals[i] = math.Float64frombits(basetype.Float64Invalid)
			continue
		}
		vals[i] = float64(m.AvgLeftPowerPhasePeak[i])/0.7111111 - 0
	}
	return vals
}

// AvgRightPowerPhaseScaled return AvgRightPowerPhase in its scaled value.
// If AvgRightPowerPhase value is invalid, nil will be returned.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average right power phase angles. Data value indexes defined by power_phase_type.
func (m *SegmentLap) AvgRightPowerPhaseScaled() []float64 {
	if m.AvgRightPowerPhase == nil {
		return nil
	}
	var vals = make([]float64, len(m.AvgRightPowerPhase))
	for i := range m.AvgRightPowerPhase {
		if m.AvgRightPowerPhase[i] == basetype.Uint8Invalid {
			vals[i] = math.Float64frombits(basetype.Float64Invalid)
			continue
		}
		vals[i] = float64(m.AvgRightPowerPhase[i])/0.7111111 - 0
	}
	return vals
}

// AvgRightPowerPhasePeakScaled return AvgRightPowerPhasePeak in its scaled value.
// If AvgRightPowerPhasePeak value is invalid, nil will be returned.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average right power phase peak angles. Data value indexes defined by power_phase_type.
func (m *SegmentLap) AvgRightPowerPhasePeakScaled() []float64 {
	if m.AvgRightPowerPhasePeak == nil {
		return nil
	}
	var vals = make([]float64, len(m.AvgRightPowerPhasePeak))
	for i := range m.AvgRightPowerPhasePeak {
		if m.AvgRightPowerPhasePeak[i] == basetype.Uint8Invalid {
			vals[i] = math.Float64frombits(basetype.Float64Invalid)
			continue
		}
		vals[i] = float64(m.AvgRightPowerPhasePeak[i])/0.7111111 - 0
	}
	return vals
}

// TotalFractionalAscentScaled return TotalFractionalAscent in its scaled value.
// If TotalFractionalAscent value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: m; fractional part of total_ascent
func (m *SegmentLap) TotalFractionalAscentScaled() float64 {
	if m.TotalFractionalAscent == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.TotalFractionalAscent)/100 - 0
}

// TotalFractionalDescentScaled return TotalFractionalDescent in its scaled value.
// If TotalFractionalDescent value is invalid, float64 invalid value will be returned.
//
// Scale: 100; Units: m; fractional part of total_descent
func (m *SegmentLap) TotalFractionalDescentScaled() float64 {
	if m.TotalFractionalDescent == basetype.Uint8Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.TotalFractionalDescent)/100 - 0
}

// EnhancedAvgAltitudeScaled return EnhancedAvgAltitude in its scaled value.
// If EnhancedAvgAltitude value is invalid, float64 invalid value will be returned.
//
// Scale: 5; Offset: 500; Units: m
func (m *SegmentLap) EnhancedAvgAltitudeScaled() float64 {
	if m.EnhancedAvgAltitude == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.EnhancedAvgAltitude)/5 - 500
}

// EnhancedMaxAltitudeScaled return EnhancedMaxAltitude in its scaled value.
// If EnhancedMaxAltitude value is invalid, float64 invalid value will be returned.
//
// Scale: 5; Offset: 500; Units: m
func (m *SegmentLap) EnhancedMaxAltitudeScaled() float64 {
	if m.EnhancedMaxAltitude == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.EnhancedMaxAltitude)/5 - 500
}

// EnhancedMinAltitudeScaled return EnhancedMinAltitude in its scaled value.
// If EnhancedMinAltitude value is invalid, float64 invalid value will be returned.
//
// Scale: 5; Offset: 500; Units: m
func (m *SegmentLap) EnhancedMinAltitudeScaled() float64 {
	if m.EnhancedMinAltitude == basetype.Uint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return float64(m.EnhancedMinAltitude)/5 - 500
}

// StartPositionLatDegrees returns StartPositionLat in degrees instead of semicircles.
// If StartPositionLat value is invalid, float64 invalid value will be returned.
func (m *SegmentLap) StartPositionLatDegrees() float64 {
	if m.StartPositionLat == basetype.Sint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return semicircles.ToDegrees(m.StartPositionLat)
}

// StartPositionLongDegrees returns StartPositionLong in degrees instead of semicircles.
// If StartPositionLong value is invalid, float64 invalid value will be returned.
func (m *SegmentLap) StartPositionLongDegrees() float64 {
	if m.StartPositionLong == basetype.Sint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return semicircles.ToDegrees(m.StartPositionLong)
}

// EndPositionLatDegrees returns EndPositionLat in degrees instead of semicircles.
// If EndPositionLat value is invalid, float64 invalid value will be returned.
func (m *SegmentLap) EndPositionLatDegrees() float64 {
	if m.EndPositionLat == basetype.Sint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return semicircles.ToDegrees(m.EndPositionLat)
}

// EndPositionLongDegrees returns EndPositionLong in degrees instead of semicircles.
// If EndPositionLong value is invalid, float64 invalid value will be returned.
func (m *SegmentLap) EndPositionLongDegrees() float64 {
	if m.EndPositionLong == basetype.Sint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return semicircles.ToDegrees(m.EndPositionLong)
}

// NecLatDegrees returns NecLat in degrees instead of semicircles.
// If NecLat value is invalid, float64 invalid value will be returned.
func (m *SegmentLap) NecLatDegrees() float64 {
	if m.NecLat == basetype.Sint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return semicircles.ToDegrees(m.NecLat)
}

// NecLongDegrees returns NecLong in degrees instead of semicircles.
// If NecLong value is invalid, float64 invalid value will be returned.
func (m *SegmentLap) NecLongDegrees() float64 {
	if m.NecLong == basetype.Sint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return semicircles.ToDegrees(m.NecLong)
}

// SwcLatDegrees returns SwcLat in degrees instead of semicircles.
// If SwcLat value is invalid, float64 invalid value will be returned.
func (m *SegmentLap) SwcLatDegrees() float64 {
	if m.SwcLat == basetype.Sint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return semicircles.ToDegrees(m.SwcLat)
}

// SwcLongDegrees returns SwcLong in degrees instead of semicircles.
// If SwcLong value is invalid, float64 invalid value will be returned.
func (m *SegmentLap) SwcLongDegrees() float64 {
	if m.SwcLong == basetype.Sint32Invalid {
		return math.Float64frombits(basetype.Float64Invalid)
	}
	return semicircles.ToDegrees(m.SwcLong)
}

// SetMessageIndex sets MessageIndex value.
func (m *SegmentLap) SetMessageIndex(v typedef.MessageIndex) *SegmentLap {
	m.MessageIndex = v
	return m
}

// SetTimestamp sets Timestamp value.
//
// Units: s; Lap end time.
func (m *SegmentLap) SetTimestamp(v time.Time) *SegmentLap {
	m.Timestamp = v
	return m
}

// SetEvent sets Event value.
func (m *SegmentLap) SetEvent(v typedef.Event) *SegmentLap {
	m.Event = v
	return m
}

// SetEventType sets EventType value.
func (m *SegmentLap) SetEventType(v typedef.EventType) *SegmentLap {
	m.EventType = v
	return m
}

// SetStartTime sets StartTime value.
func (m *SegmentLap) SetStartTime(v time.Time) *SegmentLap {
	m.StartTime = v
	return m
}

// SetStartPositionLat sets StartPositionLat value.
//
// Units: semicircles
func (m *SegmentLap) SetStartPositionLat(v int32) *SegmentLap {
	m.StartPositionLat = v
	return m
}

// SetStartPositionLatDegrees is similar to SetStartPositionLat except it accepts a value in degrees.
// This method will automatically convert given degrees value to semicircles (int32) form.
func (m *SegmentLap) SetStartPositionLatDegrees(degrees float64) *SegmentLap {
	m.StartPositionLat = semicircles.ToSemicircles(degrees)
	return m
}

// SetStartPositionLong sets StartPositionLong value.
//
// Units: semicircles
func (m *SegmentLap) SetStartPositionLong(v int32) *SegmentLap {
	m.StartPositionLong = v
	return m
}

// SetStartPositionLongDegrees is similar to SetStartPositionLong except it accepts a value in degrees.
// This method will automatically convert given degrees value to semicircles (int32) form.
func (m *SegmentLap) SetStartPositionLongDegrees(degrees float64) *SegmentLap {
	m.StartPositionLong = semicircles.ToSemicircles(degrees)
	return m
}

// SetEndPositionLat sets EndPositionLat value.
//
// Units: semicircles
func (m *SegmentLap) SetEndPositionLat(v int32) *SegmentLap {
	m.EndPositionLat = v
	return m
}

// SetEndPositionLatDegrees is similar to SetEndPositionLat except it accepts a value in degrees.
// This method will automatically convert given degrees value to semicircles (int32) form.
func (m *SegmentLap) SetEndPositionLatDegrees(degrees float64) *SegmentLap {
	m.EndPositionLat = semicircles.ToSemicircles(degrees)
	return m
}

// SetEndPositionLong sets EndPositionLong value.
//
// Units: semicircles
func (m *SegmentLap) SetEndPositionLong(v int32) *SegmentLap {
	m.EndPositionLong = v
	return m
}

// SetEndPositionLongDegrees is similar to SetEndPositionLong except it accepts a value in degrees.
// This method will automatically convert given degrees value to semicircles (int32) form.
func (m *SegmentLap) SetEndPositionLongDegrees(degrees float64) *SegmentLap {
	m.EndPositionLong = semicircles.ToSemicircles(degrees)
	return m
}

// SetTotalElapsedTime sets TotalElapsedTime value.
//
// Scale: 1000; Units: s; Time (includes pauses)
func (m *SegmentLap) SetTotalElapsedTime(v uint32) *SegmentLap {
	m.TotalElapsedTime = v
	return m
}

// SetTotalElapsedTimeScaled is similar to SetTotalElapsedTime except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: s; Time (includes pauses)
func (m *SegmentLap) SetTotalElapsedTimeScaled(v float64) *SegmentLap {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.TotalElapsedTime = uint32(basetype.Uint32Invalid)
		return m
	}
	m.TotalElapsedTime = uint32(unscaled)
	return m
}

// SetTotalTimerTime sets TotalTimerTime value.
//
// Scale: 1000; Units: s; Timer Time (excludes pauses)
func (m *SegmentLap) SetTotalTimerTime(v uint32) *SegmentLap {
	m.TotalTimerTime = v
	return m
}

// SetTotalTimerTimeScaled is similar to SetTotalTimerTime except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: s; Timer Time (excludes pauses)
func (m *SegmentLap) SetTotalTimerTimeScaled(v float64) *SegmentLap {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.TotalTimerTime = uint32(basetype.Uint32Invalid)
		return m
	}
	m.TotalTimerTime = uint32(unscaled)
	return m
}

// SetTotalDistance sets TotalDistance value.
//
// Scale: 100; Units: m
func (m *SegmentLap) SetTotalDistance(v uint32) *SegmentLap {
	m.TotalDistance = v
	return m
}

// SetTotalDistanceScaled is similar to SetTotalDistance except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 100; Units: m
func (m *SegmentLap) SetTotalDistanceScaled(v float64) *SegmentLap {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.TotalDistance = uint32(basetype.Uint32Invalid)
		return m
	}
	m.TotalDistance = uint32(unscaled)
	return m
}

// SetTotalCycles sets TotalCycles value.
//
// Units: cycles
func (m *SegmentLap) SetTotalCycles(v uint32) *SegmentLap {
	m.TotalCycles = v
	return m
}

// SetTotalCalories sets TotalCalories value.
//
// Units: kcal
func (m *SegmentLap) SetTotalCalories(v uint16) *SegmentLap {
	m.TotalCalories = v
	return m
}

// SetTotalFatCalories sets TotalFatCalories value.
//
// Units: kcal; If New Leaf
func (m *SegmentLap) SetTotalFatCalories(v uint16) *SegmentLap {
	m.TotalFatCalories = v
	return m
}

// SetAvgSpeed sets AvgSpeed value.
//
// Scale: 1000; Units: m/s
func (m *SegmentLap) SetAvgSpeed(v uint16) *SegmentLap {
	m.AvgSpeed = v
	return m
}

// SetAvgSpeedScaled is similar to SetAvgSpeed except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: m/s
func (m *SegmentLap) SetAvgSpeedScaled(v float64) *SegmentLap {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.AvgSpeed = uint16(basetype.Uint16Invalid)
		return m
	}
	m.AvgSpeed = uint16(unscaled)
	return m
}

// SetMaxSpeed sets MaxSpeed value.
//
// Scale: 1000; Units: m/s
func (m *SegmentLap) SetMaxSpeed(v uint16) *SegmentLap {
	m.MaxSpeed = v
	return m
}

// SetMaxSpeedScaled is similar to SetMaxSpeed except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: m/s
func (m *SegmentLap) SetMaxSpeedScaled(v float64) *SegmentLap {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.MaxSpeed = uint16(basetype.Uint16Invalid)
		return m
	}
	m.MaxSpeed = uint16(unscaled)
	return m
}

// SetAvgHeartRate sets AvgHeartRate value.
//
// Units: bpm
func (m *SegmentLap) SetAvgHeartRate(v uint8) *SegmentLap {
	m.AvgHeartRate = v
	return m
}

// SetMaxHeartRate sets MaxHeartRate value.
//
// Units: bpm
func (m *SegmentLap) SetMaxHeartRate(v uint8) *SegmentLap {
	m.MaxHeartRate = v
	return m
}

// SetAvgCadence sets AvgCadence value.
//
// Units: rpm; total_cycles / total_timer_time if non_zero_avg_cadence otherwise total_cycles / total_elapsed_time
func (m *SegmentLap) SetAvgCadence(v uint8) *SegmentLap {
	m.AvgCadence = v
	return m
}

// SetMaxCadence sets MaxCadence value.
//
// Units: rpm
func (m *SegmentLap) SetMaxCadence(v uint8) *SegmentLap {
	m.MaxCadence = v
	return m
}

// SetAvgPower sets AvgPower value.
//
// Units: watts; total_power / total_timer_time if non_zero_avg_power otherwise total_power / total_elapsed_time
func (m *SegmentLap) SetAvgPower(v uint16) *SegmentLap {
	m.AvgPower = v
	return m
}

// SetMaxPower sets MaxPower value.
//
// Units: watts
func (m *SegmentLap) SetMaxPower(v uint16) *SegmentLap {
	m.MaxPower = v
	return m
}

// SetTotalAscent sets TotalAscent value.
//
// Units: m
func (m *SegmentLap) SetTotalAscent(v uint16) *SegmentLap {
	m.TotalAscent = v
	return m
}

// SetTotalDescent sets TotalDescent value.
//
// Units: m
func (m *SegmentLap) SetTotalDescent(v uint16) *SegmentLap {
	m.TotalDescent = v
	return m
}

// SetSport sets Sport value.
func (m *SegmentLap) SetSport(v typedef.Sport) *SegmentLap {
	m.Sport = v
	return m
}

// SetEventGroup sets EventGroup value.
func (m *SegmentLap) SetEventGroup(v uint8) *SegmentLap {
	m.EventGroup = v
	return m
}

// SetNecLat sets NecLat value.
//
// Units: semicircles; North east corner latitude.
func (m *SegmentLap) SetNecLat(v int32) *SegmentLap {
	m.NecLat = v
	return m
}

// SetNecLatDegrees is similar to SetNecLat except it accepts a value in degrees.
// This method will automatically convert given degrees value to semicircles (int32) form.
func (m *SegmentLap) SetNecLatDegrees(degrees float64) *SegmentLap {
	m.NecLat = semicircles.ToSemicircles(degrees)
	return m
}

// SetNecLong sets NecLong value.
//
// Units: semicircles; North east corner longitude.
func (m *SegmentLap) SetNecLong(v int32) *SegmentLap {
	m.NecLong = v
	return m
}

// SetNecLongDegrees is similar to SetNecLong except it accepts a value in degrees.
// This method will automatically convert given degrees value to semicircles (int32) form.
func (m *SegmentLap) SetNecLongDegrees(degrees float64) *SegmentLap {
	m.NecLong = semicircles.ToSemicircles(degrees)
	return m
}

// SetSwcLat sets SwcLat value.
//
// Units: semicircles; South west corner latitude.
func (m *SegmentLap) SetSwcLat(v int32) *SegmentLap {
	m.SwcLat = v
	return m
}

// SetSwcLatDegrees is similar to SetSwcLat except it accepts a value in degrees.
// This method will automatically convert given degrees value to semicircles (int32) form.
func (m *SegmentLap) SetSwcLatDegrees(degrees float64) *SegmentLap {
	m.SwcLat = semicircles.ToSemicircles(degrees)
	return m
}

// SetSwcLong sets SwcLong value.
//
// Units: semicircles; South west corner latitude.
func (m *SegmentLap) SetSwcLong(v int32) *SegmentLap {
	m.SwcLong = v
	return m
}

// SetSwcLongDegrees is similar to SetSwcLong except it accepts a value in degrees.
// This method will automatically convert given degrees value to semicircles (int32) form.
func (m *SegmentLap) SetSwcLongDegrees(degrees float64) *SegmentLap {
	m.SwcLong = semicircles.ToSemicircles(degrees)
	return m
}

// SetName sets Name value.
func (m *SegmentLap) SetName(v string) *SegmentLap {
	m.Name = v
	return m
}

// SetNormalizedPower sets NormalizedPower value.
//
// Units: watts
func (m *SegmentLap) SetNormalizedPower(v uint16) *SegmentLap {
	m.NormalizedPower = v
	return m
}

// SetLeftRightBalance sets LeftRightBalance value.
func (m *SegmentLap) SetLeftRightBalance(v typedef.LeftRightBalance100) *SegmentLap {
	m.LeftRightBalance = v
	return m
}

// SetSubSport sets SubSport value.
func (m *SegmentLap) SetSubSport(v typedef.SubSport) *SegmentLap {
	m.SubSport = v
	return m
}

// SetTotalWork sets TotalWork value.
//
// Units: J
func (m *SegmentLap) SetTotalWork(v uint32) *SegmentLap {
	m.TotalWork = v
	return m
}

// SetAvgAltitude sets AvgAltitude value.
//
// Scale: 5; Offset: 500; Units: m
func (m *SegmentLap) SetAvgAltitude(v uint16) *SegmentLap {
	m.AvgAltitude = v
	return m
}

// SetAvgAltitudeScaled is similar to SetAvgAltitude except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 5; Offset: 500; Units: m
func (m *SegmentLap) SetAvgAltitudeScaled(v float64) *SegmentLap {
	unscaled := (v + 500) * 5
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.AvgAltitude = uint16(basetype.Uint16Invalid)
		return m
	}
	m.AvgAltitude = uint16(unscaled)
	return m
}

// SetMaxAltitude sets MaxAltitude value.
//
// Scale: 5; Offset: 500; Units: m
func (m *SegmentLap) SetMaxAltitude(v uint16) *SegmentLap {
	m.MaxAltitude = v
	return m
}

// SetMaxAltitudeScaled is similar to SetMaxAltitude except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 5; Offset: 500; Units: m
func (m *SegmentLap) SetMaxAltitudeScaled(v float64) *SegmentLap {
	unscaled := (v + 500) * 5
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.MaxAltitude = uint16(basetype.Uint16Invalid)
		return m
	}
	m.MaxAltitude = uint16(unscaled)
	return m
}

// SetGpsAccuracy sets GpsAccuracy value.
//
// Units: m
func (m *SegmentLap) SetGpsAccuracy(v uint8) *SegmentLap {
	m.GpsAccuracy = v
	return m
}

// SetAvgGrade sets AvgGrade value.
//
// Scale: 100; Units: %
func (m *SegmentLap) SetAvgGrade(v int16) *SegmentLap {
	m.AvgGrade = v
	return m
}

// SetAvgGradeScaled is similar to SetAvgGrade except it accepts a scaled value.
// This method automatically converts the given value to its int16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: %
func (m *SegmentLap) SetAvgGradeScaled(v float64) *SegmentLap {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Sint16Invalid) {
		m.AvgGrade = int16(basetype.Sint16Invalid)
		return m
	}
	m.AvgGrade = int16(unscaled)
	return m
}

// SetAvgPosGrade sets AvgPosGrade value.
//
// Scale: 100; Units: %
func (m *SegmentLap) SetAvgPosGrade(v int16) *SegmentLap {
	m.AvgPosGrade = v
	return m
}

// SetAvgPosGradeScaled is similar to SetAvgPosGrade except it accepts a scaled value.
// This method automatically converts the given value to its int16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: %
func (m *SegmentLap) SetAvgPosGradeScaled(v float64) *SegmentLap {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Sint16Invalid) {
		m.AvgPosGrade = int16(basetype.Sint16Invalid)
		return m
	}
	m.AvgPosGrade = int16(unscaled)
	return m
}

// SetAvgNegGrade sets AvgNegGrade value.
//
// Scale: 100; Units: %
func (m *SegmentLap) SetAvgNegGrade(v int16) *SegmentLap {
	m.AvgNegGrade = v
	return m
}

// SetAvgNegGradeScaled is similar to SetAvgNegGrade except it accepts a scaled value.
// This method automatically converts the given value to its int16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: %
func (m *SegmentLap) SetAvgNegGradeScaled(v float64) *SegmentLap {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Sint16Invalid) {
		m.AvgNegGrade = int16(basetype.Sint16Invalid)
		return m
	}
	m.AvgNegGrade = int16(unscaled)
	return m
}

// SetMaxPosGrade sets MaxPosGrade value.
//
// Scale: 100; Units: %
func (m *SegmentLap) SetMaxPosGrade(v int16) *SegmentLap {
	m.MaxPosGrade = v
	return m
}

// SetMaxPosGradeScaled is similar to SetMaxPosGrade except it accepts a scaled value.
// This method automatically converts the given value to its int16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: %
func (m *SegmentLap) SetMaxPosGradeScaled(v float64) *SegmentLap {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Sint16Invalid) {
		m.MaxPosGrade = int16(basetype.Sint16Invalid)
		return m
	}
	m.MaxPosGrade = int16(unscaled)
	return m
}

// SetMaxNegGrade sets MaxNegGrade value.
//
// Scale: 100; Units: %
func (m *SegmentLap) SetMaxNegGrade(v int16) *SegmentLap {
	m.MaxNegGrade = v
	return m
}

// SetMaxNegGradeScaled is similar to SetMaxNegGrade except it accepts a scaled value.
// This method automatically converts the given value to its int16 form, discarding any applied scale and offset.
//
// Scale: 100; Units: %
func (m *SegmentLap) SetMaxNegGradeScaled(v float64) *SegmentLap {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Sint16Invalid) {
		m.MaxNegGrade = int16(basetype.Sint16Invalid)
		return m
	}
	m.MaxNegGrade = int16(unscaled)
	return m
}

// SetAvgTemperature sets AvgTemperature value.
//
// Units: C
func (m *SegmentLap) SetAvgTemperature(v int8) *SegmentLap {
	m.AvgTemperature = v
	return m
}

// SetMaxTemperature sets MaxTemperature value.
//
// Units: C
func (m *SegmentLap) SetMaxTemperature(v int8) *SegmentLap {
	m.MaxTemperature = v
	return m
}

// SetTotalMovingTime sets TotalMovingTime value.
//
// Scale: 1000; Units: s
func (m *SegmentLap) SetTotalMovingTime(v uint32) *SegmentLap {
	m.TotalMovingTime = v
	return m
}

// SetTotalMovingTimeScaled is similar to SetTotalMovingTime except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: s
func (m *SegmentLap) SetTotalMovingTimeScaled(v float64) *SegmentLap {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.TotalMovingTime = uint32(basetype.Uint32Invalid)
		return m
	}
	m.TotalMovingTime = uint32(unscaled)
	return m
}

// SetAvgPosVerticalSpeed sets AvgPosVerticalSpeed value.
//
// Scale: 1000; Units: m/s
func (m *SegmentLap) SetAvgPosVerticalSpeed(v int16) *SegmentLap {
	m.AvgPosVerticalSpeed = v
	return m
}

// SetAvgPosVerticalSpeedScaled is similar to SetAvgPosVerticalSpeed except it accepts a scaled value.
// This method automatically converts the given value to its int16 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: m/s
func (m *SegmentLap) SetAvgPosVerticalSpeedScaled(v float64) *SegmentLap {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Sint16Invalid) {
		m.AvgPosVerticalSpeed = int16(basetype.Sint16Invalid)
		return m
	}
	m.AvgPosVerticalSpeed = int16(unscaled)
	return m
}

// SetAvgNegVerticalSpeed sets AvgNegVerticalSpeed value.
//
// Scale: 1000; Units: m/s
func (m *SegmentLap) SetAvgNegVerticalSpeed(v int16) *SegmentLap {
	m.AvgNegVerticalSpeed = v
	return m
}

// SetAvgNegVerticalSpeedScaled is similar to SetAvgNegVerticalSpeed except it accepts a scaled value.
// This method automatically converts the given value to its int16 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: m/s
func (m *SegmentLap) SetAvgNegVerticalSpeedScaled(v float64) *SegmentLap {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Sint16Invalid) {
		m.AvgNegVerticalSpeed = int16(basetype.Sint16Invalid)
		return m
	}
	m.AvgNegVerticalSpeed = int16(unscaled)
	return m
}

// SetMaxPosVerticalSpeed sets MaxPosVerticalSpeed value.
//
// Scale: 1000; Units: m/s
func (m *SegmentLap) SetMaxPosVerticalSpeed(v int16) *SegmentLap {
	m.MaxPosVerticalSpeed = v
	return m
}

// SetMaxPosVerticalSpeedScaled is similar to SetMaxPosVerticalSpeed except it accepts a scaled value.
// This method automatically converts the given value to its int16 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: m/s
func (m *SegmentLap) SetMaxPosVerticalSpeedScaled(v float64) *SegmentLap {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Sint16Invalid) {
		m.MaxPosVerticalSpeed = int16(basetype.Sint16Invalid)
		return m
	}
	m.MaxPosVerticalSpeed = int16(unscaled)
	return m
}

// SetMaxNegVerticalSpeed sets MaxNegVerticalSpeed value.
//
// Scale: 1000; Units: m/s
func (m *SegmentLap) SetMaxNegVerticalSpeed(v int16) *SegmentLap {
	m.MaxNegVerticalSpeed = v
	return m
}

// SetMaxNegVerticalSpeedScaled is similar to SetMaxNegVerticalSpeed except it accepts a scaled value.
// This method automatically converts the given value to its int16 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: m/s
func (m *SegmentLap) SetMaxNegVerticalSpeedScaled(v float64) *SegmentLap {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Sint16Invalid) {
		m.MaxNegVerticalSpeed = int16(basetype.Sint16Invalid)
		return m
	}
	m.MaxNegVerticalSpeed = int16(unscaled)
	return m
}

// SetTimeInHrZone sets TimeInHrZone value.
//
// Array: [N]; Scale: 1000; Units: s
func (m *SegmentLap) SetTimeInHrZone(v []uint32) *SegmentLap {
	m.TimeInHrZone = v
	return m
}

// SetTimeInHrZoneScaled is similar to SetTimeInHrZone except it accepts a scaled value.
// This method automatically converts the given value to its []uint32 form, discarding any applied scale and offset.
//
// Array: [N]; Scale: 1000; Units: s
func (m *SegmentLap) SetTimeInHrZoneScaled(vs []float64) *SegmentLap {
	if vs == nil {
		m.TimeInHrZone = nil
		return m
	}
	m.TimeInHrZone = make([]uint32, len(vs))
	for i := range vs {
		unscaled := (vs[i] + 0) * 1000
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
			m.TimeInHrZone[i] = uint32(basetype.Uint32Invalid)
			continue
		}
		m.TimeInHrZone[i] = uint32(unscaled)
	}
	return m
}

// SetTimeInSpeedZone sets TimeInSpeedZone value.
//
// Array: [N]; Scale: 1000; Units: s
func (m *SegmentLap) SetTimeInSpeedZone(v []uint32) *SegmentLap {
	m.TimeInSpeedZone = v
	return m
}

// SetTimeInSpeedZoneScaled is similar to SetTimeInSpeedZone except it accepts a scaled value.
// This method automatically converts the given value to its []uint32 form, discarding any applied scale and offset.
//
// Array: [N]; Scale: 1000; Units: s
func (m *SegmentLap) SetTimeInSpeedZoneScaled(vs []float64) *SegmentLap {
	if vs == nil {
		m.TimeInSpeedZone = nil
		return m
	}
	m.TimeInSpeedZone = make([]uint32, len(vs))
	for i := range vs {
		unscaled := (vs[i] + 0) * 1000
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
			m.TimeInSpeedZone[i] = uint32(basetype.Uint32Invalid)
			continue
		}
		m.TimeInSpeedZone[i] = uint32(unscaled)
	}
	return m
}

// SetTimeInCadenceZone sets TimeInCadenceZone value.
//
// Array: [N]; Scale: 1000; Units: s
func (m *SegmentLap) SetTimeInCadenceZone(v []uint32) *SegmentLap {
	m.TimeInCadenceZone = v
	return m
}

// SetTimeInCadenceZoneScaled is similar to SetTimeInCadenceZone except it accepts a scaled value.
// This method automatically converts the given value to its []uint32 form, discarding any applied scale and offset.
//
// Array: [N]; Scale: 1000; Units: s
func (m *SegmentLap) SetTimeInCadenceZoneScaled(vs []float64) *SegmentLap {
	if vs == nil {
		m.TimeInCadenceZone = nil
		return m
	}
	m.TimeInCadenceZone = make([]uint32, len(vs))
	for i := range vs {
		unscaled := (vs[i] + 0) * 1000
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
			m.TimeInCadenceZone[i] = uint32(basetype.Uint32Invalid)
			continue
		}
		m.TimeInCadenceZone[i] = uint32(unscaled)
	}
	return m
}

// SetTimeInPowerZone sets TimeInPowerZone value.
//
// Array: [N]; Scale: 1000; Units: s
func (m *SegmentLap) SetTimeInPowerZone(v []uint32) *SegmentLap {
	m.TimeInPowerZone = v
	return m
}

// SetTimeInPowerZoneScaled is similar to SetTimeInPowerZone except it accepts a scaled value.
// This method automatically converts the given value to its []uint32 form, discarding any applied scale and offset.
//
// Array: [N]; Scale: 1000; Units: s
func (m *SegmentLap) SetTimeInPowerZoneScaled(vs []float64) *SegmentLap {
	if vs == nil {
		m.TimeInPowerZone = nil
		return m
	}
	m.TimeInPowerZone = make([]uint32, len(vs))
	for i := range vs {
		unscaled := (vs[i] + 0) * 1000
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
			m.TimeInPowerZone[i] = uint32(basetype.Uint32Invalid)
			continue
		}
		m.TimeInPowerZone[i] = uint32(unscaled)
	}
	return m
}

// SetRepetitionNum sets RepetitionNum value.
func (m *SegmentLap) SetRepetitionNum(v uint16) *SegmentLap {
	m.RepetitionNum = v
	return m
}

// SetMinAltitude sets MinAltitude value.
//
// Scale: 5; Offset: 500; Units: m
func (m *SegmentLap) SetMinAltitude(v uint16) *SegmentLap {
	m.MinAltitude = v
	return m
}

// SetMinAltitudeScaled is similar to SetMinAltitude except it accepts a scaled value.
// This method automatically converts the given value to its uint16 form, discarding any applied scale and offset.
//
// Scale: 5; Offset: 500; Units: m
func (m *SegmentLap) SetMinAltitudeScaled(v float64) *SegmentLap {
	unscaled := (v + 500) * 5
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint16Invalid) {
		m.MinAltitude = uint16(basetype.Uint16Invalid)
		return m
	}
	m.MinAltitude = uint16(unscaled)
	return m
}

// SetMinHeartRate sets MinHeartRate value.
//
// Units: bpm
func (m *SegmentLap) SetMinHeartRate(v uint8) *SegmentLap {
	m.MinHeartRate = v
	return m
}

// SetActiveTime sets ActiveTime value.
//
// Scale: 1000; Units: s
func (m *SegmentLap) SetActiveTime(v uint32) *SegmentLap {
	m.ActiveTime = v
	return m
}

// SetActiveTimeScaled is similar to SetActiveTime except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: s
func (m *SegmentLap) SetActiveTimeScaled(v float64) *SegmentLap {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.ActiveTime = uint32(basetype.Uint32Invalid)
		return m
	}
	m.ActiveTime = uint32(unscaled)
	return m
}

// SetWktStepIndex sets WktStepIndex value.
func (m *SegmentLap) SetWktStepIndex(v typedef.MessageIndex) *SegmentLap {
	m.WktStepIndex = v
	return m
}

// SetSportEvent sets SportEvent value.
func (m *SegmentLap) SetSportEvent(v typedef.SportEvent) *SegmentLap {
	m.SportEvent = v
	return m
}

// SetAvgLeftTorqueEffectiveness sets AvgLeftTorqueEffectiveness value.
//
// Scale: 2; Units: percent
func (m *SegmentLap) SetAvgLeftTorqueEffectiveness(v uint8) *SegmentLap {
	m.AvgLeftTorqueEffectiveness = v
	return m
}

// SetAvgLeftTorqueEffectivenessScaled is similar to SetAvgLeftTorqueEffectiveness except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 2; Units: percent
func (m *SegmentLap) SetAvgLeftTorqueEffectivenessScaled(v float64) *SegmentLap {
	unscaled := (v + 0) * 2
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.AvgLeftTorqueEffectiveness = uint8(basetype.Uint8Invalid)
		return m
	}
	m.AvgLeftTorqueEffectiveness = uint8(unscaled)
	return m
}

// SetAvgRightTorqueEffectiveness sets AvgRightTorqueEffectiveness value.
//
// Scale: 2; Units: percent
func (m *SegmentLap) SetAvgRightTorqueEffectiveness(v uint8) *SegmentLap {
	m.AvgRightTorqueEffectiveness = v
	return m
}

// SetAvgRightTorqueEffectivenessScaled is similar to SetAvgRightTorqueEffectiveness except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 2; Units: percent
func (m *SegmentLap) SetAvgRightTorqueEffectivenessScaled(v float64) *SegmentLap {
	unscaled := (v + 0) * 2
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.AvgRightTorqueEffectiveness = uint8(basetype.Uint8Invalid)
		return m
	}
	m.AvgRightTorqueEffectiveness = uint8(unscaled)
	return m
}

// SetAvgLeftPedalSmoothness sets AvgLeftPedalSmoothness value.
//
// Scale: 2; Units: percent
func (m *SegmentLap) SetAvgLeftPedalSmoothness(v uint8) *SegmentLap {
	m.AvgLeftPedalSmoothness = v
	return m
}

// SetAvgLeftPedalSmoothnessScaled is similar to SetAvgLeftPedalSmoothness except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 2; Units: percent
func (m *SegmentLap) SetAvgLeftPedalSmoothnessScaled(v float64) *SegmentLap {
	unscaled := (v + 0) * 2
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.AvgLeftPedalSmoothness = uint8(basetype.Uint8Invalid)
		return m
	}
	m.AvgLeftPedalSmoothness = uint8(unscaled)
	return m
}

// SetAvgRightPedalSmoothness sets AvgRightPedalSmoothness value.
//
// Scale: 2; Units: percent
func (m *SegmentLap) SetAvgRightPedalSmoothness(v uint8) *SegmentLap {
	m.AvgRightPedalSmoothness = v
	return m
}

// SetAvgRightPedalSmoothnessScaled is similar to SetAvgRightPedalSmoothness except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 2; Units: percent
func (m *SegmentLap) SetAvgRightPedalSmoothnessScaled(v float64) *SegmentLap {
	unscaled := (v + 0) * 2
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.AvgRightPedalSmoothness = uint8(basetype.Uint8Invalid)
		return m
	}
	m.AvgRightPedalSmoothness = uint8(unscaled)
	return m
}

// SetAvgCombinedPedalSmoothness sets AvgCombinedPedalSmoothness value.
//
// Scale: 2; Units: percent
func (m *SegmentLap) SetAvgCombinedPedalSmoothness(v uint8) *SegmentLap {
	m.AvgCombinedPedalSmoothness = v
	return m
}

// SetAvgCombinedPedalSmoothnessScaled is similar to SetAvgCombinedPedalSmoothness except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 2; Units: percent
func (m *SegmentLap) SetAvgCombinedPedalSmoothnessScaled(v float64) *SegmentLap {
	unscaled := (v + 0) * 2
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.AvgCombinedPedalSmoothness = uint8(basetype.Uint8Invalid)
		return m
	}
	m.AvgCombinedPedalSmoothness = uint8(unscaled)
	return m
}

// SetStatus sets Status value.
func (m *SegmentLap) SetStatus(v typedef.SegmentLapStatus) *SegmentLap {
	m.Status = v
	return m
}

// SetUuid sets Uuid value.
func (m *SegmentLap) SetUuid(v string) *SegmentLap {
	m.Uuid = v
	return m
}

// SetAvgFractionalCadence sets AvgFractionalCadence value.
//
// Scale: 128; Units: rpm; fractional part of the avg_cadence
func (m *SegmentLap) SetAvgFractionalCadence(v uint8) *SegmentLap {
	m.AvgFractionalCadence = v
	return m
}

// SetAvgFractionalCadenceScaled is similar to SetAvgFractionalCadence except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 128; Units: rpm; fractional part of the avg_cadence
func (m *SegmentLap) SetAvgFractionalCadenceScaled(v float64) *SegmentLap {
	unscaled := (v + 0) * 128
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.AvgFractionalCadence = uint8(basetype.Uint8Invalid)
		return m
	}
	m.AvgFractionalCadence = uint8(unscaled)
	return m
}

// SetMaxFractionalCadence sets MaxFractionalCadence value.
//
// Scale: 128; Units: rpm; fractional part of the max_cadence
func (m *SegmentLap) SetMaxFractionalCadence(v uint8) *SegmentLap {
	m.MaxFractionalCadence = v
	return m
}

// SetMaxFractionalCadenceScaled is similar to SetMaxFractionalCadence except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 128; Units: rpm; fractional part of the max_cadence
func (m *SegmentLap) SetMaxFractionalCadenceScaled(v float64) *SegmentLap {
	unscaled := (v + 0) * 128
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.MaxFractionalCadence = uint8(basetype.Uint8Invalid)
		return m
	}
	m.MaxFractionalCadence = uint8(unscaled)
	return m
}

// SetTotalFractionalCycles sets TotalFractionalCycles value.
//
// Scale: 128; Units: cycles; fractional part of the total_cycles
func (m *SegmentLap) SetTotalFractionalCycles(v uint8) *SegmentLap {
	m.TotalFractionalCycles = v
	return m
}

// SetTotalFractionalCyclesScaled is similar to SetTotalFractionalCycles except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 128; Units: cycles; fractional part of the total_cycles
func (m *SegmentLap) SetTotalFractionalCyclesScaled(v float64) *SegmentLap {
	unscaled := (v + 0) * 128
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.TotalFractionalCycles = uint8(basetype.Uint8Invalid)
		return m
	}
	m.TotalFractionalCycles = uint8(unscaled)
	return m
}

// SetFrontGearShiftCount sets FrontGearShiftCount value.
func (m *SegmentLap) SetFrontGearShiftCount(v uint16) *SegmentLap {
	m.FrontGearShiftCount = v
	return m
}

// SetRearGearShiftCount sets RearGearShiftCount value.
func (m *SegmentLap) SetRearGearShiftCount(v uint16) *SegmentLap {
	m.RearGearShiftCount = v
	return m
}

// SetTimeStanding sets TimeStanding value.
//
// Scale: 1000; Units: s; Total time spent in the standing position
func (m *SegmentLap) SetTimeStanding(v uint32) *SegmentLap {
	m.TimeStanding = v
	return m
}

// SetTimeStandingScaled is similar to SetTimeStanding except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 1000; Units: s; Total time spent in the standing position
func (m *SegmentLap) SetTimeStandingScaled(v float64) *SegmentLap {
	unscaled := (v + 0) * 1000
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.TimeStanding = uint32(basetype.Uint32Invalid)
		return m
	}
	m.TimeStanding = uint32(unscaled)
	return m
}

// SetStandCount sets StandCount value.
//
// Number of transitions to the standing state
func (m *SegmentLap) SetStandCount(v uint16) *SegmentLap {
	m.StandCount = v
	return m
}

// SetAvgLeftPco sets AvgLeftPco value.
//
// Units: mm; Average left platform center offset
func (m *SegmentLap) SetAvgLeftPco(v int8) *SegmentLap {
	m.AvgLeftPco = v
	return m
}

// SetAvgRightPco sets AvgRightPco value.
//
// Units: mm; Average right platform center offset
func (m *SegmentLap) SetAvgRightPco(v int8) *SegmentLap {
	m.AvgRightPco = v
	return m
}

// SetAvgLeftPowerPhase sets AvgLeftPowerPhase value.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average left power phase angles. Data value indexes defined by power_phase_type.
func (m *SegmentLap) SetAvgLeftPowerPhase(v []uint8) *SegmentLap {
	m.AvgLeftPowerPhase = v
	return m
}

// SetAvgLeftPowerPhaseScaled is similar to SetAvgLeftPowerPhase except it accepts a scaled value.
// This method automatically converts the given value to its []uint8 form, discarding any applied scale and offset.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average left power phase angles. Data value indexes defined by power_phase_type.
func (m *SegmentLap) SetAvgLeftPowerPhaseScaled(vs []float64) *SegmentLap {
	if vs == nil {
		m.AvgLeftPowerPhase = nil
		return m
	}
	m.AvgLeftPowerPhase = make([]uint8, len(vs))
	for i := range vs {
		unscaled := (vs[i] + 0) * 0.7111111
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
			m.AvgLeftPowerPhase[i] = uint8(basetype.Uint8Invalid)
			continue
		}
		m.AvgLeftPowerPhase[i] = uint8(unscaled)
	}
	return m
}

// SetAvgLeftPowerPhasePeak sets AvgLeftPowerPhasePeak value.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average left power phase peak angles. Data value indexes defined by power_phase_type.
func (m *SegmentLap) SetAvgLeftPowerPhasePeak(v []uint8) *SegmentLap {
	m.AvgLeftPowerPhasePeak = v
	return m
}

// SetAvgLeftPowerPhasePeakScaled is similar to SetAvgLeftPowerPhasePeak except it accepts a scaled value.
// This method automatically converts the given value to its []uint8 form, discarding any applied scale and offset.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average left power phase peak angles. Data value indexes defined by power_phase_type.
func (m *SegmentLap) SetAvgLeftPowerPhasePeakScaled(vs []float64) *SegmentLap {
	if vs == nil {
		m.AvgLeftPowerPhasePeak = nil
		return m
	}
	m.AvgLeftPowerPhasePeak = make([]uint8, len(vs))
	for i := range vs {
		unscaled := (vs[i] + 0) * 0.7111111
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
			m.AvgLeftPowerPhasePeak[i] = uint8(basetype.Uint8Invalid)
			continue
		}
		m.AvgLeftPowerPhasePeak[i] = uint8(unscaled)
	}
	return m
}

// SetAvgRightPowerPhase sets AvgRightPowerPhase value.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average right power phase angles. Data value indexes defined by power_phase_type.
func (m *SegmentLap) SetAvgRightPowerPhase(v []uint8) *SegmentLap {
	m.AvgRightPowerPhase = v
	return m
}

// SetAvgRightPowerPhaseScaled is similar to SetAvgRightPowerPhase except it accepts a scaled value.
// This method automatically converts the given value to its []uint8 form, discarding any applied scale and offset.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average right power phase angles. Data value indexes defined by power_phase_type.
func (m *SegmentLap) SetAvgRightPowerPhaseScaled(vs []float64) *SegmentLap {
	if vs == nil {
		m.AvgRightPowerPhase = nil
		return m
	}
	m.AvgRightPowerPhase = make([]uint8, len(vs))
	for i := range vs {
		unscaled := (vs[i] + 0) * 0.7111111
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
			m.AvgRightPowerPhase[i] = uint8(basetype.Uint8Invalid)
			continue
		}
		m.AvgRightPowerPhase[i] = uint8(unscaled)
	}
	return m
}

// SetAvgRightPowerPhasePeak sets AvgRightPowerPhasePeak value.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average right power phase peak angles. Data value indexes defined by power_phase_type.
func (m *SegmentLap) SetAvgRightPowerPhasePeak(v []uint8) *SegmentLap {
	m.AvgRightPowerPhasePeak = v
	return m
}

// SetAvgRightPowerPhasePeakScaled is similar to SetAvgRightPowerPhasePeak except it accepts a scaled value.
// This method automatically converts the given value to its []uint8 form, discarding any applied scale and offset.
//
// Array: [N]; Scale: 0.7111111; Units: degrees; Average right power phase peak angles. Data value indexes defined by power_phase_type.
func (m *SegmentLap) SetAvgRightPowerPhasePeakScaled(vs []float64) *SegmentLap {
	if vs == nil {
		m.AvgRightPowerPhasePeak = nil
		return m
	}
	m.AvgRightPowerPhasePeak = make([]uint8, len(vs))
	for i := range vs {
		unscaled := (vs[i] + 0) * 0.7111111
		if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
			m.AvgRightPowerPhasePeak[i] = uint8(basetype.Uint8Invalid)
			continue
		}
		m.AvgRightPowerPhasePeak[i] = uint8(unscaled)
	}
	return m
}

// SetAvgPowerPosition sets AvgPowerPosition value.
//
// Array: [N]; Units: watts; Average power by position. Data value indexes defined by rider_position_type.
func (m *SegmentLap) SetAvgPowerPosition(v []uint16) *SegmentLap {
	m.AvgPowerPosition = v
	return m
}

// SetMaxPowerPosition sets MaxPowerPosition value.
//
// Array: [N]; Units: watts; Maximum power by position. Data value indexes defined by rider_position_type.
func (m *SegmentLap) SetMaxPowerPosition(v []uint16) *SegmentLap {
	m.MaxPowerPosition = v
	return m
}

// SetAvgCadencePosition sets AvgCadencePosition value.
//
// Array: [N]; Units: rpm; Average cadence by position. Data value indexes defined by rider_position_type.
func (m *SegmentLap) SetAvgCadencePosition(v []uint8) *SegmentLap {
	m.AvgCadencePosition = v
	return m
}

// SetMaxCadencePosition sets MaxCadencePosition value.
//
// Array: [N]; Units: rpm; Maximum cadence by position. Data value indexes defined by rider_position_type.
func (m *SegmentLap) SetMaxCadencePosition(v []uint8) *SegmentLap {
	m.MaxCadencePosition = v
	return m
}

// SetManufacturer sets Manufacturer value.
//
// Manufacturer that produced the segment
func (m *SegmentLap) SetManufacturer(v typedef.Manufacturer) *SegmentLap {
	m.Manufacturer = v
	return m
}

// SetTotalGrit sets TotalGrit value.
//
// Units: kGrit; The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes.
func (m *SegmentLap) SetTotalGrit(v float32) *SegmentLap {
	m.TotalGrit = v
	return m
}

// SetTotalFlow sets TotalFlow value.
//
// Units: Flow; The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals.
func (m *SegmentLap) SetTotalFlow(v float32) *SegmentLap {
	m.TotalFlow = v
	return m
}

// SetAvgGrit sets AvgGrit value.
//
// Units: kGrit; The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes.
func (m *SegmentLap) SetAvgGrit(v float32) *SegmentLap {
	m.AvgGrit = v
	return m
}

// SetAvgFlow sets AvgFlow value.
//
// Units: Flow; The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals.
func (m *SegmentLap) SetAvgFlow(v float32) *SegmentLap {
	m.AvgFlow = v
	return m
}

// SetTotalFractionalAscent sets TotalFractionalAscent value.
//
// Scale: 100; Units: m; fractional part of total_ascent
func (m *SegmentLap) SetTotalFractionalAscent(v uint8) *SegmentLap {
	m.TotalFractionalAscent = v
	return m
}

// SetTotalFractionalAscentScaled is similar to SetTotalFractionalAscent except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 100; Units: m; fractional part of total_ascent
func (m *SegmentLap) SetTotalFractionalAscentScaled(v float64) *SegmentLap {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.TotalFractionalAscent = uint8(basetype.Uint8Invalid)
		return m
	}
	m.TotalFractionalAscent = uint8(unscaled)
	return m
}

// SetTotalFractionalDescent sets TotalFractionalDescent value.
//
// Scale: 100; Units: m; fractional part of total_descent
func (m *SegmentLap) SetTotalFractionalDescent(v uint8) *SegmentLap {
	m.TotalFractionalDescent = v
	return m
}

// SetTotalFractionalDescentScaled is similar to SetTotalFractionalDescent except it accepts a scaled value.
// This method automatically converts the given value to its uint8 form, discarding any applied scale and offset.
//
// Scale: 100; Units: m; fractional part of total_descent
func (m *SegmentLap) SetTotalFractionalDescentScaled(v float64) *SegmentLap {
	unscaled := (v + 0) * 100
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint8Invalid) {
		m.TotalFractionalDescent = uint8(basetype.Uint8Invalid)
		return m
	}
	m.TotalFractionalDescent = uint8(unscaled)
	return m
}

// SetEnhancedAvgAltitude sets EnhancedAvgAltitude value.
//
// Scale: 5; Offset: 500; Units: m
func (m *SegmentLap) SetEnhancedAvgAltitude(v uint32) *SegmentLap {
	m.EnhancedAvgAltitude = v
	return m
}

// SetEnhancedAvgAltitudeScaled is similar to SetEnhancedAvgAltitude except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 5; Offset: 500; Units: m
func (m *SegmentLap) SetEnhancedAvgAltitudeScaled(v float64) *SegmentLap {
	unscaled := (v + 500) * 5
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.EnhancedAvgAltitude = uint32(basetype.Uint32Invalid)
		return m
	}
	m.EnhancedAvgAltitude = uint32(unscaled)
	return m
}

// SetEnhancedMaxAltitude sets EnhancedMaxAltitude value.
//
// Scale: 5; Offset: 500; Units: m
func (m *SegmentLap) SetEnhancedMaxAltitude(v uint32) *SegmentLap {
	m.EnhancedMaxAltitude = v
	return m
}

// SetEnhancedMaxAltitudeScaled is similar to SetEnhancedMaxAltitude except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 5; Offset: 500; Units: m
func (m *SegmentLap) SetEnhancedMaxAltitudeScaled(v float64) *SegmentLap {
	unscaled := (v + 500) * 5
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.EnhancedMaxAltitude = uint32(basetype.Uint32Invalid)
		return m
	}
	m.EnhancedMaxAltitude = uint32(unscaled)
	return m
}

// SetEnhancedMinAltitude sets EnhancedMinAltitude value.
//
// Scale: 5; Offset: 500; Units: m
func (m *SegmentLap) SetEnhancedMinAltitude(v uint32) *SegmentLap {
	m.EnhancedMinAltitude = v
	return m
}

// SetEnhancedMinAltitudeScaled is similar to SetEnhancedMinAltitude except it accepts a scaled value.
// This method automatically converts the given value to its uint32 form, discarding any applied scale and offset.
//
// Scale: 5; Offset: 500; Units: m
func (m *SegmentLap) SetEnhancedMinAltitudeScaled(v float64) *SegmentLap {
	unscaled := (v + 500) * 5
	if math.IsNaN(unscaled) || math.IsInf(unscaled, 0) || unscaled > float64(basetype.Uint32Invalid) {
		m.EnhancedMinAltitude = uint32(basetype.Uint32Invalid)
		return m
	}
	m.EnhancedMinAltitude = uint32(unscaled)
	return m
}

// SetDeveloperFields SegmentLap's DeveloperFields.
func (m *SegmentLap) SetDeveloperFields(developerFields ...proto.DeveloperField) *SegmentLap {
	m.DeveloperFields = developerFields
	return m
}

// MarkAsExpandedField marks whether given fieldNum is an expanded field (field that being
// generated through a component expansion). Eligible for field number: 91, 92, 93.
func (m *SegmentLap) MarkAsExpandedField(fieldNum byte, flag bool) (ok bool) {
	switch fieldNum {
	case 91, 92, 93:
	default:
		return false
	}
	pos := fieldNum / 8
	bit := uint8(1) << (fieldNum - (8 * pos))
	m.state[pos] &^= bit
	if flag {
		m.state[pos] |= bit
	}
	return true
}

// IsExpandedField checks whether given fieldNum is a field generated through
// a component expansion. Eligible for field number: 91, 92, 93.
func (m *SegmentLap) IsExpandedField(fieldNum byte) bool {
	if fieldNum >= 94 {
		return false
	}
	pos := fieldNum / 8
	bit := uint8(1) << (fieldNum - (8 * pos))
	return m.state[pos]&bit == bit
}
