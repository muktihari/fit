// Code generated by internal/cmd/fitgen/main.go. DO NOT EDIT.

// Copyright 2023 The Fit SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package mesgdef

import (
	"github.com/muktihari/fit/factory"
	"github.com/muktihari/fit/kit/scaleoffset"
	"github.com/muktihari/fit/kit/typeconv"
	"github.com/muktihari/fit/profile/basetype"
	"github.com/muktihari/fit/profile/typedef"
	"github.com/muktihari/fit/proto"
)

// DiveAlarm is a DiveAlarm message.
type DiveAlarm struct {
	DiveTypes        []typedef.SubSport    // Array: [N]; Dive types the alarm will trigger on
	Depth            uint32                // Scale: 1000; Units: m; Depth setting (m) for depth type alarms
	Time             int32                 // Units: s; Time setting (s) for time type alarms
	Id               uint32                // Alarm ID
	Speed            int32                 // Scale: 1000; Units: mps; Ascent/descent rate (mps) setting for speed type alarms
	MessageIndex     typedef.MessageIndex  // Index of the alarm
	AlarmType        typedef.DiveAlarmType // Alarm type setting
	Sound            typedef.Tone          // Tone and Vibe setting for the alarm
	Enabled          bool                  // Enablement flag
	PopupEnabled     bool                  // Show a visible pop-up for this alarm
	TriggerOnDescent bool                  // Trigger the alarm on descent
	TriggerOnAscent  bool                  // Trigger the alarm on ascent
	Repeating        bool                  // Repeat alarm each time threshold is crossed?

	// Developer Fields are dynamic, can't be mapped as struct's fields.
	// [Added since protocol version 2.0]
	DeveloperFields []proto.DeveloperField
}

// NewDiveAlarm creates new DiveAlarm struct based on given mesg.
// If mesg is nil, it will return DiveAlarm with all fields being set to its corresponding invalid value.
func NewDiveAlarm(mesg *proto.Message) *DiveAlarm {
	vals := [255]any{}

	var developerFields []proto.DeveloperField
	if mesg != nil {
		for i := range mesg.Fields {
			if mesg.Fields[i].Num >= byte(len(vals)) {
				continue
			}
			vals[mesg.Fields[i].Num] = mesg.Fields[i].Value
		}
		developerFields = mesg.DeveloperFields
	}

	return &DiveAlarm{
		DiveTypes:        typeconv.ToSliceEnum[typedef.SubSport](vals[5]),
		Depth:            typeconv.ToUint32[uint32](vals[0]),
		Time:             typeconv.ToSint32[int32](vals[1]),
		Id:               typeconv.ToUint32[uint32](vals[6]),
		Speed:            typeconv.ToSint32[int32](vals[11]),
		MessageIndex:     typeconv.ToUint16[typedef.MessageIndex](vals[254]),
		AlarmType:        typeconv.ToEnum[typedef.DiveAlarmType](vals[3]),
		Sound:            typeconv.ToEnum[typedef.Tone](vals[4]),
		Enabled:          typeconv.ToBool[bool](vals[2]),
		PopupEnabled:     typeconv.ToBool[bool](vals[7]),
		TriggerOnDescent: typeconv.ToBool[bool](vals[8]),
		TriggerOnAscent:  typeconv.ToBool[bool](vals[9]),
		Repeating:        typeconv.ToBool[bool](vals[10]),

		DeveloperFields: developerFields,
	}
}

// ToMesg converts DiveAlarm into proto.Message. If options is nil, default options will be used.
func (m *DiveAlarm) ToMesg(options *Options) proto.Message {
	if options == nil {
		options = defaultOptions
	} else if options.Factory == nil {
		options.Factory = factory.StandardFactory()
	}

	fac := options.Factory

	fieldsArray := fieldsPool.Get().(*[256]proto.Field)
	defer fieldsPool.Put(fieldsArray)

	fields := (*fieldsArray)[:0] // Create slice from array with zero len.
	mesg := fac.CreateMesgOnly(typedef.MesgNumDiveAlarm)

	if typeconv.ToSliceEnum[byte](m.DiveTypes) != nil {
		field := fac.CreateField(mesg.Num, 5)
		field.Value = typeconv.ToSliceEnum[byte](m.DiveTypes)
		fields = append(fields, field)
	}
	if m.Depth != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 0)
		field.Value = m.Depth
		fields = append(fields, field)
	}
	if m.Time != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 1)
		field.Value = m.Time
		fields = append(fields, field)
	}
	if m.Id != basetype.Uint32Invalid {
		field := fac.CreateField(mesg.Num, 6)
		field.Value = m.Id
		fields = append(fields, field)
	}
	if m.Speed != basetype.Sint32Invalid {
		field := fac.CreateField(mesg.Num, 11)
		field.Value = m.Speed
		fields = append(fields, field)
	}
	if uint16(m.MessageIndex) != basetype.Uint16Invalid {
		field := fac.CreateField(mesg.Num, 254)
		field.Value = uint16(m.MessageIndex)
		fields = append(fields, field)
	}
	if byte(m.AlarmType) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 3)
		field.Value = byte(m.AlarmType)
		fields = append(fields, field)
	}
	if byte(m.Sound) != basetype.EnumInvalid {
		field := fac.CreateField(mesg.Num, 4)
		field.Value = byte(m.Sound)
		fields = append(fields, field)
	}
	if m.Enabled != false {
		field := fac.CreateField(mesg.Num, 2)
		field.Value = m.Enabled
		fields = append(fields, field)
	}
	if m.PopupEnabled != false {
		field := fac.CreateField(mesg.Num, 7)
		field.Value = m.PopupEnabled
		fields = append(fields, field)
	}
	if m.TriggerOnDescent != false {
		field := fac.CreateField(mesg.Num, 8)
		field.Value = m.TriggerOnDescent
		fields = append(fields, field)
	}
	if m.TriggerOnAscent != false {
		field := fac.CreateField(mesg.Num, 9)
		field.Value = m.TriggerOnAscent
		fields = append(fields, field)
	}
	if m.Repeating != false {
		field := fac.CreateField(mesg.Num, 10)
		field.Value = m.Repeating
		fields = append(fields, field)
	}

	mesg.Fields = make([]proto.Field, len(fields))
	copy(mesg.Fields, fields)

	mesg.DeveloperFields = m.DeveloperFields

	return mesg
}

// DepthScaled return Depth in its scaled value [Scale: 1000; Units: m; Depth setting (m) for depth type alarms].
//
// If Depth value is invalid, float64 invalid value will be returned.
func (m *DiveAlarm) DepthScaled() float64 {
	if m.Depth == basetype.Uint32Invalid {
		return basetype.Float64InvalidInFloatForm()
	}
	return scaleoffset.Apply(m.Depth, 1000, 0)
}

// SpeedScaled return Speed in its scaled value [Scale: 1000; Units: mps; Ascent/descent rate (mps) setting for speed type alarms].
//
// If Speed value is invalid, float64 invalid value will be returned.
func (m *DiveAlarm) SpeedScaled() float64 {
	if m.Speed == basetype.Sint32Invalid {
		return basetype.Float64InvalidInFloatForm()
	}
	return scaleoffset.Apply(m.Speed, 1000, 0)
}

// SetDiveTypes sets DiveAlarm value.
//
// Array: [N]; Dive types the alarm will trigger on
func (m *DiveAlarm) SetDiveTypes(v []typedef.SubSport) *DiveAlarm {
	m.DiveTypes = v
	return m
}

// SetDepth sets DiveAlarm value.
//
// Scale: 1000; Units: m; Depth setting (m) for depth type alarms
func (m *DiveAlarm) SetDepth(v uint32) *DiveAlarm {
	m.Depth = v
	return m
}

// SetTime sets DiveAlarm value.
//
// Units: s; Time setting (s) for time type alarms
func (m *DiveAlarm) SetTime(v int32) *DiveAlarm {
	m.Time = v
	return m
}

// SetId sets DiveAlarm value.
//
// Alarm ID
func (m *DiveAlarm) SetId(v uint32) *DiveAlarm {
	m.Id = v
	return m
}

// SetSpeed sets DiveAlarm value.
//
// Scale: 1000; Units: mps; Ascent/descent rate (mps) setting for speed type alarms
func (m *DiveAlarm) SetSpeed(v int32) *DiveAlarm {
	m.Speed = v
	return m
}

// SetMessageIndex sets DiveAlarm value.
//
// Index of the alarm
func (m *DiveAlarm) SetMessageIndex(v typedef.MessageIndex) *DiveAlarm {
	m.MessageIndex = v
	return m
}

// SetAlarmType sets DiveAlarm value.
//
// Alarm type setting
func (m *DiveAlarm) SetAlarmType(v typedef.DiveAlarmType) *DiveAlarm {
	m.AlarmType = v
	return m
}

// SetSound sets DiveAlarm value.
//
// Tone and Vibe setting for the alarm
func (m *DiveAlarm) SetSound(v typedef.Tone) *DiveAlarm {
	m.Sound = v
	return m
}

// SetEnabled sets DiveAlarm value.
//
// Enablement flag
func (m *DiveAlarm) SetEnabled(v bool) *DiveAlarm {
	m.Enabled = v
	return m
}

// SetPopupEnabled sets DiveAlarm value.
//
// Show a visible pop-up for this alarm
func (m *DiveAlarm) SetPopupEnabled(v bool) *DiveAlarm {
	m.PopupEnabled = v
	return m
}

// SetTriggerOnDescent sets DiveAlarm value.
//
// Trigger the alarm on descent
func (m *DiveAlarm) SetTriggerOnDescent(v bool) *DiveAlarm {
	m.TriggerOnDescent = v
	return m
}

// SetTriggerOnAscent sets DiveAlarm value.
//
// Trigger the alarm on ascent
func (m *DiveAlarm) SetTriggerOnAscent(v bool) *DiveAlarm {
	m.TriggerOnAscent = v
	return m
}

// SetRepeating sets DiveAlarm value.
//
// Repeat alarm each time threshold is crossed?
func (m *DiveAlarm) SetRepeating(v bool) *DiveAlarm {
	m.Repeating = v
	return m
}

// SetDeveloperFields DiveAlarm's DeveloperFields.
func (m *DiveAlarm) SetDeveloperFields(developerFields ...proto.DeveloperField) *DiveAlarm {
	m.DeveloperFields = developerFields
	return m
}
