// Copyright 2023 The Fit SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package typedef

import (
	"encoding/binary"
	"errors"
	"fmt"
	"math"
	"reflect"
)

var (
	ErrNilDest          = errors.New("nil dest")
	ErrNilValue         = errors.New("nil value")
	ErrTypeNotSupported = errors.New("type is not supported")
)

// Marshal v into []byte supporting primitive types, types generated by fitgen, and other type definitions as long as they point to primitive values.
func Marshal(v any, bo binary.ByteOrder) ([]byte, error) {
	var b []byte
	if err := MarshalTo(&b, v, bo); err != nil {
		return nil, err
	}
	return b, nil
}

// MarshalTo is a zero-alloc marshal function that will marshal v into []byte append it to given dest.
// It support primitive types, types generated by fitgen, and other type definitions as long as they point to primitive values (or slice of the types)
func MarshalTo(dest *[]byte, value any, bo binary.ByteOrder) error {
	if dest == nil {
		return fmt.Errorf("dest could not be: %w", ErrNilDest)
	}

	if value == nil {
		return ErrNilValue
	}

	switch val := value.(type) { // Fast path
	case bool:
		var boolean byte
		if val {
			boolean = 1
		}
		*dest = append(*dest, boolean)
		return nil
	case []bool:
		for i := range val {
			if val[i] {
				*dest = append(*dest, 1)
			} else {
				*dest = append(*dest, 0)
			}
		}
		return nil
	case int8:
		*dest = append(*dest, byte(val))
		return nil
	case []int8:
		for i := range val {
			*dest = append(*dest, byte(val[i]))
		}
		return nil
	case uint8:
		*dest = append(*dest, byte(val))
		return nil
	case []uint8:
		*dest = append(*dest, val...)
		return nil
	case int16:
		cur := len(*dest)
		*dest = append(*dest, 0, 0)
		bo.PutUint16((*dest)[cur:], uint16(val))
		return nil
	case []int16:
		const n = 2
		cur := len(*dest)
		for i := range val {
			*dest = append(*dest, 0, 0)
			bo.PutUint16((*dest)[cur:cur+n], uint16(val[i]))
			cur += n
		}
		return nil
	case uint16:
		cur := len(*dest)
		*dest = append(*dest, 0, 0)
		bo.PutUint16((*dest)[cur:], val)
		return nil
	case []uint16:
		const n = 2
		cur := len(*dest)
		for i := range val {
			*dest = append(*dest, 0, 0)
			bo.PutUint16((*dest)[cur:cur+n], val[i])
			cur += n
		}
		return nil
	case int32:
		cur := len(*dest)
		*dest = append(*dest, 0, 0, 0, 0)
		bo.PutUint32((*dest)[cur:], uint32(val))
		return nil
	case []int32:
		const n = 4
		cur := len(*dest)
		for i := range val {
			*dest = append(*dest, 0, 0, 0, 0)
			bo.PutUint32((*dest)[cur:cur+n], uint32(val[i]))
			cur += n
		}
		return nil
	case uint32:
		cur := len(*dest)
		*dest = append(*dest, 0, 0, 0, 0)
		bo.PutUint32((*dest)[cur:], val)
		return nil
	case []uint32:
		const n = 4
		cur := len(*dest)
		for i := range val {
			*dest = append(*dest, 0, 0, 0, 0)
			bo.PutUint32((*dest)[cur:cur+n], val[i])
			cur += n
		}
		return nil
	case int64:
		cur := len(*dest)
		*dest = append(*dest, 0, 0, 0, 0, 0, 0, 0, 0)
		bo.PutUint64((*dest)[cur:], uint64(val))
		return nil
	case []int64:
		const n = 8
		cur := len(*dest)
		for i := range val {
			*dest = append(*dest, 0, 0, 0, 0, 0, 0, 0, 0)
			bo.PutUint64((*dest)[cur:cur+n], uint64(val[i]))
			cur += n
		}
		return nil
	case uint64:
		cur := len(*dest)
		*dest = append(*dest, 0, 0, 0, 0, 0, 0, 0, 0)
		bo.PutUint64((*dest)[cur:], val)
		return nil
	case []uint64:
		const n = 8
		cur := len(*dest)
		for i := range val {
			*dest = append(*dest, 0, 0, 0, 0, 0, 0, 0, 0)
			bo.PutUint64((*dest)[cur:cur+n], val[i])
			cur += n
		}
		return nil
	case float32:
		cur := len(*dest)
		v := math.Float32bits(val)
		*dest = append(*dest, 0, 0, 0, 0)
		bo.PutUint32((*dest)[cur:], v)
		return nil
	case []float32:
		const n = 4
		cur := len(*dest)
		for i := range val {
			*dest = append(*dest, 0, 0, 0, 0)
			bo.PutUint32((*dest)[cur:cur+n], math.Float32bits(val[i]))
			cur += n
		}
		return nil
	case float64:
		v := math.Float64bits(val)
		cur := len(*dest)
		*dest = append(*dest, 0, 0, 0, 0, 0, 0, 0, 0)
		bo.PutUint64((*dest)[cur:], v)
		return nil
	case []float64:
		const n = 8
		cur := len(*dest)
		for i := range val {
			*dest = append(*dest, 0, 0, 0, 0, 0, 0, 0, 0)
			bo.PutUint64((*dest)[cur:cur+n], math.Float64bits(val[i]))
			cur += n
		}
		return nil
	case string:
		if len(val) == 0 {
			*dest = append(*dest, 0x00)
			return nil
		}
		*dest = append(*dest, val...)
		if val[len(val)-1] != '\x00' {
			*dest = append(*dest, '\x00') // add utf-8 null-terminated string
		}
		return nil
	case []string:
		for i := range val {
			if len(val[i]) == 0 {
				*dest = append(*dest, '\x00')
				continue
			}
			*dest = append(*dest, val[i]...)
			if val[i][len(val[i])-1] != '\x00' {
				*dest = append(*dest, '\x00')
			}
		}
		return nil
	case []any:
		return fmt.Errorf("type %T is not supported: %w", val, ErrTypeNotSupported)
	}

	// Fallback to reflection.
	rv := reflect.Indirect(reflect.ValueOf(value)) // accept pointer value

	if !rv.IsValid() {
		return fmt.Errorf("type %T is not supported: %w", value, ErrTypeNotSupported)
	}

	switch rv.Type().Kind() {
	case reflect.Bool:
		val := rv.Bool()
		var boolean byte
		if val {
			boolean = 1
		}
		*dest = append(*dest, boolean)
		return nil
	case reflect.Int8:
		*dest = append(*dest, byte(rv.Int()))
		return nil
	case reflect.Uint8:
		*dest = append(*dest, byte(rv.Uint()))
		return nil
	case reflect.Int16:
		cur := len(*dest)
		*dest = append(*dest, 0, 0)
		bo.PutUint16((*dest)[cur:], uint16(rv.Int()))
		return nil
	case reflect.Uint16:
		cur := len(*dest)
		*dest = append(*dest, 0, 0)
		bo.PutUint16((*dest)[cur:], uint16(rv.Uint()))
		return nil
	case reflect.Int32:
		cur := len(*dest)
		*dest = append(*dest, 0, 0, 0, 0)
		bo.PutUint32((*dest)[cur:], uint32(rv.Int()))
		return nil
	case reflect.Uint32:
		cur := len(*dest)
		*dest = append(*dest, 0, 0, 0, 0)
		bo.PutUint32((*dest)[cur:], uint32(rv.Uint()))
		return nil
	case reflect.Int64:
		cur := len(*dest)
		*dest = append(*dest, 0, 0, 0, 0, 0, 0, 0, 0)
		bo.PutUint64((*dest)[cur:], uint64(rv.Int()))
		return nil
	case reflect.Uint64:
		cur := len(*dest)
		*dest = append(*dest, 0, 0, 0, 0, 0, 0, 0, 0)
		bo.PutUint64((*dest)[cur:], rv.Uint())
		return nil
	case reflect.Float32:
		cur := len(*dest)
		v := math.Float32bits(float32(rv.Float()))
		*dest = append(*dest, 0, 0, 0, 0)
		bo.PutUint32((*dest)[cur:], v)
		return nil
	case reflect.Float64:
		v := math.Float64bits(rv.Float())
		cur := len(*dest)
		*dest = append(*dest, 0, 0, 0, 0, 0, 0, 0, 0)
		bo.PutUint64((*dest)[cur:], v)
		return nil
	case reflect.String:
		s := rv.String()
		if len(s) == 0 {
			*dest = append(*dest, 0x00)
			return nil
		}
		*dest = append(*dest, s...)
		if (*dest)[len(*dest)-1] != '\x00' {
			*dest = append(*dest, '\x00') // add utf-8 null-terminated string
		}
		return nil
	case reflect.Slice:
		rv := reflect.ValueOf(value)
		for i := 0; i < rv.Len(); i++ {
			index := rv.Index(i)
			if index.Kind() == reflect.Interface {
				index = index.Elem()
			}

			if index.Kind() == reflect.Slice {
				return fmt.Errorf("nested slice is not supported: %w", ErrTypeNotSupported)
			}

			if !index.IsValid() {
				return fmt.Errorf("type %T is not supported: %w", value, ErrTypeNotSupported)
			}

			// NOTE/PERF: If this too slow, let's declare switch elem.Kind() here to avoid recursive, a function call has a cost.
			// If after doing that is still slow, let's use code generation to generate types assertion then make a benchmark to see which one is faster.
			bb, err := Marshal(index.Interface(), bo)
			if err != nil {
				return err
			}

			*dest = append(*dest, bb...)
		}

		return nil
	}

	return fmt.Errorf("type %T is not supported: %w", value, ErrTypeNotSupported)
}
