// Copyright 2023 The Fit SDK for Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package typedef

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"math"
	"reflect"

	"github.com/muktihari/fit/profile/basetype"
)

var (
	ErrNilValue         = errors.New("nil value")
	ErrTypeNotSupported = errors.New("type is not supported")
)

// Marshal v into []byte supporting primitive types, types generated by fitgen, and other type definitions as long as they point to primitive values.
func Marshal(v any, bo binary.ByteOrder) ([]byte, error) {
	if v == nil {
		return nil, ErrNilValue
	}

	switch val := v.(type) { // Fast path
	case bool:
		var boolean byte
		if val {
			boolean = 1
		}
		return []byte{byte(boolean)}, nil
	case []bool:
		b := make([]byte, 0, len(val))
		for i := range val {
			if val[i] {
				b = append(b, 1)
			} else {
				b = append(b, 0)
			}
		}
		return b, nil
	case int8:
		return []byte{byte(val)}, nil
	case []int8:
		b := make([]byte, 0, len(val))
		for i := range val {
			b = append(b, byte(val[i]))
		}
		return b, nil
	case uint8:
		return []byte{byte(val)}, nil
	case []uint8:
		return val, nil
	case int16:
		b := make([]byte, 2)
		bo.PutUint16(b, uint16(val))
		return b, nil
	case []int16:
		const n = 2
		cur := 0
		b := make([]byte, len(val)*n)
		for i := range val {
			bo.PutUint16(b[cur:cur+n], uint16(val[i]))
			cur += n
		}
		return b, nil
	case uint16:
		b := make([]byte, 2)
		bo.PutUint16(b, val)
		return b, nil
	case []uint16:
		const n = 2
		cur := 0
		b := make([]byte, len(val)*n)
		for i := range val {
			bo.PutUint16(b[cur:cur+n], val[i])
			cur += n
		}
		return b, nil
	case int32:
		b := make([]byte, 4)
		bo.PutUint32(b, uint32(val))
		return b, nil
	case []int32:
		const n = 4
		cur := 0
		b := make([]byte, len(val)*n)
		for i := range val {
			bo.PutUint32(b[cur:cur+n], uint32(val[i]))
			cur += n
		}
		return b, nil
	case uint32:
		b := make([]byte, 4)
		bo.PutUint32(b, val)
		return b, nil
	case []uint32:
		const n = 4
		cur := 0
		b := make([]byte, len(val)*n)
		for i := range val {
			bo.PutUint32(b[cur:cur+n], val[i])
			cur += n
		}
		return b, nil
	case int64:
		b := make([]byte, 8)
		bo.PutUint64(b, uint64(val))
		return b, nil
	case []int64:
		const n = 8
		cur := 0
		b := make([]byte, len(val)*n)
		for i := range val {
			bo.PutUint64(b[cur:cur+n], uint64(val[i]))
			cur += n
		}
		return b, nil
	case uint64:
		b := make([]byte, 8)
		bo.PutUint64(b, val)
		return b, nil
	case []uint64:
		const n = 8
		cur := 0
		b := make([]byte, len(val)*n)
		for i := range val {
			bo.PutUint64(b[cur:cur+n], val[i])
			cur += n
		}
		return b, nil
	case float32:
		v := math.Float32bits(val)
		b := make([]byte, 4)
		bo.PutUint32(b, v)
		return b, nil
	case []float32:
		const n = 4
		cur := 0
		b := make([]byte, len(val)*n)
		for i := range val {
			bo.PutUint32(b[cur:cur+n], math.Float32bits(val[i]))
			cur += n
		}
		return b, nil
	case float64:
		v := math.Float64bits(val)
		b := make([]byte, 8)
		bo.PutUint64(b, v)
		return b, nil
	case []float64:
		const n = 8
		cur := 0
		b := make([]byte, len(val)*n)
		for i := range val {
			bo.PutUint64(b[cur:cur+n], math.Float64bits(val[i]))
			cur += n
		}
		return b, nil
	case string:
		if len(val) == 0 {
			return []byte(basetype.StringInvalid), nil
		}
		b := []byte(val)
		if b[len(b)-1] != '\x00' {
			b = append(b, '\x00') // add utf-8 null-terminated string
		}
		return b, nil
	case []string:
		var size int
		for i := range val {
			if len(val[i]) == 0 {
				continue
			}
			if len(val[i]) == 1 && val[i][0] == '\x00' {
				continue
			}
			size += len(val[i])
			if val[i][len(val[i])-1] != '\x00' {
				size += 1 // plus utf-8 null-terminated string
			}
		}
		b := make([]byte, 0, size)
		for i := range val {
			if len(val[i]) == 0 {
				continue
			}
			if len(val[i]) == 1 && val[i][0] == '\x00' {
				continue
			}
			b = append(b, []byte(val[i])...)
			if val[i][len(val[i])-1] != '\x00' {
				b = append(b, '\x00')
			}
		}
		return b, nil
	case []any:
		return nil, fmt.Errorf("type %T is not supported: %w", val, ErrTypeNotSupported)
	}

	// Fallback to reflection.
	rv := reflect.Indirect(reflect.ValueOf(v)) // accept pointer value

	if !rv.IsValid() {
		return nil, fmt.Errorf("type %T is not supported: %w", v, ErrTypeNotSupported)
	}

	switch rv.Type().Kind() {
	case reflect.Bool:
		val := rv.Bool()
		var boolean byte
		if val {
			boolean = 1
		}
		return []byte{byte(boolean)}, nil
	case reflect.Int8:
		return []byte{byte(int8(rv.Int()))}, nil
	case reflect.Uint8:
		return []byte{byte(uint8(rv.Uint()))}, nil
	case reflect.Int16:
		b := make([]byte, 2)
		bo.PutUint16(b, uint16(int16(rv.Int())))
		return b, nil
	case reflect.Uint16:
		b := make([]byte, 2)
		bo.PutUint16(b, uint16(rv.Uint()))
		return b, nil
	case reflect.Int32:
		b := make([]byte, 4)
		bo.PutUint32(b, uint32(int32(rv.Int())))
		return b, nil
	case reflect.Uint32:
		b := make([]byte, 4)
		bo.PutUint32(b, uint32(rv.Uint()))
		return b, nil
	case reflect.Int64:
		b := make([]byte, 8)
		bo.PutUint64(b, uint64(int64(rv.Int())))
		return b, nil
	case reflect.Uint64:
		b := make([]byte, 8)
		bo.PutUint64(b, uint64(rv.Uint()))
		return b, nil
	case reflect.Float32:
		v := math.Float32bits(float32(rv.Float()))
		b := make([]byte, 4)
		bo.PutUint32(b, v)
		return b, nil
	case reflect.Float64:
		v := math.Float64bits(float64(rv.Float()))
		b := make([]byte, 8)
		bo.PutUint64(b, v)
		return b, nil
	case reflect.String:
		if len(rv.String()) == 0 {
			return []byte(basetype.StringInvalid), nil
		}
		b := []byte(rv.String())
		if b[len(b)-1] != '\x00' {
			b = append(b, '\x00') // add utf-8 null-terminated string
		}
		return b, nil
	case reflect.Slice:
		buf := new(bytes.Buffer)
		rv := reflect.ValueOf(v)
		for i := 0; i < rv.Len(); i++ {
			index := rv.Index(i)
			if index.Kind() == reflect.Interface {
				index = index.Elem()
			}

			if index.Kind() == reflect.Slice {
				return nil, fmt.Errorf("nested slice is not supported: %w", ErrTypeNotSupported)
			}

			if !index.IsValid() {
				return nil, fmt.Errorf("type %T is not supported: %w", v, ErrTypeNotSupported)
			}

			// NOTE/PERF: If this too slow, let's declare switch elem.Kind() here to avoid recursive, a function call has a cost.
			// If after doing that is still slow, let's use code generation to generate types assertion then make a benchmark to see which one is faster.
			bb, err := Marshal(index.Interface(), bo)
			if err != nil {
				return nil, err
			}

			buf.Write(bb)
		}

		return buf.Bytes(), nil
	}

	return nil, fmt.Errorf("type %T is not supported: %w", v, ErrTypeNotSupported)
}
